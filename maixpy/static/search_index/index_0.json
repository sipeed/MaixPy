{"/maixpy/api/maix/peripheral/pinmap.html":{"title":"maix.peripheral.pinmap","content":" title: maix.peripheral.pinmap maix.peripheral.pinmap module > You can use `maix.peripheral.pinmap` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ## Variable {#Variable} ## Function {#Function} ### get\\_pins {#get\\_pins} ```python def get_pins() > list[str] ``` Get all pins of devices item description **return** pin name list, string type. > C++ defination code: > ```cpp > std::vector<std::string> get_pins() > ``` ### get\\_pin\\_functions {#get\\_pin\\_functions} ```python def get_pin_functions(pin: str) > list[str] ``` Get all function of a pin item description **param** **pin**: pin name, string type.<br> **return** function list, function name is string type. **throw** If pin name error will throwout err.Err.ERR_ARGS error. > C++ defination code: > ```cpp > std::vector<std::string> get_pin_functions(const std::string &pin) > ``` ### set\\_pin\\_function {#set\\_pin\\_function} ```python def set_pin_function(pin: str, func: str) > maix.err.Err ``` Set function of a pin item description **param** **pin**: pin name, string type.<br>**func**: which function should this pin use.<br> **return** if set ok, will return err.Err.ERR_NONE, else error occurs. > C++ defination code: > ```cpp > err::Err set_pin_function(const std::string &pin, const std::string &func) > ``` ### get\\_pin\\_function {#get\\_pin\\_function} ```python def get_pin_function(pin: str) > str ``` Get pin's current function item description **param** **pin**: pin name, string type.<br> **return** pin's current funtion name. **throw** If pin name error will throwout err.Err.ERR_ARGS error,<br>if not implement for this pin, or read/write register failed, will throwout err.Err.Exception. > C++ defination code: > ```cpp > std::string get_pin_function(const std::string &pin) > ``` ## Class {#Class}"},"/maixpy/api/maix/peripheral/uart.html":{"title":"maix.peripheral.uart","content":" title: maix.peripheral.uart maix uart peripheral driver > You can use `maix.peripheral.uart` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### PARITY {#PARITY} uart parity enum item describe **values** **PARITY_NONE**: no parity<br>**PARITY_ODD**: odd parity<br>**PARITY_EVEN**: even parity<br>**PARITY_MAX**: <br> > C++ defination code: > ```cpp > enum PARITY > { > PARITY_NONE 0x00, // no parity > PARITY_ODD 0x01, // odd parity > PARITY_EVEN 0x02, // even parity > PARITY_MAX > } > ``` ### STOP {#STOP} uart stop bits item describe **values** **STOP_1**: 1 stop bit<br>**STOP_2**: 2 stop bits<br>**STOP_1_5**: 1.5 stop bits<br>**STOP_MAX**: <br> > C++ defination code: > ```cpp > enum STOP > { > STOP_1 0x01, // 1 stop bit > STOP_2 0x02, // 2 stop bits > STOP_1_5 0x03, // 1.5 stop bits > STOP_MAX > } > ``` ### BITS {#BITS} uart stop bits item describe **values** **BITS_5**: 5 data bits<br>**BITS_6**: 6 data bits<br>**BITS_7**: 7 data bits<br>**BITS_8**: 8 data bits<br>**BITS_MAX**: <br> > C++ defination code: > ```cpp > enum BITS > { > BITS_5 5, // 5 data bits > BITS_6 6, // 6 data bits > BITS_7 7, // 7 data bits > BITS_8 8, // 8 data bits > BITS_MAX > } > ``` ### FLOW\\_CTRL {#FLOW\\_CTRL} uart flow control item describe **values** **FLOW_CTRL_NONE**: no flow control<br>**FLOW_CTRL_HW**: hardware flow control<br>**FLOW_CTRL_MAX**: <br> > C++ defination code: > ```cpp > enum FLOW_CTRL > { > FLOW_CTRL_NONE 0, // no flow control > FLOW_CTRL_HW 1, // hardware flow control > FLOW_CTRL_MAX > } > ``` ## Variable {#Variable} ## Function {#Function} ### list\\_devices {#list\\_devices} ```python def list_devices() > list[str] ``` Get supported uart ports. item description **return** uart ports list, string type. > C++ defination code: > ```cpp > std::vector<std::string> list_devices() > ``` ## Class {#Class} ### UART {#UART} maix uart peripheral driver > C++ defination code: > ```cpp > class UART : public comm::CommBase > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, port: str '', baudrate: int 115200, databits: BITS ..., parity: PARITY ..., stopbits: STOP ..., flow_ctrl: FLOW_CTRL ...) > None ``` UART constructor. You need to call open() to open the device. item description **type** func **param** **port**: uart port. string type, can get it by uart.list_devices().<br>If empty, will not open device in constructor, default empty.<br>if not empty, will auto open device in constructor, open fail will throw err.Exception.<br>**baudrate**: baudrate of uart. int type, default 115200.<br>**databits**: databits, values @see uart.DATA_BITS<br>**parity**: parity, values @see uart.PARITY<br>**stopbits**: stopbits, values @see uart.STOP_BITS<br>**flow_control**: flow_control, values @see uart.FLOW_CTRL<br> **static** False > C++ defination code: > ```cpp > UART(const std::string &port \"\", int baudrate 115200, uart::BITS databits uart::BITS_8, > uart::PARITY parity uart::PARITY_NONE, uart::STOP stopbits uart::STOP_1, > uart::FLOW_CTRL flow_ctrl uart::FLOW_CTRL_NONE) > ``` #### set\\_port {#set\\_port} ```python def set_port(self, port: str) > maix.err.Err ``` Set port item description **type** func **param** **port**: uart port. string type, can get it by uart.list_devices().<br> **return** set port error code, err.Err type. **static** False > C++ defination code: > ```cpp > err::Err set_port(const std::string &port) > ``` #### get\\_port {#get\\_port} ```python def get_port(self) > str ``` Get port item description **type** func **return** uart port, string type. **static** False > C++ defination code: > ```cpp > std::string get_port() > ``` #### set\\_baudrate {#set\\_baudrate} ```python def set_baudrate(self, baudrate: int) > maix.err.Err ``` Set baud rate item description **type** func **param** **baudrate**: baudrate of uart. int type, default 115200.<br> **return** set baud rate error code, err.Err type. **static** False > C++ defination code: > ```cpp > err::Err set_baudrate(int baudrate) > ``` #### get\\_baudrate {#get\\_baudrate} ```python def get_baudrate(self) > int ``` Get baud rate item description **type** func **return** baud rate, int type. **static** False > C++ defination code: > ```cpp > int get_baudrate() > ``` #### open {#open} ```python def open(self) > maix.err.Err ``` Open uart device, before open, port must be set in constructor or by set_port().\\nIf already opened, do nothing and return err.ERR_NONE. item description **type** func **return** open device error code, err.Err type. **static** False > C++ defination code: > ```cpp > err::Err open() > ``` #### is\\_open {#is\\_open} ```python def is_open(self) > bool ``` Check if device is opened. item description **type** func **return** true if opened, false if not opened. **static** False > C++ defination code: > ```cpp > bool is_open() > ``` #### close {#close} ```python def close(self) > maix.err.Err ``` Close uart device, if already closed, do nothing and return err.ERR_NONE. item description **type** func **return** close device error code, err.Err type. **static** False > C++ defination code: > ```cpp > err::Err close() > ``` #### set\\_received\\_callback {#set\\_received\\_callback} ```python def set_received_callback(self, callback: typing.Callable[[UART, maix.Bytes(bytes)], None]) > None ``` Set received callback function item description **type** func **param** **callback**: function to call when received data<br> **static** False > C++ defination code: > ```cpp > void set_received_callback(std::function<void(uart::UART&, Bytes&)> callback) > ``` #### write\\_str {#write\\_str} ```python def write_str(self, str: str) > int ``` Send string data item description **type** func **param** **str**: string data<br> **return** sent data length, < 0 means error, value is err.Err. **static** False > C++ defination code: > ```cpp > int write_str(const std::string &str) > ``` #### write {#write} ```python def write(self, data: maix.Bytes(bytes)) > int ``` Send data to uart item description **type** func **param** **data**: direction [in], data to send, bytes type. If you want to send str type, use str.encode() to convert.<br> **return** sent length, int type, if < 0 means error, value is err.Err. **static** False > C++ defination code: > ```cpp > int write(Bytes &data) > ``` #### available {#available} ```python def available(self, timeout: int 0) > int ``` Check if data available or wait data available. item description **type** func **param** **timeout**: unit ms, timeout to wait data, default 0.<br>0 means check data available and return immediately,<br>> 0 means wait until data available or timeout.<br> 1 means wait until data available.<br> **return** available data number, 0 if timeout or no data, <0 if error, value is err.Err, can be err::ERR_IO， err::ERR_CANCEL, err::ERR_NOT_OPEN. **throw** err.Exception if fatal error. **static** False > C++ defination code: > ```cpp > int available(int timeout 0) > ``` #### read {#read} ```python def read(*args, **kwargs) ``` Recv data from uart item description **type** func **param** **len**: max data length want to receive, default 1.<br> 1 means read data in uart receive buffer.<br>>0 means read len data want to receive.<br>other values is invalid.<br>**timeout**: unit ms, timeout to receive data, default 0.<br>0 means read data in uart receive buffer and return immediately,<br> 1 means block until read len data,<br>>0 means block until read len data or timeout.<br> **return** received data, bytes type.<br>Attention, you need to delete the returned object yourself in C++. **throw** Read failed will raise err.Exception error. **static** False > C++ defination code: > ```cpp > Bytes *read(int len 1, int timeout 0) > ``` #### readline {#readline} ```python def readline(*args, **kwargs) ``` Read line from uart, that is read until '\\n' or '\\r\\n'. item description **type** func **param** **timeout**: unit ms, timeout to receive data, default 1 means block until read '\\n' or '\\r\\n'.<br>> 0 means block until read '\\n' or '\\r\\n' or timeout.<br> **return** received data, bytes type. If timeout will return the current received data despite not read '\\n' or '\\r\\n'.<br>e.g. If we want to read b'123\\n', but when we only read b'12', timeout, then return b'12'. **static** False > C++ defination code: > ```cpp > Bytes *readline(int timeout 1) > ```"},"/maixpy/api/maix/peripheral/spi.html":{"title":"maix.peripheral.spi","content":" title: maix.peripheral.spi maix.peripheral.spi module > You can use `maix.peripheral.spi` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### Mode {#Mode} SPI mode enum item describe **values** **MASTER**: spi master mode<br>**SLAVE**: spi slave mode<br> > C++ defination code: > ```cpp > enum Mode > { > MASTER 0x0, // spi master mode > SLAVE 0x1, // spi slave mode > } > ``` ## Variable {#Variable} ## Function {#Function} ## Class {#Class} ### SPI {#SPI} Peripheral spi class > C++ defination code: > ```cpp > class SPI > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, id: int, mode: Mode, freq: int, polarity: int 0, phase: int 0, bits: int 8, hw_cs: int 1, soft_cs: str '', cs_active_low: bool True) > None ``` SPI constructor item description **type** func **param** **id**: direction [in], spi bus id, int type<br>**mode**: direction [in], mode of spi, spi.Mode type, spi.Mode.MASTER or spi.Mode.SLAVE.<br>**freq**: direction [in], freq of spi, int type. Different board support different max freq, for MaixCAM2 is 26000000(26M).<br>**polarity**: direction [in], polarity of spi, 0 means idle level of clock is low, 1 means high, int type, default is 0.<br>**phase**: direction [in], phase of spi, 0 means data is captured on the first edge of the SPI clock cycle, 1 means second, int type, default is 0.<br>**bits**: direction [in], bits of spi, int type, default is 8.<br>**hw_cs**: direction [in], use hardware CS id, 1 means use default(e.g. for MaixCAM2 SPI2 is CS1), 0 means use CS0, 1 means use CS1 ...<br>**soft_cs**: direction [in], use soft CS instead of hw_cs, default empty string means not use soft CS control, so you can use hw_cs or control CS pin by your self with GPIO module.<br>if set GPIO name, for example GPIOA19(MaixCAM) or GPIOA2(MaixCAM2), this class will automatically init GPIO object and control soft CS pin when read/write.<br>Attention, you should set GPIO's pinmap first by yourself first.<br>Attention, the driver may still own the hw_cs pin and perform control hw_cs, you can use pinmap to map hw_cs pin to other function to avoid this.<br>**cs_active_low**: direction [in], CS pin low voltage means activate slave device, default true. hw_cs only support true, soft_cs support both.<br> **static** False > C++ defination code: > ```cpp > SPI(int id, spi::Mode mode, int freq, int polarity 0, int phase 0, int bits 8, > int hw_cs 1, std::string soft_cs \"\", > bool cs_active_low true) > ``` #### read {#read} ```python def read(*args, **kwargs) ``` read data from spi item description **type** func **param** **length**: direction [in], read length, int type<br> **return** bytes data, Bytes type in C++, bytes type in MaixPy. You need to delete it manually after use in C++. **static** False > C++ defination code: > ```cpp > Bytes *read(int length) > ``` #### write {#write} ```python def write(self, data: maix.Bytes(bytes)) > int ``` write data to spi item description **type** func **param** **data**: direction [in], data to write, Bytes type in C++, bytes type in MaixPy<br> **return** write length, int type, if write failed, return err::Err code. **static** False > C++ defination code: > ```cpp > int write(Bytes *data) > ``` #### write\\_read {#write\\_read} ```python def write_read(*args, **kwargs) ``` write data to spi and read data from spi at the same time. item description **type** func **param** **data**: direction [in], data to write, Bytes type in C++, bytes type in MaixPy<br>**read_len**: direction [in], read length, int type, should > 0.<br> **return** read data, Bytes type in C++, bytes type in MaixPy. You need to delete it manually after use in C++. **static** False > C++ defination code: > ```cpp > Bytes *write_read(Bytes *data, int read_len) > ``` #### is\\_busy {#is\\_busy} ```python def is_busy(self) > bool ``` get busy status of spi item description **type** func **return** busy status, bool type **static** False > C++ defination code: > ```cpp > bool is_busy() > ```"},"/maixpy/api/maix/peripheral/adc.html":{"title":"maix.peripheral.adc","content":" title: maix.peripheral.adc maix.peripheral.adc module > You can use `maix.peripheral.adc` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ## Variable {#Variable} ### RES\\_BIT\\_8 {#RES\\_BIT\\_8} 8 bit resolution, supported by the actual hardware item description **value** **8** **readonly** True > C++ defination code: > ```cpp > const int RES_BIT_8 8 > ``` ### RES\\_BIT\\_10 {#RES\\_BIT\\_10} 10 bit resolution, supported by the actual hardware item description **value** **10** **readonly** True > C++ defination code: > ```cpp > const int RES_BIT_10 10 > ``` ### RES\\_BIT\\_12 {#RES\\_BIT\\_12} 12 bit resolution, supported by the actual hardware item description **value** **12** **readonly** True > C++ defination code: > ```cpp > const int RES_BIT_12 12 > ``` ### RES\\_BIT\\_16 {#RES\\_BIT\\_16} 16 bit resolution, supported by the actual hardware item description **value** **16** **readonly** True > C++ defination code: > ```cpp > const int RES_BIT_16 16 > ``` ## Function {#Function} ## Class {#Class} ### ADC {#ADC} Peripheral adc class > C++ defination code: > ```cpp > class ADC > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, id: int, resolution: int, vref: float 1) > None ``` ADC constructor item description **type** func **param** **id**: direction [in], adc id, int type, before use this ADC, you should use pinmap to ensure the coresponding pin is ADC function.<br>**resolution**: direction [in], adc resolution. default is 1, means use default resolution<br>option:<br>resolution adc.RES_BIT_8, means 8 bit resolution<br>resolution adc.RES_BIT_10, means 10 bit resolution<br>resolution adc.RES_BIT_12, means 12 bit resolution<br>resolution adc.RES_BIT_16, means 16 bit resolution<br>the default resolution is determined by actual hardware.<br>**vref**: direction [in], adc refer voltage. default is 1, means use default refer voltage.<br>the default vref is determined by actual hardware. range: [0.0, 10.0]<br> **static** False > C++ defination code: > ```cpp > ADC(int id, int resolution, float vref 1) > ``` #### read {#read} ```python def read(self) > int ``` read adc value item description **type** func **return** adc data, int type<br>if resolution is 8 bit, return value range is [0, 255]<br>if resolution is 10 bit, return value range is [0, 1023]<br>if resolution is 12 bit, return value range is [0, 4095]<br>if resolution is 16 bit, return value range is [0, 65535] **static** False > C++ defination code: > ```cpp > int read() > ``` #### read\\_vol {#read\\_vol} ```python def read_vol(self) > float ``` read adc voltage item description **type** func **return** adc voltage, float type。the range is [0.0, vref] **static** False > C++ defination code: > ```cpp > float read_vol() > ```"},"/maixpy/api/maix/peripheral/gpio.html":{"title":"maix.peripheral.gpio","content":" title: maix.peripheral.gpio maix.peripheral.gpio module > You can use `maix.peripheral.gpio` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### Mode {#Mode} GPIO mode item describe **values** **IN**: input mode<br>**OUT**: output mode<br>**OUT_OD**: output open drain mode<br>**MODE_MAX**: <br> > C++ defination code: > ```cpp > enum Mode > { > IN 0x01, // input mode > OUT 0x02, // output mode > OUT_OD 0x03, // output open drain mode > MODE_MAX > } > ``` ### Pull {#Pull} GPIO pull mode item describe **values** **PULL_NONE**: pull none mode<br>**PULL_UP**: pull up mode<br>**PULL_DOWN**: pull down mode<br>**PULL_MAX**: <br> > C++ defination code: > ```cpp > enum Pull > { > PULL_NONE 0x00, // pull none mode > PULL_UP 0x01, // pull up mode > PULL_DOWN 0x02, // pull down mode > PULL_MAX > } > ``` ## Variable {#Variable} ## Function {#Function} ## Class {#Class} ### GPIO {#GPIO} Peripheral gpio class > C++ defination code: > ```cpp > class GPIO > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, pin: str, mode: Mode ..., pull: Pull ...) > None ``` GPIO constructor item description **type** func **param** **pin**: direction [in], gpio pin name, string type the same as board's pin name, e.g. \"B14\" or \"GPIOB14\", or number string like \"10\" if board no gpiochipe name.<br>**mode**: direction [in], gpio mode. gpio.Mode type, default is gpio.Mode.IN (input) mode.<br>**pull**: direction [in], gpio pull. gpio.Pull type, default is gpio.Pull.PULL_NONE (pull none) mode.<br>For input mode, this will set gpio default status(value), if set to gpio.Pull.PULL_NONE, gpio value will be floating.<br>For output mode, this will set gpio default status(value), if set to gpio.Pull.PULL_UP, gpio value will be 1, else 0.<br> **throw** err::Exception if open gpio device failed. **static** False > C++ defination code: > ```cpp > GPIO(std::string pin, gpio::Mode mode gpio::Mode::IN, gpio::Pull pull gpio::Pull::PULL_NONE) > ``` #### value {#value} ```python def value(self, value: int 1) > int ``` set and get gpio value item description **type** func **param** **value**: direction [in], gpio value. int type.<br>0, means write gpio to low level<br>1, means write gpio to high level<br> 1, means read gpio value, not set<br> **return** int type, return gpio value, can be 0 or 1 **static** False > C++ defination code: > ```cpp > int value(int value 1) > ``` #### high {#high} ```python def high(self) > None ``` set gpio high (value to 1) item description **type** func **static** False > C++ defination code: > ```cpp > void high() > ``` #### low {#low} ```python def low(self) > None ``` set gpio low (value to 0) item description **type** func **static** False > C++ defination code: > ```cpp > void low() > ``` #### toggle {#toggle} ```python def toggle(self) > None ``` gpio toggle item description **type** func **static** False > C++ defination code: > ```cpp > void toggle() > ``` #### get\\_mode {#get\\_mode} ```python def get_mode(self) > Mode ``` gpio get mode item description **type** func **static** False > C++ defination code: > ```cpp > gpio::Mode get_mode() > ``` #### get\\_pull {#get\\_pull} ```python def get_pull(self) > Pull ``` get gpio pull item description **type** func **return** gpio::Pull type **static** False > C++ defination code: > ```cpp > gpio::Pull get_pull() > ``` #### reset {#reset} ```python def reset(self, mode: Mode, pull: Pull) > maix.err.Err ``` reset gpio item description **type** func **param** **mode**: direction [in], gpio mode. gpio.Mode type<br>**pull**: direction [in], gpio pull. gpio.Pull type<br>For input mode, this will set gpio default status(value), if set to gpio.Pull.PULL_NONE, gpio value will be floating.<br>For output mode, this will set gpio default status(value), if set to gpio.Pull.PULL_UP, gpio value will be 1, else 0.<br> **return** err::Err type **static** False > C++ defination code: > ```cpp > err::Err reset(gpio::Mode mode, gpio::Pull pull) > ```"},"/maixpy/api/maix/peripheral/wdt.html":{"title":"maix.peripheral.wdt","content":" title: maix.peripheral.wdt maix.peripheral.wdt module > You can use `maix.peripheral.wdt` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ## Variable {#Variable} ## Function {#Function} ## Class {#Class} ### WDT {#WDT} Peripheral wdt class > C++ defination code: > ```cpp > class WDT > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, id: int, feed_ms: int) > None ``` WDT constructor, after construct, the wdt will auto start. item description **type** func **param** **id**: direction [in], id of wdt, int type<br>**feed_ms**: direction [in], feed interval, int type, unit is ms, you must feed wdt in this interval, or system will restart.<br> **static** False > C++ defination code: > ```cpp > WDT(int id, int feed_ms) > ``` #### feed {#feed} ```python def feed(self) > int ``` feed wdt item description **type** func **return** error code, if feed success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > int feed() > ``` #### stop {#stop} ```python def stop(self) > int ``` stop wdt item description **type** func **static** False > C++ defination code: > ```cpp > int stop() > ``` #### restart {#restart} ```python def restart(self) > int ``` restart wdt, stop and start watchdog timer. item description **type** func **static** False > C++ defination code: > ```cpp > int restart() > ```"},"/maixpy/api/maix/util.html":{"title":"maix.util","content":" title: maix.util maix.util module > You can use `maix.util` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ## Variable {#Variable} ## Function {#Function} ### init\\_before\\_main {#init\\_before\\_main} ```python def init_before_main() > None ``` Initialize before main\\nThe function is used to add preparatory operations that need to be executed before the main program runs. > C++ defination code: > ```cpp > void init_before_main() > ``` ### do\\_exit\\_function {#do\\_exit\\_function} ```python def do_exit_function() > None ``` exec all of exit function > C++ defination code: > ```cpp > void do_exit_function() > ``` ### register\\_atexit {#register\\_atexit} ```python def register_atexit() > None ``` Registering default processes that need to be executed on exit > C++ defination code: > ```cpp > void register_atexit() > ``` ### str\\_strip {#str\\_strip} ```python def str_strip(s: str) > str ``` strip string, and return new striped string, will alloc new string. > C++ defination code: > ```cpp > std::string str_strip(std::string &s) > ``` ## Class {#Class}"},"/maixpy/api/maix/ext_dev/tof100.html":{"title":"maix.ext_dev.tof100","content":" title: maix.ext_dev.tof100 maix.ext_dev.tof100 module > You can use `maix.ext_dev.tof100` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### Resolution {#Resolution} Tof100 Resolution item describe **values** **RES_100x100**: <br>**RES_50x50**: <br>**RES_25x25**: <br> > C++ defination code: > ```cpp > enum class Resolution : uint32_t { > RES_100x100 100, > RES_50x50 50, > RES_25x25 25, > } > ``` ## Variable {#Variable} ## Function {#Function} ## Class {#Class} ### Tof100 {#Tof100} Tof100 TOF > C++ defination code: > ```cpp > class Tof100 final > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, spi_bus_num: int, resolution: Resolution ..., cmap: maix.ext_dev.cmap.Cmap ..., dis_min: int 1, dis_max: int 1) > None ``` Construct a new Tof100 object item description **type** func **param** **spi_bus_num**: SPI bus number.<br>**resolution**: @see Resolution<br>**cmap**: The color mapping to be used for generating the pseudo color image<br>**dis_min**: The minimum reference distance (in mm) for generating the pseudo color image. Default is 1.<br>**dis_max**: The maximum reference distance (in mm) for generating the pseudo color image. Default is 1.<br>If both max and min are equal, it operates in auto mode:<br>the maximum distance in the frame is taken as the maximum reference distance,<br>and the minimum distance in the frame is taken as the minimum reference distance.<br> **static** False > C++ defination code: > ```cpp > Tof100(int spi_bus_num, > ::maix::ext_dev::tof100::Resolution resolution ::maix::ext_dev::tof100::Resolution::RES_50x50, > ::maix::ext_dev::cmap::Cmap cmap ::maix::ext_dev::cmap::Cmap::JET, > int dis_min 1, int dis_max 1) > ``` #### matrix {#matrix} ```python def matrix(self) > list[list[int]] ``` Retrieves sensor data and returns a distance matrix. item description **type** func **return** Matrix containing the distance data, or an empty matrix ([]) if the operation fails. **static** False > C++ defination code: > ```cpp > TOFMatrix matrix() > ``` #### image {#image} ```python def image(self) > maix.image.Image ``` Obtains sensor data and converts it into a pseudo color image item description **type** func **return** ::maix::image::Image* A raw pointer to a maix image object.<br>It is the responsibility of the caller to free this memory<br>in C/C++ to prevent memory leaks. **static** False > C++ defination code: > ```cpp > ::maix::image::Image* image() > ``` #### max\\_dis\\_point {#max\\_dis\\_point} ```python def max_dis_point(self) > tuple[int, int, int] ``` Finds the pixel with the maximum distance from the most recent reading item description **type** func **return** Point A tuple of type <int, int, float>, representing<br>(x, y, distance) of the pixel with the maximum distance.<br>If the operation fails, the return values will be x, y < 0. **static** False > C++ defination code: > ```cpp > TOFPoint max_dis_point() > ``` #### min\\_dis\\_point {#min\\_dis\\_point} ```python def min_dis_point(self) > tuple[int, int, int] ``` Finds the pixel with the minimum distance from the most recent reading item description **type** func **return** Point A tuple of type <int, int, float>, representing<br>(x, y, distance) of the pixel with the minimum distance.<br>If the operation fails, the return values will be x, y < 0. **static** False > C++ defination code: > ```cpp > TOFPoint min_dis_point() > ``` #### center\\_point {#center\\_point} ```python def center_point(self) > tuple[int, int, int] ``` Finds the center pixel from the most recent reading item description **type** func **return** Point A tuple of type <int, int, float>, representing<br>(x, y, distance) of the center pixel in the distance matrix.<br>If the operation fails, the return values will be x, y < 0. **static** False > C++ defination code: > ```cpp > TOFPoint center_point() > ``` #### image\\_from {#image\\_from} ```python def image_from(self, matrix: list[list[int]]) > maix.image.Image ``` Converts a given matrix of distance data into an image item description **type** func **param** **matrix**: The distance matrix to be converted.<br> **return** ::maix::image::Image* A pointer to the generated image.<br>It is the responsibility of the caller to free this memory<br>in C/C++ to prevent memory leaks. **static** False > C++ defination code: > ```cpp > ::maix::image::Image* image_from(const TOFMatrix& matrix) > ``` #### max\\_dis\\_point\\_from {#max\\_dis\\_point\\_from} ```python def max_dis_point_from(matrix: list[list[int]]) > tuple[int, int, int] ``` Finds the pixel with the maximum distance from the given matrix item description **type** func **param** **matrix**: The distance matrix to be analyzed.<br> **return** Point A tuple of type <int, int, float>, representing<br>(x, y, distance) of the pixel with the maximum distance.<br>If the operation fails, the return values will be x, y < 0. **static** True > C++ defination code: > ```cpp > static TOFPoint max_dis_point_from(const TOFMatrix& matrix) > ``` #### min\\_dis\\_point\\_from {#min\\_dis\\_point\\_from} ```python def min_dis_point_from(matrix: list[list[int]]) > tuple[int, int, int] ``` Finds the pixel with the minimum distance from the given matrix item description **type** func **param** **matrix**: The distance matrix to be analyzed.<br> **return** Point A tuple of type <int, int, float>, representing<br>(x, y, distance) of the pixel with the minimum distance.<br>If the operation fails, the return values will be x, y < 0. **static** True > C++ defination code: > ```cpp > static TOFPoint min_dis_point_from(const TOFMatrix& matrix) > ``` #### center\\_point\\_from {#center\\_point\\_from} ```python def center_point_from(matrix: list[list[int]]) > tuple[int, int, int] ``` Finds the center pixel from the given matrix item description **type** func **param** **matrix**: The distance matrix to be analyzed.<br> **return** Point A tuple of type <int, int, float>, representing<br>(x, y, distance) of the center pixel in the matrix.<br>If the operation fails, the return values will be x, y < 0. **static** True > C++ defination code: > ```cpp > static TOFPoint center_point_from(const TOFMatrix& matrix) > ```"},"/maixpy/api/maix/ext_dev/tmc2209.html":{"title":"maix.ext_dev.tmc2209","content":" title: maix.ext_dev.tmc2209 maix.ext_dev.tmc2209 module > You can use `maix.ext_dev.tmc2209` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ## Variable {#Variable} ## Function {#Function} ### slide\\_scan {#slide\\_scan} ```python def slide_scan(port: str, addr: int, baud: int, step_angle: float, micro_step: int, round_mm: float, speed_mm_s: float, dir: bool True, use_internal_sense_resistors: bool True, run_current_per: int 100, hold_current_per: int 100, conf_save_path: str './slide_conf.bin', force_update: bool True) > None ``` Scan and initialize the slide with the given parameters item description **param** **port**: UART port, string type.<br>**addr**: TMC2209 UART address, range 0x00~0x03, integer type.<br>**baud**: UART baud rate, integer type.<br>**step_angle**: Motor step angle, float type.<br>**micro_step**: Motor micro step, options: 1/2/4/8/16/32/64/128/256, integer type.<br>**round_mm**: Round distance in mm, float type.<br>**speed_mm_s**: Speed of the slide in mm/s, float type.<br>**dir**: Direction of movement, boolean type. Default is true.<br>**use_internal_sense_resistors**: Enable internal sense resistors if true, disable if false, boolean type. Default is true.<br>**run_current_per**: Motor run current percentage, range 0~100(%), integer type. Default is 100%.<br>**hold_current_per**: Motor hold current percentage, range 0~100(%), integer type. Default is 100%.<br>**conf_save_path**: Configuration save path, string type. Default is \"./slide_conf.bin\".<br>**force_update**: Force update the configuration if true, boolean type. Default is true.<br> > C++ defination code: > ```cpp > void slide_scan(const char* port, uint8_t addr, long baud, /* Uart init param */ > float step_angle, uint16_t micro_step, float round_mm, /* Motor init param */ > float speed_mm_s, bool dir true, bool use_internal_sense_resistors true, uint8_t run_current_per 100, > uint8_t hold_current_per 100, const std::string conf_save_path \"./slide_conf.bin\", > bool force_update true /* Driver init param */) > ``` ### slide\\_test {#slide\\_test} ```python def slide_test(port: str, addr: int, baud: int, step_angle: float, micro_step: int, round_mm: float, speed_mm_s: float, dir: bool True, use_internal_sense_resistors: bool True, run_current_per: int 100, hold_current_per: int 100, conf_save_path: str './slide_conf.bin') > None ``` Test the slide with the given parameters\\nThis function tests the slide by moving it in the specified direction until a stall condition is detected, as defined in the configuration file. item description **param** **port**: UART port, string type.<br>**addr**: TMC2209 UART address, range 0x00~0x03, integer type.<br>**baud**: UART baud rate, integer type.<br>**step_angle**: Motor step angle, float type.<br>**micro_step**: Motor micro step, options: 1/2/4/8/16/32/64/128/256, integer type.<br>**round_mm**: Round distance in mm, float type.<br>**speed_mm_s**: Speed of the slide in mm/s, float type.<br>**dir**: Direction of movement, boolean type. Default is true.<br>**use_internal_sense_resistors**: Enable internal sense resistors if true, disable if false, boolean type. Default is true.<br>**run_current_per**: Motor run current percentage, range 0~100(%), integer type. Default is 100%.<br>**hold_current_per**: Motor hold current percentage, range 0~100(%), integer type. Default is 100%.<br>**conf_save_path**: Configuration save path, string type. Default is \"./slide_conf.bin\".<br> > C++ defination code: > ```cpp > void slide_test(const char* port, uint8_t addr, long baud, /* Uart init param */ > float step_angle, uint16_t micro_step, float round_mm, /* Motor init param */ > float speed_mm_s, bool dir true, bool use_internal_sense_resistors true, uint8_t run_current_per 100, > uint8_t hold_current_per 100, const std::string conf_save_path \"./slide_conf.bin\"/* Driver init param */) > ``` ## Class {#Class} ### Slide {#Slide} Slide Class > C++ defination code: > ```cpp > class Slide > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, port: str, addr: int, baud: int, step_angle: float, micro_step: int, round_mm: float, speed_mm_s: float 1, use_internal_sense_resistors: bool True, run_current_per: int 100, hold_current_per: int 100, cfg_file_path: str '') > None ``` Constructor for Slide\\nInitializes the Slide object with the specified parameters. item description **type** func **param** **port**: UART port, string type.<br>**addr**: TMC2209 UART address, range 0x00~0x03, integer type.<br>**baud**: UART baud rate, integer type.<br>**step_angle**: Motor step angle, float type.<br>**micro_step**: Motor micro step, options: 1/2/4/8/16/32/64/128/256, integer type.<br>**round_mm**: Round distance in mm, float type.<br>**speed_mm_s**: Speed of the slide in mm/s, float type. Default is 1, indicating the use of a default speed factor.<br>**use_internal_sense_resistors**: Enable internal sense resistors if TRUE, disable if FALSE, boolean type. Default is TRUE.<br>**run_current_per**: Motor run current percentage, range 0~100(%), integer type. Default is 100%.<br>**hold_current_per**: Motor hold current percentage, range 0~100(%), integer type. Default is 100%.<br>**cfg_file_path**: Configuration file path, string type. Default is an empty string, indicating no configuration file.<br> **static** False > C++ defination code: > ```cpp > Slide(const char* port, uint8_t addr, long baud, /* Uart init param */ > float step_angle, uint16_t micro_step, float round_mm, /* Motor init param */ > float speed_mm_s 1, bool use_internal_sense_resistors true, uint8_t run_current_per 100, > uint8_t hold_current_per 100, std::string cfg_file_path \"\" /* Driver init param */) > ``` #### load\\_conf {#load\\_conf} ```python def load_conf(self, path: str) > None ``` Load configuration from a file\\nLoads the configuration settings for the slide from the specified file path. item description **type** func **param** **path**: Path to the configuration file, string type.<br> **static** False > C++ defination code: > ```cpp > void load_conf(std::string path) > ``` #### move {#move} ```python def move(self, oft: float, speed_mm_s: int 1, check: bool True) > None ``` Move the slide by a specified length\\nMoves the slide by the specified length at the given speed. Optionally checks for stall conditions. item description **type** func **param** **oft**: Length to move, float type.<br>**speed_mm_s**: Speed in mm/s. Default is 1, indicating the use of the default speed set during initialization.<br>**check**: Enable movement check if true, boolean type. Default is true.<br> **static** False > C++ defination code: > ```cpp > void move(float oft, int speed_mm_s 1, bool check true) > ``` #### reset {#reset} ```python def reset(self, dir: bool False, speed_mm_s: int 1) > None ``` Reset the slide position\\nResets the slide position in the specified direction at the given speed. item description **type** func **param** **dir**: Direction of reset, boolean type. Default is false.<br>**speed_mm_s**: Speed in mm/s. Default is 1, indicating the use of the speed set during initialization.<br> **static** False > C++ defination code: > ```cpp > void reset(bool dir false, int speed_mm_s 1) > ``` #### stop\\_default\\_per {#stop\\_default\\_per} Get or set the stop default percentage\\nRetrieves or sets the stop default percentage. If the parameter is 1, it returns the current setting. item description **type** func **param** **per**: Stop default percentage, range 0~100(%), integer type. Default is 1, indicating no change.<br> **return** int Current stop default percentage if per is 1, otherwise the new set percentage. **static** False > C++ defination code: > ```cpp > int stop_default_per(int per 1) > ``` #### run\\_current\\_per {#run\\_current\\_per} ```python def run_current_per(self, per: int 1) > int ``` Get or set the run current percentage\\nRetrieves or sets the run current percentage. If the parameter is 1, it returns the current setting. item description **type** func **param** **per**: Run current percentage, range 0~100(%), integer type. Default is 1, indicating no change.<br> **return** int Current run current percentage if per is 1, otherwise the new set percentage. **static** False > C++ defination code: > ```cpp > int run_current_per(int per 1) > ``` #### hold\\_current\\_per {#hold\\_current\\_per} ```python def hold_current_per(self, per: int 1) > int ``` Get or set the hold current percentage\\nRetrieves or sets the hold current percentage. If the parameter is 1, it returns the current setting. item description **type** func **param** **per**: Hold current percentage, range 0~100(%), integer type. Default is 1, indicating no change.<br> **return** int Current hold current percentage if per is 1, otherwise the new set percentage. **static** False > C++ defination code: > ```cpp > int hold_current_per(int per 1) > ``` #### use\\_internal\\_sense\\_resistors {#use\\_internal\\_sense\\_resistors} ```python def use_internal_sense_resistors(self, b: bool True) > None ``` Enable or disable internal sense resistors\\nEnables or disables the internal sense resistors based on the provided boolean value. item description **type** func **param** **b**: Boolean value to enable (true) or disable (false) internal sense resistors. Default is true.<br> **static** False > C++ defination code: > ```cpp > void use_internal_sense_resistors(bool b true) > ``` ### ScrewSlide {#ScrewSlide} ScrewSlide Class > C++ defination code: > ```cpp > class ScrewSlide > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 2} ```python def __init__(self, port: str, addr: int, baud: int, step_angle: float, micro_step: int, screw_pitch: float, speed_mm_s: float 1, use_internal_sense_resistors: bool True, run_current_per: int 100, hold_current_per: int 100) > None ``` Constructor for ScrewSlide item description **type** func **param** **port**: UART port, string type.<br>**addr**: TMC2209 UART address, range 0x00~0x03, integer type.<br>**baud**: UART baud rate, integer type.<br>**step_angle**: Motor step angle, float type.<br>**micro_step**: Motor micro step, options: 1/2/4/8/16/32/64/128/256, integer type.<br>**screw_pitch**: Screw pitch of the slide, integer type.<br>**speed_mm_s**: Speed of the slide in mm/s, 10 means 10mm/s, float type.<br>Default is 1, indicating the use of a default speed factor.<br>**use_internal_sense_resistors**: Enable internal sense resistors if TRUE,<br>disable if FALSE, boolean type. Default is TRUE.<br>**run_current_per**: Motor run current percentage, range 0~100(%), integer type. Default is 100%.<br>**hold_current_per**: Motor hold current percentage, range 0~100(%), integer type. Default is 100%.<br> **static** False > C++ defination code: > ```cpp > ScrewSlide(const char* port, uint8_t addr, long baud, /* Uart init param */ > float step_angle, uint16_t micro_step, float screw_pitch, /* Motor init param */ > float speed_mm_s 1, bool use_internal_sense_resistors true, uint8_t run_current_per 100, > uint8_t hold_current_per 100) > ``` #### move {#move 2} ```python def move(self, oft: float, speed_mm_s: int 1, callback: typing.Callable[[float], bool] None) > None ``` Move the slide by a specified length item description **type** func **param** **oft**: Length to move, 10 means 10mm, float type.<br>Positive values move the slide in the positive direction, negative values move it in the opposite direction.<br>**speed_mm_s**: Speed in mm/s. Default is 1, indicating the use of the default speed set during initialization.<br>**callback**: Callback function to be called during movement.<br>The callback function receives the current progress percentage (0~100%) of the movement.<br>If the callback returns true, the move operation will be terminated immediately. Default is nullptr.<br> **static** False > C++ defination code: > ```cpp > void move(float oft, int speed_mm_s 1, std::function<bool(float)> callback nullptr) > ``` #### reset {#reset 2} ```python def reset(self, callback: typing.Callable[[], bool], dir: bool False, speed_mm_s: int 1) > None ``` Reset the slide position item description **type** func **param** **callback**: Callback function to be called during the reset loop.<br>The reset operation will only terminate if the callback returns true.<br>**dir**: Direction of reset. Default is false.<br>**speed_mm_s**: Speed in mm/s. Default is 1, indicating the use of the speed set during initialization.<br> **static** False > C++ defination code: > ```cpp > void reset(std::function<bool(void)> callback, bool dir false, int speed_mm_s 1) > ``` #### run\\_current\\_per {#run\\_current\\_per 2} ```python def run_current_per(self, per: int 1) > int ``` Get or set the run current percentage item description **type** func **param** **per**: Run current percentage, range 0~100(%).<br>Default is 1, indicating no change and returning the current run current percentage.<br> **return** int Current run current percentage if per is 1, otherwise the new set percentage. **static** False > C++ defination code: > ```cpp > int run_current_per(int per 1) > ``` #### hold\\_current\\_per {#hold\\_current\\_per 2} ```python def hold_current_per(self, per: int 1) > int ``` Get or set the hold current percentage item description **type** func **param** **per**: Hold current percentage, range 0~100(%). Default is 1, indicating no change and returning the current hold current percentage.<br> **return** int Current hold current percentage if per is 1, otherwise the new set percentage. **static** False > C++ defination code: > ```cpp > int hold_current_per(int per 1) > ``` #### use\\_internal\\_sense\\_resistors {#use\\_internal\\_sense\\_resistors 2} ```python def use_internal_sense_resistors(self, b: bool True) > None ``` Enable or disable internal sense resistors item description **type** func **param** **b**: Boolean value to enable (true) or disable (false) internal sense resistors. Default is true.<br> **static** False > C++ defination code: > ```cpp > void use_internal_sense_resistors(bool b true) > ```"},"/maixpy/api/maix/ext_dev/axp2101.html":{"title":"maix.ext_dev.axp2101","content":" title: maix.ext_dev.axp2101 maix.ext_dev.axp2101 module > You can use `maix.ext_dev.axp2101` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### ChargerStatus {#ChargerStatus} charger status item describe **values** **CHG_TRI_STATE**: tri_charge<br>**CHG_PRE_STATE**: pre_charge<br>**CHG_CC_STATE**: constant charge<br>**CHG_CV_STATE**: constant voltage<br>**CHG_DONE_STATE**: charge done<br>**CHG_STOP_STATE**: not charge<br> > C++ defination code: > ```cpp > enum class ChargerStatus { > CHG_TRI_STATE, //tri_charge > CHG_PRE_STATE, //pre_charge > CHG_CC_STATE, //constant charge > CHG_CV_STATE, //constant voltage > CHG_DONE_STATE, //charge done > CHG_STOP_STATE, //not charge > } > ``` ### ChargerCurrent {#ChargerCurrent} charger current item describe **values** **CHG_CUR_0MA**: <br>**CHG_CUR_100MA**: <br>**CHG_CUR_125MA**: <br>**CHG_CUR_150MA**: <br>**CHG_CUR_175MA**: <br>**CHG_CUR_200MA**: <br>**CHG_CUR_300MA**: <br>**CHG_CUR_400MA**: <br>**CHG_CUR_500MA**: <br>**CHG_CUR_600MA**: <br>**CHG_CUR_700MA**: <br>**CHG_CUR_800MA**: <br>**CHG_CUR_900MA**: <br>**CHG_CUR_1000MA**: <br> > C++ defination code: > ```cpp > enum class ChargerCurrent { > CHG_CUR_0MA, > CHG_CUR_100MA 4, > CHG_CUR_125MA, > CHG_CUR_150MA, > CHG_CUR_175MA, > CHG_CUR_200MA, > CHG_CUR_300MA, > CHG_CUR_400MA, > CHG_CUR_500MA, > CHG_CUR_600MA, > CHG_CUR_700MA, > CHG_CUR_800MA, > CHG_CUR_900MA, > CHG_CUR_1000MA, > } > ``` ### PowerChannel {#PowerChannel} power channel item describe **values** **DCDC1**: <br>**DCDC2**: <br>**DCDC3**: <br>**DCDC4**: <br>**DCDC5**: <br>**ALDO1**: <br>**ALDO2**: <br>**ALDO3**: <br>**ALDO4**: <br>**BLDO1**: <br>**BLDO2**: <br>**DLDO1**: <br>**DLDO2**: <br>**VBACKUP**: <br>**CPULDO**: <br> > C++ defination code: > ```cpp > enum class PowerChannel { > DCDC1, > DCDC2, > DCDC3, > DCDC4, > DCDC5, > ALDO1, > ALDO2, > ALDO3, > ALDO4, > BLDO1, > BLDO2, > DLDO1, > DLDO2, > VBACKUP, > CPULDO, > } > ``` ### PowerOffTime {#PowerOffTime} power off time item describe **values** **POWEROFF_4S**: <br>**POWEROFF_6S**: <br>**POWEROFF_8S**: <br>**POWEROFF_10S**: <br>**POWEROFF_DISABLE**: <br> > C++ defination code: > ```cpp > enum class PowerOffTime { > POWEROFF_4S, > POWEROFF_6S, > POWEROFF_8S, > POWEROFF_10S, > POWEROFF_DISABLE 65535, > } > ``` ### PowerOnTime {#PowerOnTime} power on time item describe **values** **POWERON_128MS**: <br>**POWERON_512MS**: <br>**POWERON_1S**: <br>**POWERON_2S**: <br> > C++ defination code: > ```cpp > enum class PowerOnTime { > POWERON_128MS, > POWERON_512MS, > POWERON_1S, > POWERON_2S, > } > ``` ## Variable {#Variable} ## Function {#Function} ## Class {#Class} ### AXP2101 {#AXP2101} Peripheral AXP2101 class > C++ defination code: > ```cpp > class AXP2101 > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, i2c_bus: int 1, addr: int 52) > None ``` AXP2101 constructor. item description **type** func **param** **i2c_bus**: i2c bus number.<br>**addr**: pmu device addr.<br> **static** False > C++ defination code: > ```cpp > AXP2101(int i2c_bus 1, uint8_t addr 0x34) > ``` #### init {#init} ```python def init(self) > maix.err.Err ``` Initialise the AXP2101. item description **type** func **return** err::Err type, if init success, return err::ERR_NONE. **static** False > C++ defination code: > ```cpp > err::Err init() > ``` #### poweroff {#poweroff} ```python def poweroff(self) > maix.err.Err ``` Poweroff immediately. item description **type** func **return** err::Err type, if init success, return err::ERR_NONE. **static** False > C++ defination code: > ```cpp > err::Err poweroff() > ``` #### is\\_bat\\_connect {#is\\_bat\\_connect} ```python def is_bat_connect(self) > bool ``` Is the battery connected. item description **type** func **return** bool type, if battery is connected, return true. **static** False > C++ defination code: > ```cpp > bool is_bat_connect() > ``` #### is\\_vbus\\_in {#is\\_vbus\\_in} ```python def is_vbus_in(self) > bool ``` Is the power adapter connected. item description **type** func **return** bool type, if power adapter is connected, return true. **static** False > C++ defination code: > ```cpp > bool is_vbus_in() > ``` #### is\\_charging {#is\\_charging} ```python def is_charging(self) > bool ``` Is bat charging. item description **type** func **return** bool type, if bat is charging, return true. **static** False > C++ defination code: > ```cpp > bool is_charging() > ``` #### get\\_bat\\_percent {#get\\_bat\\_percent} ```python def get_bat_percent(self) > int ``` Get the battery percentage. item description **type** func **return** int type, return battery percentage. **static** False > C++ defination code: > ```cpp > int get_bat_percent() > ``` #### get\\_charger\\_status {#get\\_charger\\_status} ```python def get_charger_status(self) > ChargerStatus ``` Get the battery charging status. item description **type** func **return** int type, return battery charging status. **static** False > C++ defination code: > ```cpp > ext_dev::axp2101::ChargerStatus get_charger_status() > ``` #### get\\_bat\\_vol {#get\\_bat\\_vol} ```python def get_bat_vol(self) > int ``` Get the battery voltage. item description **type** func **return** uint16_t type, return battery voltage. **static** False > C++ defination code: > ```cpp > uint16_t get_bat_vol() > ``` #### clean\\_irq {#clean\\_irq} ```python def clean_irq(self) > maix.err.Err ``` Clear interrupt flag. item description **type** func **return** err::Err type, if clean success, return err::ERR_NONE. **static** False > C++ defination code: > ```cpp > err::Err clean_irq() > ``` #### set\\_bat\\_charging\\_cur {#set\\_bat\\_charging\\_cur} ```python def set_bat_charging_cur(self, current: ChargerCurrent) > maix.err.Err ``` Set the battery charging current. item description **type** func **param** **current**: The current to be set.<br>The available values are 0mA, 100mA, 125mA, 150mA, 175mA,<br>200mA, 300mA, 400mA, 500mA, 600mA, 700mA, 800mA, 900mA, and 1000mA.<br> **return** err::Err type, if set success, return err::ERR_NONE. **static** False > C++ defination code: > ```cpp > err::Err set_bat_charging_cur(ext_dev::axp2101::ChargerCurrent current) > ``` #### get\\_bat\\_charging\\_cur {#get\\_bat\\_charging\\_cur} ```python def get_bat_charging_cur(self) > ChargerCurrent ``` Get the battery charging current. item description **type** func **return** ChargerCurrent, return the currently set charging current. **static** False > C++ defination code: > ```cpp > ext_dev::axp2101::ChargerCurrent get_bat_charging_cur() > ``` #### dcdc1 {#dcdc1} ```python def dcdc1(self, voltage: int 1) > int ``` Set and get the PMU DCDC1 voltage. item description **type** func **param** **voltage**: The voltage to be set,<br>voltage range is 1500mV~3400mV(step 20mV).<br> **return** int, return the PMU DCDC1 voltage. **static** False > C++ defination code: > ```cpp > int dcdc1(int voltage 1) > ``` #### dcdc2 {#dcdc2} ```python def dcdc2(self, voltage: int 1) > int ``` Set and get the PMU DCDC2 voltage. item description **type** func **param** **voltage**: The voltage to be set,<br>voltage range is 500mV~1200mV(step 10mV) and 1220mV~1540mV(step 20mV).<br> **return** int, return the PMU DCDC2 voltage. **static** False > C++ defination code: > ```cpp > int dcdc2(int voltage 1) > ``` #### dcdc3 {#dcdc3} ```python def dcdc3(self, voltage: int 1) > int ``` Set and get the PMU DCDC3 voltage. item description **type** func **param** **voltage**: The voltage to be set,<br>voltage range is 500mV~1200mV(step 10mV) and 1220mV~1540mV(step 20mV).<br> **return** int, return the PMU DCDC3 voltage. **static** False > C++ defination code: > ```cpp > int dcdc3(int voltage 1) > ``` #### dcdc4 {#dcdc4} ```python def dcdc4(self, voltage: int 1) > int ``` Set and get the PMU DCDC4 voltage. item description **type** func **param** **voltage**: The voltage to be set,<br>voltage range is 500mV~1200mV(step 10mV) and 1220mV~1840mV(step 20mV).<br> **return** int, return the PMU DCDC4 voltage. **static** False > C++ defination code: > ```cpp > int dcdc4(int voltage 1) > ``` #### dcdc5 {#dcdc5} ```python def dcdc5(self, voltage: int 1) > int ``` Set and get the PMU DCDC5 voltage. item description **type** func **param** **voltage**: The voltage to be set,<br>voltage range is 1400mV~3700mV(step 100mV).<br> **return** int, return the PMU DCDC5 voltage. **static** False > C++ defination code: > ```cpp > int dcdc5(int voltage 1) > ``` #### aldo1 {#aldo1} ```python def aldo1(self, voltage: int 1) > int ``` Set and get the PMU ALDO1 voltage. item description **type** func **param** **voltage**: The voltage to be set,<br>voltage range is 500mV~3500mV(step 100mV).<br> **return** int, return the PMU ALDO1 voltage. **static** False > C++ defination code: > ```cpp > int aldo1(int voltage 1) > ``` #### aldo2 {#aldo2} ```python def aldo2(self, voltage: int 1) > int ``` Set and get the PMU ALDO2 voltage. item description **type** func **param** **voltage**: The voltage to be set,<br>voltage range is 500mV~3500mV(step 100mV).<br> **return** int, return the PMU ALDO2 voltage. **static** False > C++ defination code: > ```cpp > int aldo2(int voltage 1) > ``` #### aldo3 {#aldo3} ```python def aldo3(self, voltage: int 1) > int ``` Set and get the PMU ALDO3 voltage. item description **type** func **param** **voltage**: The voltage to be set,<br>voltage range is 500mV~3500mV(step 100mV).<br> **return** int, return the PMU ALDO3 voltage. **static** False > C++ defination code: > ```cpp > int aldo3(int voltage 1) > ``` #### aldo4 {#aldo4} ```python def aldo4(self, voltage: int 1) > int ``` Set and get the PMU ALDO4 voltage. item description **type** func **param** **voltage**: The voltage to be set,<br>voltage range is 500mV~3500mV(step 100mV).<br> **return** int, return the PMU ALDO4 voltage. **static** False > C++ defination code: > ```cpp > int aldo4(int voltage 1) > ``` #### bldo1 {#bldo1} ```python def bldo1(self, voltage: int 1) > int ``` Set and get the PMU BLDO1 voltage. item description **type** func **param** **voltage**: The voltage to be set,<br>voltage range is 500mV~3500mV(step 100mV).<br> **return** int, return the PMU BLDO1 voltage. **static** False > C++ defination code: > ```cpp > int bldo1(int voltage 1) > ``` #### bldo2 {#bldo2} ```python def bldo2(self, voltage: int 1) > int ``` Set and get the PMU BLDO2 voltage. item description **type** func **param** **voltage**: The voltage to be set,<br>voltage range is 500mV~3500mV(step 100mV).<br> **return** int, return the PMU BLDO2 voltage. **static** False > C++ defination code: > ```cpp > int bldo2(int voltage 1) > ``` #### set\\_poweroff\\_time {#set\\_poweroff\\_time} ```python def set_poweroff_time(self, tm: PowerOffTime) > maix.err.Err ``` Set power off time, The device will shut down\\nif the power button is held down longer than this time. item description **type** func **param** **tm**: The time to be set, you can set it to 4s, 6s, 8s, or 10s.<br> **return** err::Err type, if set success, return err::ERR_NONE. **static** False > C++ defination code: > ```cpp > err::Err set_poweroff_time(ext_dev::axp2101::PowerOffTime tm) > ``` #### get\\_poweroff\\_time {#get\\_poweroff\\_time} ```python def get_poweroff_time(self) > PowerOffTime ``` Get power off time. item description **type** func **return** PowerOffTime, return power off time. **static** False > C++ defination code: > ```cpp > ext_dev::axp2101::PowerOffTime get_poweroff_time() > ``` #### set\\_poweron\\_time {#set\\_poweron\\_time} ```python def set_poweron_time(self, tm: PowerOnTime) > maix.err.Err ``` Set power on time, The device will power on\\nif the power button is held down longer than this time. item description **type** func **param** **tm**: The time to be set, you can set it to 128ms, 512ms, 1s, or 2s.<br> **return** err::Err type, if set success, return err::ERR_NONE. **static** False > C++ defination code: > ```cpp > err::Err set_poweron_time(ext_dev::axp2101::PowerOnTime tm) > ``` #### get\\_poweron\\_time {#get\\_poweron\\_time} ```python def get_poweron_time(self) > PowerOnTime ``` Get power on time. item description **type** func **return** PowerOnTime, return power on time. **static** False > C++ defination code: > ```cpp > ext_dev::axp2101::PowerOnTime get_poweron_time() > ```"},"/maixpy/api/maix/ext_dev/fp5510.html":{"title":"maix.ext_dev.fp5510","content":" title: maix.ext_dev.fp5510 maix.ext_dev.fp5510 module > You can use `maix.ext_dev.fp5510` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ## Variable {#Variable} ## Function {#Function} ## Class {#Class} ### FP5510 {#FP5510} FP5510 class > C++ defination code: > ```cpp > class FP5510 > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, id: int 4, slave_addr: int 12, freq: int 400000) > None ``` Construct a new FP5510 object item description **type** func **param** **id**: iic number, default is 4<br>**slave_addr**: slave address of fp5510, default is 0x0c.<br>**freq**: iic frequency, default is 400k<br> **static** False > C++ defination code: > ```cpp > FP5510(int id 4, int slave_addr 0x0c, int freq 400000) > ``` #### set\\_pos {#set\\_pos} ```python def set_pos(self, pos: int) > None ``` Set fp5510 position item description **type** func **param** **pos**: the position of fp5510, range is [0, 1023]<br> **static** False > C++ defination code: > ```cpp > void set_pos(uint32_t pos) > ``` #### get\\_pos {#get\\_pos} ```python def get_pos(self) > int ``` Get fp5510 position item description **type** func **return** returns the position of fp5510, range is [0, 1023] **static** False > C++ defination code: > ```cpp > uint32_t get_pos() > ```"},"/maixpy/api/maix/ext_dev/pmu.html":{"title":"maix.ext_dev.pmu","content":" title: maix.ext_dev.pmu maix.ext_dev.pmu module > You can use `maix.ext_dev.pmu` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### ChargerStatus {#ChargerStatus} charger status item describe **values** **CHG_TRI_STATE**: tri_charge<br>**CHG_PRE_STATE**: pre_charge<br>**CHG_CC_STATE**: constant charge<br>**CHG_CV_STATE**: constant voltage<br>**CHG_DONE_STATE**: charge done<br>**CHG_STOP_STATE**: not charge<br> > C++ defination code: > ```cpp > enum class ChargerStatus { > CHG_TRI_STATE, //tri_charge > CHG_PRE_STATE, //pre_charge > CHG_CC_STATE, //constant charge > CHG_CV_STATE, //constant voltage > CHG_DONE_STATE, //charge done > CHG_STOP_STATE, //not charge > } > ``` ### PowerChannel {#PowerChannel} power channel item describe **values** **DCDC1**: <br>**DCDC2**: <br>**DCDC3**: <br>**DCDC4**: <br>**DCDC5**: <br>**ALDO1**: <br>**ALDO2**: <br>**ALDO3**: <br>**ALDO4**: <br>**BLDO1**: <br>**BLDO2**: <br>**DLDO1**: <br>**DLDO2**: <br>**VBACKUP**: <br>**CPULDO**: <br> > C++ defination code: > ```cpp > enum class PowerChannel { > DCDC1, > DCDC2, > DCDC3, > DCDC4, > DCDC5, > ALDO1, > ALDO2, > ALDO3, > ALDO4, > BLDO1, > BLDO2, > DLDO1, > DLDO2, > VBACKUP, > CPULDO, > } > ``` ## Variable {#Variable} ## Function {#Function} ## Class {#Class} ### PMU {#PMU} PMU driver class > C++ defination code: > ```cpp > class PMU > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, driver: str '', i2c_bus: int 1, addr: int 52) > None ``` Construct a new PMU object, will open PMU. item description **type** func **param** **driver**: driver name, support \"axp2101\" \"maixcam2\", default empty means use default.<br>**i2c_bus**: i2c bus number. Automatically selects the on board pmu when 1 is passed in.<br>**addr**: PMU i2c addr.<br> **static** False > C++ defination code: > ```cpp > PMU(std::string driver \"\", int i2c_bus 1, int addr 0x34) > ``` #### poweroff {#poweroff} ```python def poweroff(self) > maix.err.Err ``` Poweroff immediately. item description **type** func **return** err::Err type, if init success, return err::ERR_NONE. **static** False > C++ defination code: > ```cpp > err::Err poweroff() > ``` #### is\\_bat\\_connect {#is\\_bat\\_connect} ```python def is_bat_connect(self) > bool ``` Is the battery connected. item description **type** func **return** bool type, if battery is connected, return true. **static** False > C++ defination code: > ```cpp > bool is_bat_connect() > ``` #### is\\_vbus\\_in {#is\\_vbus\\_in} ```python def is_vbus_in(self) > bool ``` Is the power adapter connected. item description **type** func **return** bool type, if power adapter is connected, return true. **static** False > C++ defination code: > ```cpp > bool is_vbus_in() > ``` #### is\\_charging {#is\\_charging} ```python def is_charging(self) > bool ``` Is bat charging. item description **type** func **return** bool type, if bat is charging, return true. **static** False > C++ defination code: > ```cpp > bool is_charging() > ``` #### get\\_bat\\_percent {#get\\_bat\\_percent} ```python def get_bat_percent(self) > int ``` Get the battery percentage. item description **type** func **return** int type, return battery percentage. **static** False > C++ defination code: > ```cpp > int get_bat_percent() > ``` #### get\\_charger\\_status {#get\\_charger\\_status} ```python def get_charger_status(self) > ChargerStatus ``` Get the battery charging status. item description **type** func **return** int type, return battery charging status. **static** False > C++ defination code: > ```cpp > ext_dev::pmu::ChargerStatus get_charger_status() > ``` #### get\\_bat\\_vol {#get\\_bat\\_vol} ```python def get_bat_vol(self) > int ``` Get the battery voltage. item description **type** func **return** uint16_t type, return battery voltage. **static** False > C++ defination code: > ```cpp > uint16_t get_bat_vol() > ``` #### clean\\_irq {#clean\\_irq} ```python def clean_irq(self) > maix.err.Err ``` Clear interrupt flag. item description **type** func **return** err::Err type, if clean success, return err::ERR_NONE. **static** False > C++ defination code: > ```cpp > err::Err clean_irq() > ``` #### set\\_bat\\_charging\\_cur {#set\\_bat\\_charging\\_cur} ```python def set_bat_charging_cur(self, current: int) > maix.err.Err ``` Set the battery charging current. item description **type** func **param** **current**: The current to be set.<br> **return** err::Err type, if set success, return err::ERR_NONE. **static** False > C++ defination code: > ```cpp > err::Err set_bat_charging_cur(int current) > ``` #### get\\_bat\\_charging\\_cur {#get\\_bat\\_charging\\_cur} ```python def get_bat_charging_cur(self) > int ``` Get the battery charging current. item description **type** func **return** int, return the currently set charging current. **static** False > C++ defination code: > ```cpp > int get_bat_charging_cur() > ``` #### set\\_vol {#set\\_vol} ```python def set_vol(self, channel: PowerChannel, voltage: int) > maix.err.Err ``` Set the PMU channel voltage.\\nYou can retrieve the available channel from ext_dev.pmu.PowerChannel. item description **type** func **param** **voltage**: The voltage to be set.<br> **return** int, return the channel voltage. **static** False > C++ defination code: > ```cpp > err::Err set_vol(ext_dev::pmu::PowerChannel channel, int voltage) > ``` #### get\\_vol {#get\\_vol} ```python def get_vol(self, channel: PowerChannel) > int ``` Get the PMU channel voltage.\\nYou can retrieve the available channel from ext_dev.pmu.PowerChannel. item description **type** func **return** err::Err type, if set success, return err::ERR_NONE. **static** False > C++ defination code: > ```cpp > int get_vol(ext_dev::pmu::PowerChannel channel) > ```"},"/maixpy/api/maix/ext_dev/imu.html":{"title":"maix.ext_dev.imu","content":" title: maix.ext_dev.imu maix.ext_dev.imu module > You can use `maix.ext_dev.imu` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### Mode {#Mode} imu mode item describe **values** **ACC_ONLY**: <br>**GYRO_ONLY**: <br>**DUAL**: <br> > C++ defination code: > ```cpp > enum class Mode { > ACC_ONLY 0, > GYRO_ONLY, > DUAL > } > ``` ### AccScale {#AccScale} imu acc scale item describe **values** **ACC_SCALE_2G**: <br>**ACC_SCALE_4G**: <br>**ACC_SCALE_8G**: <br>**ACC_SCALE_16G**: <br> > C++ defination code: > ```cpp > enum class AccScale { > ACC_SCALE_2G 0, > ACC_SCALE_4G, > ACC_SCALE_8G, > ACC_SCALE_16G > } > ``` ### AccOdr {#AccOdr} imu acc output data rate item describe **values** **ACC_ODR_8000**: Accelerometer ODR set to 8000 Hz.<br>**ACC_ODR_4000**: Accelerometer ODR set to 4000 Hz.<br>**ACC_ODR_2000**: Accelerometer ODR set to 2000 Hz.<br>**ACC_ODR_1000**: Accelerometer ODR set to 1000 Hz.<br>**ACC_ODR_833**: Accelerometer ODR set to 833 Hz.<br>**ACC_ODR_500**: Accelerometer ODR set to 500 Hz.<br>**ACC_ODR_416**: Accelerometer ODR set to 416 Hz.<br>**ACC_ODR_250**: Accelerometer ODR set to 250 Hz.<br>**ACC_ODR_208**: Accelerometer ODR set to 208 Hz.<br>**ACC_ODR_128**: Accelerometer ODR set to 128 Hz.<br>**ACC_ODR_125**: Accelerometer ODR set to 125 Hz.<br>**ACC_ODR_104**: Accelerometer ODR set to 104 Hz.<br>**ACC_ODR_62_5**: Accelerometer ODR set to 62.5 Hz.<br>**ACC_ODR_52**: Accelerometer ODR set to 52 Hz.<br>**ACC_ODR_31_25**: Accelerometer ODR set to 31.25 Hz.<br>**ACC_ODR_26**: Accelerometer ODR set to 26 Hz.<br>**ACC_ODR_21**: Accelerometer ODR set to 21 Hz.<br>**ACC_ODR_12_5**: Accelerometer ODR set to 12.5 Hz.<br>**ACC_ODR_11**: Accelerometer ODR set to 11 Hz.<br>**ACC_ODR_3**: Accelerometer ODR set to 3 Hz.<br> > C++ defination code: > ```cpp > enum class AccOdr { > ACC_ODR_8000, // Accelerometer ODR set to 8000 Hz. > ACC_ODR_4000, // Accelerometer ODR set to 4000 Hz. > ACC_ODR_2000, // Accelerometer ODR set to 2000 Hz. > ACC_ODR_1000, // Accelerometer ODR set to 1000 Hz. > ACC_ODR_833, // Accelerometer ODR set to 833 Hz. > ACC_ODR_500, // Accelerometer ODR set to 500 Hz. > ACC_ODR_416, // Accelerometer ODR set to 416 Hz. > ACC_ODR_250, // Accelerometer ODR set to 250 Hz. > ACC_ODR_208, // Accelerometer ODR set to 208 Hz. > ACC_ODR_128, // Accelerometer ODR set to 128 Hz. > ACC_ODR_125, // Accelerometer ODR set to 125 Hz. > ACC_ODR_104, // Accelerometer ODR set to 104 Hz. > ACC_ODR_62_5, // Accelerometer ODR set to 62.5 Hz. > ACC_ODR_52, // Accelerometer ODR set to 52 Hz. > ACC_ODR_31_25, // Accelerometer ODR set to 31.25 Hz. > ACC_ODR_26, // Accelerometer ODR set to 26 Hz. > ACC_ODR_21, // Accelerometer ODR set to 21 Hz. > ACC_ODR_12_5, // Accelerometer ODR set to 12.5 Hz. > ACC_ODR_11, // Accelerometer ODR set to 11 Hz. > ACC_ODR_3, // Accelerometer ODR set to 3 Hz. > } > ``` ### GyroScale {#GyroScale} imu gyro scale item describe **values** **GYRO_SCALE_16DPS**: Gyroscope scale set to ±16 degrees per second.<br>**GYRO_SCALE_32DPS**: Gyroscope scale set to ±32 degrees per second.<br>**GYRO_SCALE_64DPS**: Gyroscope scale set to ±64 degrees per second.<br>**GYRO_SCALE_125DPS**: Gyroscope scale set to ±125 degrees per second.<br>**GYRO_SCALE_128DPS**: Gyroscope scale set to ±128 degrees per second.<br>**GYRO_SCALE_250DPS**: Gyroscope scale set to ±250 degrees per second.<br>**GYRO_SCALE_256DPS**: Gyroscope scale set to ±256 degrees per second.<br>**GYRO_SCALE_500DPS**: Gyroscope scale set to ±500 degrees per second.<br>**GYRO_SCALE_512DPS**: Gyroscope scale set to ±512 degrees per second.<br>**GYRO_SCALE_1000DPS**: Gyroscope scale set to ±1000 degrees per second.<br>**GYRO_SCALE_1024DPS**: Gyroscope scale set to ±1024 degrees per second.<br>**GYRO_SCALE_2000DPS**: Gyroscope scale set to ±2000 degrees per second.<br>**GYRO_SCALE_2048DPS**: Gyroscope scale set to ±2048 degrees per second.<br> > C++ defination code: > ```cpp > enum class GyroScale { > GYRO_SCALE_16DPS 0, // Gyroscope scale set to ±16 degrees per second. > GYRO_SCALE_32DPS, // Gyroscope scale set to ±32 degrees per second. > GYRO_SCALE_64DPS, // Gyroscope scale set to ±64 degrees per second. > GYRO_SCALE_125DPS, // Gyroscope scale set to ±125 degrees per second. > GYRO_SCALE_128DPS, // Gyroscope scale set to ±128 degrees per second. > GYRO_SCALE_250DPS, // Gyroscope scale set to ±250 degrees per second. > GYRO_SCALE_256DPS, // Gyroscope scale set to ±256 degrees per second. > GYRO_SCALE_500DPS, // Gyroscope scale set to ±500 degrees per second. > GYRO_SCALE_512DPS, // Gyroscope scale set to ±512 degrees per second. > GYRO_SCALE_1000DPS, // Gyroscope scale set to ±1000 degrees per second. > GYRO_SCALE_1024DPS, // Gyroscope scale set to ±1024 degrees per second. > GYRO_SCALE_2000DPS, // Gyroscope scale set to ±2000 degrees per second. > GYRO_SCALE_2048DPS, // Gyroscope scale set to ±2048 degrees per second. > } > ``` ### GyroOdr {#GyroOdr} imu gyro output data rate item describe **values** **GYRO_ODR_8000**: Gyroscope ODR set to 8000 Hz.<br>**GYRO_ODR_4000**: Gyroscope ODR set to 4000 Hz.<br>**GYRO_ODR_2000**: Gyroscope ODR set to 2000 Hz.<br>**GYRO_ODR_1000**: Gyroscope ODR set to 1000 Hz.<br>**GYRO_ODR_833**: Gyroscope ODR set to 833 Hz.<br>**GYRO_ODR_500**: Gyroscope ODR set to 500 Hz.<br>**GYRO_ODR_416**: Gyroscope ODR set to 416 Hz.<br>**GYRO_ODR_250**: Gyroscope ODR set to 250 Hz.<br>**GYRO_ODR_125**: Gyroscope ODR set to 125 Hz.<br>**GYRO_ODR_208**: Gyroscope ODR set to 208 Hz.<br>**GYRO_ODR_104**: Gyroscope ODR set to 104 Hz.<br>**GYRO_ODR_62_5**: Gyroscope ODR set to 62.5 Hz.<br>**GYRO_ODR_52**: Gyroscope ODR set to 52 Hz.<br>**GYRO_ODR_26**: Gyroscope ODR set to 26 Hz.<br>**GYRO_ODR_31_25**: Gyroscope ODR set to 31.25 Hz.<br>**GYRO_ODR_12_5**: Gyroscope ODR set to 12.5 Hz.<br> > C++ defination code: > ```cpp > enum class GyroOdr { > GYRO_ODR_8000, // Gyroscope ODR set to 8000 Hz. > GYRO_ODR_4000, // Gyroscope ODR set to 4000 Hz. > GYRO_ODR_2000, // Gyroscope ODR set to 2000 Hz. > GYRO_ODR_1000, // Gyroscope ODR set to 1000 Hz. > GYRO_ODR_833, // Gyroscope ODR set to 833 Hz. > GYRO_ODR_500, // Gyroscope ODR set to 500 Hz. > GYRO_ODR_416, // Gyroscope ODR set to 416 Hz. > GYRO_ODR_250, // Gyroscope ODR set to 250 Hz. > GYRO_ODR_125, // Gyroscope ODR set to 125 Hz. > GYRO_ODR_208, // Gyroscope ODR set to 208 Hz. > GYRO_ODR_104, // Gyroscope ODR set to 104 Hz. > GYRO_ODR_62_5, // Gyroscope ODR set to 62.5 Hz. > GYRO_ODR_52, // Gyroscope ODR set to 52 Hz. > GYRO_ODR_26, // Gyroscope ODR set to 26 Hz. > GYRO_ODR_31_25, // Gyroscope ODR set to 31.25 Hz. > GYRO_ODR_12_5, // Gyroscope ODR set to 12.5 Hz. > } > ``` ## Variable {#Variable} ## Function {#Function} ### get\\_imu\\_info {#get\\_imu\\_info} ```python def get_imu_info() > list[IMUInfo] ``` Get all IMU info on board(not include external IMU). item description **return** std::vector<imu::IMUInfo> type, all IMU info. > C++ defination code: > ```cpp > std::vector<ext_dev::imu::IMUInfo> get_imu_info() > ``` ## Class {#Class} ### IMUData {#IMUData} IMU data type. > C++ defination code: > ```cpp > class IMUData > ``` #### acc {#acc} accelerometer data item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > maix::tensor::Vector3f acc > ``` #### gyro {#gyro} gyroscope data item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > maix::tensor::Vector3f gyro > ``` #### mag {#mag} magnetometer data item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > maix::tensor::Vector3f mag > ``` #### temp {#temp} temperature data item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float temp > ``` ### IMUInfo {#IMUInfo} IMU info > C++ defination code: > ```cpp > class IMUInfo > ``` #### name {#name} IMU name item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string name > ``` #### driver {#driver} IMU driver name item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string driver > ``` #### i2c\\_bus {#i2c\\_bus} IMU i2c bus number item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int i2c_bus > ``` #### addr {#addr} IMU i2c address item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int addr > ``` #### have\\_mag {#have\\_mag} IMU have magnetometer or not item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > bool have_mag > ``` ### IMU {#IMU} QMI8656 driver class > C++ defination code: > ```cpp > class IMU > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, driver: str, i2c_bus: int 1, addr: int 107, freq: int 400000, mode: Mode ..., acc_scale: AccScale ..., acc_odr: AccOdr ..., gyro_scale: GyroScale ..., gyro_odr: GyroOdr ..., block: bool True) > None ``` Construct a new IMU object, will open IMU item description **type** func **param** **driver**: driver name, \"default\" means use onboard IMU according to board id, other values: [\"qmi8656\"]<br>**i2c_bus**: i2c bus number. Automatically selects the on board imu when 1 is passed in.<br>**addr**: IMU i2c addr.<br>**freq**: IMU freq<br>**mode**: IMU Mode: ACC_ONLY/GYRO_ONLY/DUAL<br>**acc_scale**: acc scale, see @imu::AccScale<br>**acc_odr**: acc output data rate, see @imu::AccOdr<br>**gyro_scale**: gyro scale, see @imu::GyroScale<br>**gyro_odr**: gyro output data rate, see @imu::GyroOdr<br>**block**: block or non block, defalut is true<br> **throw** if arg error or not find valid IMU, will throw err::Exception **static** False > C++ defination code: > ```cpp > IMU(std::string driver, int i2c_bus 1, int addr 0x6B, int freq 400000, > maix::ext_dev::imu::Mode mode maix::ext_dev::imu::Mode::DUAL, > maix::ext_dev::imu::AccScale acc_scale maix::ext_dev::imu::AccScale::ACC_SCALE_2G, > maix::ext_dev::imu::AccOdr acc_odr maix::ext_dev::imu::AccOdr::ACC_ODR_1000, > maix::ext_dev::imu::GyroScale gyro_scale maix::ext_dev::imu::GyroScale::GYRO_SCALE_256DPS, > maix::ext_dev::imu::GyroOdr gyro_odr maix::ext_dev::imu::GyroOdr::GYRO_ODR_8000, > bool block true) > ``` #### read {#read} ```python def read(self) > list[float] ``` Read raw data from IMU, no calibration, recommend use read_all instead. item description **type** func **return** list type. If only one of the outputs is initialized, only [x,y,z] of that output will be returned.<br>If all outputs are initialized, [acc_x, acc_y, acc_z, gyro_x, gyro_y, gyro_z] is returned.<br>And the last one is temperature<br>Unit acc: g/s<br>Unit gyro: degree/s<br>Unit temperate: degree **static** False > C++ defination code: > ```cpp > std::vector<float> read() > ``` #### read\\_all {#read\\_all} ```python def read_all(self, calib_gryo: bool True, radian: bool False) > IMUData ``` read imu data from IMU. item description **type** func **param** **calib_gryo**: calibrate gyro data based on calib_gyro_data, you should load_calib_gyro first to load calib_gyro_data.<br>**radian**: gyro unit use rad/s instead of degree/s, default false(use degree/s).<br> **return** maix.ext_dev.imu.IMUData type.<br>Unit acc: g/s<br>Unit gyro: degree/s<br>Unit temperate: degree **static** False > C++ defination code: > ```cpp > ext_dev::imu::IMUData read_all(bool calib_gryo true, bool radian false) > ``` #### calib\\_gyro {#calib\\_gyro} ```python def calib_gyro(self, time_ms: int, interval_ms: int 1, save_id: str 'default') > maix.tensor.Vector3f ``` Calibrate gryo for time_ms long, get gryo bias. item description **type** func **param** **time_ms**: total time to collect data, unit is ms.<br>**interval_ms**: minimum read raw data interval, 1 means continues, 10ms mean > 10ms.<br>**save_id**: Save calibration data to file or not, you can load by load_calib_gyro.<br>Empty string means not save. By default value is \"default\", means save calibration as id \"default\".<br> **static** False > C++ defination code: > ```cpp > tensor::Vector3f calib_gyro(uint64_t time_ms, int interval_ms 1, const std::string &save_id \"default\") > ``` #### calib\\_gyro\\_exists {#calib\\_gyro\\_exists} ```python def calib_gyro_exists(self, save_id: str 'default') > bool ``` Load Gyro calibration from file, if not found all value will be 0. item description **type** func **param** **save_id**: saved id from valib_gyro, default is \"default\".<br> **return** If exist gyro calibration info return True else False. **static** False > C++ defination code: > ```cpp > bool calib_gyro_exists(const std::string &save_id \"default\") > ``` #### load\\_calib\\_gyro {#load\\_calib\\_gyro} ```python def load_calib_gyro(self, save_id: str 'default') > maix.tensor.Vector3f ``` Load Gyro calibration from file, if not found all value will be 0. item description **type** func **param** **save_id**: saved id from valib_gyro, default is \"default\".<br> **static** False > C++ defination code: > ```cpp > tensor::Vector3f load_calib_gyro(const std::string &save_id \"default\") > ``` #### save\\_calib\\_gyro {#save\\_calib\\_gyro} ```python def save_calib_gyro(self, calib: maix.tensor.Vector3f, save_id: str 'default') > maix.err.Err ``` Save Gyro calibration to file. item description **type** func **param** **calib**: the calibration data you want to save.<br>**save_id**: saved id from valib_gyro, default is \"default\".<br> **static** False > C++ defination code: > ```cpp > err::Err save_calib_gyro(const tensor::Vector3f &calib, const std::string &save_id \"default\") > ``` #### calculate\\_calibration {#calculate\\_calibration} ```python def calculate_calibration(self, time_ms: int 30000) > maix.err.Err ``` !!!Depracated!!!\\nCaculate calibration, save calibration data to /maixapp/share/misc/imu_calibration item description **type** func **param** **time_ms**: caculate max time, unit:ms<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err calculate_calibration(uint64_t time_ms 30 * 1000) > ``` #### get\\_calibration {#get\\_calibration} ```python def get_calibration(self) > list[float] ``` !!!Depracated!!!\\nGet calibration data item description **type** func **return** return an array, format is [acc_x_bias, acc_y_bias, acc_z_bias, gyro_x_bias, gyro_y_bias, gyro_z_bias]<br>If the calibration file cannot be found, an empty array will be returned. **static** False > C++ defination code: > ```cpp > std::vector<double> get_calibration() > ``` ### Gcsv {#Gcsv} Gcsv class > C++ defination code: > ```cpp > class Gcsv > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 2} ```python def __init__(self) > None ``` Construct a new IMU object item description **type** func **static** False > C++ defination code: > ```cpp > Gcsv() > ``` #### open {#open} ```python def open(self, path: str, tscale: float 0.001, gscale: float 1, ascale: float 1, mscale: float 1, version: str '1.3', id: str 'imu', orientation: str 'YxZ') > maix.err.Err ``` Open a file item description **type** func **param** **path**: the path where data will be saved<br>**tscale**: time scale, default is 0.001<br>**gscale**: gyroscope scale factor, default is 1, unit:g<br>**ascale**: accelerometer scale factor, default is 1, unit:radians/second<br>**mscale**: magnetometer scale factor, default is 1(unused)<br>**version**: version number, default is \"1.3\"<br>**id**: identifier for the IMU, default is \"imu\"<br>**orientation**: sensor orientation, default is \"YxZ\"<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err open(std::string path, double tscale 0.001, double gscale 1, double ascale 1, double mscale 1, std::string version \"1.3\", std::string id \"imu\", std::string orientation \"YxZ\") > ``` #### close {#close} ```python def close(self) > maix.err.Err ``` Close file item description **type** func **return** error code **static** False > C++ defination code: > ```cpp > err::Err close() > ``` #### is\\_opened {#is\\_opened} ```python def is_opened(self) > bool ``` Check if the object is already open item description **type** func **return** true, opened; false, not opened **static** False > C++ defination code: > ```cpp > bool is_opened() > ``` #### write {#write} ```python def write(self, timestamp: float, gyro: list[float], acc: list[float], mag: list[float] []) > maix.err.Err ``` Write imu data to gcsv file item description **type** func **param** **t**: Timestamp of the current data. The actual value is equal to t * tscale. unit:s<br>**gyro**: Gyroscope data must be an array consisting of x, y, and z axis data. The actual value is equal to gyro * gscale. unit:g<br>**acc**: Acceleration data must be an array consisting of x, y, and z axis data. The actual value is equal to acc * ascale.unit:radians/second<br>**mag**: Magnetic data must be an array consisting of x, y, and z axis data. Currently not supported.<br> **static** False > C++ defination code: > ```cpp > err::Err write(double timestamp, std::vector<double> gyro, std::vector<double> acc, std::vector<double> mag std::vector<double>()) > ```"},"/maixpy/api/maix/ext_dev/mlx90640.html":{"title":"maix.ext_dev.mlx90640","content":" title: maix.ext_dev.mlx90640 maix.ext_dev.mlx90640 module > You can use `maix.ext_dev.mlx90640` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### FPS {#FPS} MLX90640 FPS item describe **values** **FPS_1**: <br>**FPS_2**: <br>**FPS_4**: <br>**FPS_8**: <br>**FPS_16**: <br>**FPS_32**: <br>**FPS_64**: <br> > C++ defination code: > ```cpp > enum class FPS : uint8_t { > FPS_1 0b001, > FPS_2 0b010, > FPS_4 0b011, > FPS_8 0b100, > FPS_16 0b101, > FPS_32 0b110, > FPS_64 0b111, > } > ``` ## Variable {#Variable} ### MLX\\_W {#MLX\\_W} MLX90640 Image Width. item description **value** **32** **readonly** True > C++ defination code: > ```cpp > constexpr uint32_t MLX_W 32 > ``` ### MLX\\_H {#MLX\\_H} MLX90640 Image Height. item description **value** **24** **readonly** True > C++ defination code: > ```cpp > constexpr uint32_t MLX_H 24 > ``` ## Function {#Function} ### to\\_kmatrix {#to\\_kmatrix} ```python def to_kmatrix(matrix: list[list[float]]) > list[list[int]] ``` CMatrix to KMatrix. item description **param** **matrix**: CMatrix type.<br> **return** KMatrix > C++ defination code: > ```cpp > KMatrix to_kmatrix(const CMatrix& matrix) > ``` ### to\\_cmatrix {#to\\_cmatrix} ```python def to_cmatrix(matrix: list[list[int]]) > list[list[float]] ``` KMatrix to CMatrix item description **param** **matrix**: KMatrix type.<br> **return** CMatrix > C++ defination code: > ```cpp > CMatrix to_cmatrix(const KMatrix& matrix) > ``` ## Class {#Class} ### MLX90640Celsius {#MLX90640Celsius} MLX90640 (℃) > C++ defination code: > ```cpp > class MLX90640Celsius final > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, i2c_bus_num: int, fps: FPS ..., cmap: maix.ext_dev.cmap.Cmap ..., temp_min: float 1, temp_max: float 1, emissivity: float 0.95) > None ``` Construct a new MLX90640Celsius object\\nThis constructor initializes an MLX90640Celsius object with the specified parameters\\nto configure the I2C bus communication, frame rate, color mapping, temperature ranges,\\nand emissivity for the MLX90640 thermal camera. item description **type** func **param** **i2c_bus_num**: The I2C bus number to which the MLX90640 is connected.<br>**fps**: The preferred frame rate for the MLX90640, default is FPS::FPS_32.<br>**cmap**: The color mapping to be used for generating the pseudo color image, default is Cmap::WHITE_HOT.<br>**temp_min**: The minimum reference temperature (in °C) for generating the pseudo color image. Default is 1.<br>**temp_max**: The maximum reference temperature (in °C) for generating the pseudo color image. Default is 1.<br>If both max and min are equal, it operates in auto mode:<br>the maximum temperature in the frame is taken as the maximum reference temperature,<br>and the minimum temperature in the frame is taken as the minimum reference temperature.<br>**emissivity**: The emissivity parameter for the MLX90640, default is 0.95.<br> **static** False > C++ defination code: > ```cpp > MLX90640Celsius(int i2c_bus_num, > ::maix::ext_dev::mlx90640::FPS fps ::maix::ext_dev::mlx90640::FPS::FPS_32, > ::maix::ext_dev::cmap::Cmap cmap ::maix::ext_dev::cmap::Cmap::WHITE_HOT, > float temp_min 1, float temp_max 1, float emissivity 0.95) > ``` #### matrix {#matrix} ```python def matrix(self) > list[list[float]] ``` Retrieves sensor data and returns a temperature matrix of size MLX_H * MLX_W\\nMLX_W: 32\\n \\n\\nMLX_H \\n: 24 \\nThe matrix structure is represented as list[MLX_H][MLX_W],\\nwhere MLX_H is the number of rows (24) and MLX_W is the number of columns (32). item description **type** func **return** CMatrix containing the temperature data, or an empty matrix ([]) if the operation fails. **static** False > C++ defination code: > ```cpp > CMatrix matrix() > ``` #### image {#image} ```python def image(self) > maix.image.Image ``` Obtains sensor data and converts it into a pseudo color image\\nThis function retrieves the thermal data from the sensor and processes it\\nto generate a pseudo color representation of the temperature distribution. item description **type** func **return** maix::image::Image* A raw pointer to a maix image object.<br>It is the responsibility of the caller to free this memory<br>in C/C++ to prevent memory leaks. **static** False > C++ defination code: > ```cpp > ::maix::image::Image* image() > ``` #### min\\_temp\\_point {#min\\_temp\\_point} ```python def min_temp_point(self) > tuple[int, int, float] ``` Finds the pixel with the minimum temperature from the most recent reading\\nThis function identifies the pixel with the minimum temperature\\nfrom the latest data obtained from the sensor. item description **type** func **return** Point A tuple of type <int, int, float>, representing<br>(x, y, temperature) of the pixel with the minimum temperature.<br>If the operation fails, the return values will be x, y < 0. **static** False > C++ defination code: > ```cpp > Point min_temp_point() > ``` #### max\\_temp\\_point {#max\\_temp\\_point} ```python def max_temp_point(self) > tuple[int, int, float] ``` Finds the pixel with the maximum temperature from the most recent reading\\nThis function identifies the pixel with the maximum temperature\\nfrom the latest data obtained from the sensor. item description **type** func **return** Point A tuple of type <int, int, float>, representing<br>(x, y, temperature) of the pixel with the maximum temperature.<br>If the operation fails, the return values will be x, y < 0. **static** False > C++ defination code: > ```cpp > Point max_temp_point() > ``` #### center\\_point {#center\\_point} ```python def center_point(self) > tuple[int, int, float] ``` Finds the center pixel from the most recent reading\\nThis function determines the center pixel of the temperature matrix\\nbased on the most recent data obtained from the sensor. item description **type** func **return** Point A tuple of type <int, int, float>, representing<br>(x, y, temperature) of the center pixel in the temperature matrix.<br>If the operation fails, the return values will be x, y < 0. **static** False > C++ defination code: > ```cpp > Point center_point() > ``` #### image\\_from {#image\\_from} ```python def image_from(self, matrix: list[list[float]]) > maix.image.Image ``` Converts a given matrix of temperature data into an image\\nThis function takes a temperature matrix and generates\\na corresponding image representation based on the\\nconfigured color map and other parameters. item description **type** func **param** **matrix**: The temperature matrix to be converted.<br> **return** maix::image::Image* A pointer to the generated image.<br>It is the responsibility of the caller to free this memory<br>in C/C++ to prevent memory leaks. **static** False > C++ defination code: > ```cpp > ::maix::image::Image* image_from(const CMatrix& matrix) > ``` #### max\\_temp\\_point\\_from {#max\\_temp\\_point\\_from} ```python def max_temp_point_from(matrix: list[list[float]]) > tuple[int, int, float] ``` Finds the pixel with the maximum temperature from the given matrix\\nThis static function identifies the pixel with the maximum temperature\\nfrom the specified temperature matrix. item description **type** func **param** **matrix**: The temperature matrix to be analyzed.<br> **return** Point A tuple of type <int, int, float>, representing<br>(x, y, temperature) of the pixel with the maximum temperature.<br>If the operation fails, the return values will be x, y < 0. **static** True > C++ defination code: > ```cpp > static Point max_temp_point_from(const CMatrix& matrix) > ``` #### min\\_temp\\_point\\_from {#min\\_temp\\_point\\_from} ```python def min_temp_point_from(matrix: list[list[float]]) > tuple[int, int, float] ``` Finds the pixel with the minimum temperature from the given matrix\\nThis static function identifies the pixel with the minimum temperature\\nfrom the specified temperature matrix. item description **type** func **param** **matrix**: The temperature matrix to be analyzed.<br> **return** Point A tuple of type <int, int, float>, representing<br>(x, y, temperature) of the pixel with the minimum temperature.<br>If the operation fails, the return values will be x, y < 0. **static** True > C++ defination code: > ```cpp > static Point min_temp_point_from(const CMatrix& matrix) > ``` #### center\\_point\\_from {#center\\_point\\_from} ```python def center_point_from(matrix: list[list[float]]) > tuple[int, int, float] ``` Finds the center pixel from the given matrix\\nThis static function determines the center pixel of the\\nspecified temperature matrix based on its dimensions. item description **type** func **param** **matrix**: The temperature matrix to be analyzed.<br> **return** Point A tuple of type <int, int, float>, representing<br>(x, y, temperature) of the center pixel in the matrix.<br>If the operation fails, the return values will be x, y < 0. **static** True > C++ defination code: > ```cpp > static Point center_point_from(const CMatrix& matrix) > ``` ### MLX90640Kelvin {#MLX90640Kelvin} MLX90640 (K)) > C++ defination code: > ```cpp > class MLX90640Kelvin final > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 2} ```python def __init__(self, i2c_bus_num: int, fps: FPS ..., cmap: maix.ext_dev.cmap.Cmap ..., temp_min: float 1, temp_max: float 1, emissivity: float 0.95) > None ``` Construct a new MLX90640Kelvin object\\nThis constructor initializes an MLX90640Kelvin object with the specified parameters\\nto configure the I2C bus communication, frame rate, color mapping, temperature ranges,\\nand emissivity for the MLX90640 thermal camera. item description **type** func **param** **i2c_bus_num**: The I2C bus number to which the MLX90640 is connected.<br>**fps**: The preferred frame rate for the MLX90640, default is FPS::FPS_32.<br>**cmap**: The color mapping to be used for generating the pseudo color image, default is Cmap::WHITE_HOT.<br>**temp_min**: The minimum reference temperature (in K) for generating the pseudo color image. Default is 1.<br>**temp_max**: The maximum reference temperature (in K) for generating the pseudo color image. Default is 1.<br>If both max and min are equal, it operates in auto mode:<br>the maximum temperature in the frame is taken as the maximum reference temperature,<br>and the minimum temperature in the frame is taken as the minimum reference temperature.<br>**emissivity**: The emissivity parameter for the MLX90640, default is 0.95.<br> **static** False > C++ defination code: > ```cpp > MLX90640Kelvin( int i2c_bus_num, > ::maix::ext_dev::mlx90640::FPS fps ::maix::ext_dev::mlx90640::FPS::FPS_32, > ::maix::ext_dev::cmap::Cmap cmap ::maix::ext_dev::cmap::Cmap::WHITE_HOT, > float temp_min 1, float temp_max 1, float emissivity 0.95) > ``` #### matrix {#matrix 2} ```python def matrix(self) > list[list[int]] ``` Retrieves sensor data and returns a temperature matrix of size MLX_H * MLX_W\\nMLX_W: 32\\n \\n\\nMLX_H \\n: 24 \\nThe matrix structure is represented as list[MLX_H][MLX_W],\\nwhere MLX_H is the number of rows (24) and MLX_W is the number of columns (32). item description **type** func **return** KMatrix containing the temperature data, or an empty matrix ([]) if the operation fails. **static** False > C++ defination code: > ```cpp > KMatrix matrix() > ``` #### image {#image 2} ```python def image(self) > maix.image.Image ``` Obtains sensor data and converts it into a pseudo color image\\nThis function retrieves the thermal data from the sensor and processes it\\nto generate a pseudo color representation of the temperature distribution. item description **type** func **return** maix::image::Image* A raw pointer to a maix image object.<br>It is the responsibility of the caller to free this memory<br>in C/C++ to prevent memory leaks. **static** False > C++ defination code: > ```cpp > ::maix::image::Image* image() > ``` #### max\\_temp\\_point {#max\\_temp\\_point 2} ```python def max_temp_point(self) > tuple[int, int, float] ``` Finds the pixel with the minimum temperature from the most recent reading\\nThis function identifies the pixel with the minimum temperature\\nfrom the latest data obtained from the sensor. item description **type** func **return** Point A tuple of type <int, int, float>, representing<br>(x, y, temperature) of the pixel with the minimum temperature.<br>If the operation fails, the return values will be x, y < 0. **static** False > C++ defination code: > ```cpp > Point max_temp_point() > ``` #### min\\_temp\\_point {#min\\_temp\\_point 2} ```python def min_temp_point(self) > tuple[int, int, float] ``` Finds the pixel with the maximum temperature from the most recent reading\\nThis function identifies the pixel with the maximum temperature\\nfrom the latest data obtained from the sensor. item description **type** func **return** Point A tuple of type <int, int, float>, representing<br>(x, y, temperature) of the pixel with the maximum temperature.<br>If the operation fails, the return values will be x, y < 0. **static** False > C++ defination code: > ```cpp > Point min_temp_point() > ``` #### center\\_point {#center\\_point 2} ```python def center_point(self) > tuple[int, int, float] ``` Finds the center pixel from the most recent reading\\nThis function determines the center pixel of the temperature matrix\\nbased on the most recent data obtained from the sensor. item description **type** func **return** Point A tuple of type <int, int, float>, representing<br>(x, y, temperature) of the center pixel in the temperature matrix.<br>If the operation fails, the return values will be x, y < 0. **static** False > C++ defination code: > ```cpp > Point center_point() > ``` #### image\\_from {#image\\_from 2} ```python def image_from(self, matrix: list[list[int]]) > maix.image.Image ``` Converts a given matrix of temperature data into an image\\nThis function takes a temperature matrix and generates\\na corresponding image representation based on the\\nconfigured color map and other parameters. item description **type** func **param** **matrix**: The temperature matrix to be converted.<br> **return** maix::image::Image* A pointer to the generated image.<br>It is the responsibility of the caller to free this memory<br>in C/C++ to prevent memory leaks. **static** False > C++ defination code: > ```cpp > ::maix::image::Image* image_from(const KMatrix& matrix) > ``` #### max\\_temp\\_point\\_from {#max\\_temp\\_point\\_from 2} ```python def max_temp_point_from(matrix: list[list[int]]) > tuple[int, int, float] ``` Finds the pixel with the maximum temperature from the given matrix\\nThis static function identifies the pixel with the maximum temperature\\nfrom the specified temperature matrix. item description **type** func **param** **matrix**: The temperature matrix to be analyzed.<br> **return** Point A tuple of type <int, int, float>, representing<br>(x, y, temperature) of the pixel with the maximum temperature.<br>If the operation fails, the return values will be x, y < 0. **static** True > C++ defination code: > ```cpp > static Point max_temp_point_from(const KMatrix& matrix) > ``` #### min\\_temp\\_point\\_from {#min\\_temp\\_point\\_from 2} ```python def min_temp_point_from(matrix: list[list[int]]) > tuple[int, int, float] ``` Finds the pixel with the minimum temperature from the given matrix\\nThis static function identifies the pixel with the minimum temperature\\nfrom the specified temperature matrix. item description **type** func **param** **matrix**: The temperature matrix to be analyzed.<br> **return** Point A tuple of type <int, int, float>, representing<br>(x, y, temperature) of the pixel with the minimum temperature.<br>If the operation fails, the return values will be x, y < 0. **static** True > C++ defination code: > ```cpp > static Point min_temp_point_from(const KMatrix& matrix) > ``` #### center\\_point\\_from {#center\\_point\\_from 2} ```python def center_point_from(matrix: list[list[int]]) > tuple[int, int, float] ``` Finds the center pixel from the given matrix\\nThis static function determines the center pixel of the\\nspecified temperature matrix based on its dimensions. item description **type** func **param** **matrix**: The temperature matrix to be analyzed.<br> **return** Point A tuple of type <int, int, float>, representing<br>(x, y, temperature) of the center pixel in the matrix.<br>If the operation fails, the return values will be x, y < 0. **static** True > C++ defination code: > ```cpp > static Point center_point_from(const KMatrix& matrix) > ```"},"/maixpy/api/maix/ext_dev/cmap.html":{"title":"maix.ext_dev.cmap","content":" title: maix.ext_dev.cmap maix.ext_dev.cmap module > You can use `maix.ext_dev.cmap` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### Cmap {#Cmap} Cmap, !!!!depracated!!!!, please use maix.image.CMap. item describe **values** **WHITE_HOT**: <br>**BLACK_HOT**: <br>**IRONBOW**: <br>**NIGHT**: <br>**RED_HOT**: <br>**WHITE_HOT_SD**: <br>**BLACK_HOT_SD**: <br>**RED_HOT_SD**: <br>**JET**: <br> > C++ defination code: > ```cpp > enum class Cmap { > WHITE_HOT 0, > BLACK_HOT, > IRONBOW, > NIGHT, > RED_HOT, > WHITE_HOT_SD, > BLACK_HOT_SD, > RED_HOT_SD, > JET, > } > ``` ## Variable {#Variable} ## Function {#Function} ## Class {#Class}"},"/maixpy/api/maix/ext_dev/qmi8658.html":{"title":"maix.ext_dev.qmi8658","content":" title: maix.ext_dev.qmi8658 maix.ext_dev.qmi8658 module > You can use `maix.ext_dev.qmi8658` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ## Variable {#Variable} ## Function {#Function} ## Class {#Class} ### QMI8658 {#QMI8658} QMI8656 driver class > C++ defination code: > ```cpp > class QMI8658 > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, i2c_bus: int 1, addr: int 107, freq: int 400000, mode: maix.ext_dev.imu.Mode ..., acc_scale: maix.ext_dev.imu.AccScale ..., acc_odr: maix.ext_dev.imu.AccOdr ..., gyro_scale: maix.ext_dev.imu.GyroScale ..., gyro_odr: maix.ext_dev.imu.GyroOdr ..., block: bool True) > None ``` Construct a new QMI8658 object, will open QMI8658 item description **type** func **param** **i2c_bus**: i2c bus number. Automatically selects the on board qmi8658 when 1 is passed in.<br>**addr**: QMI8658 i2c addr.<br>**freq**: QMI8658 freq<br>**mode**: QMI8658 Mode: ACC_ONLY/GYRO_ONLY/DUAL<br>**acc_scale**: acc scale, see @qmi8658::AccScale<br>**acc_odr**: acc output data rate, see @qmi8658::AccOdr<br>**gyro_scale**: gyro scale, see @qmi8658::GyroScale<br>**gyro_odr**: gyro output data rate, see @qmi8658::GyroOdr<br>**block**: block or non block, defalut is true<br> **static** False > C++ defination code: > ```cpp > QMI8658(int i2c_bus 1, int addr 0x6B, int freq 400000, > maix::ext_dev::imu::Mode mode maix::ext_dev::imu::Mode::DUAL, > maix::ext_dev::imu::AccScale acc_scale maix::ext_dev::imu::AccScale::ACC_SCALE_2G, > maix::ext_dev::imu::AccOdr acc_odr maix::ext_dev::imu::AccOdr::ACC_ODR_8000, > maix::ext_dev::imu::GyroScale gyro_scale maix::ext_dev::imu::GyroScale::GYRO_SCALE_16DPS, > maix::ext_dev::imu::GyroOdr gyro_odr maix::ext_dev::imu::GyroOdr::GYRO_ODR_8000, > bool block true) > ``` #### read {#read} ```python def read(self) > list[float] ``` Read data from QMI8658. item description **type** func **return** list type. If only one of the outputs is initialized, only [x,y,z] of that output will be returned.<br>If all outputs are initialized, [acc_x, acc_y, acc_z, gyro_x, gyro_y, gyro_z] is returned. **static** False > C++ defination code: > ```cpp > std::vector<float> read() > ```"},"/maixpy/api/maix/ext_dev/bm8563.html":{"title":"maix.ext_dev.bm8563","content":" title: maix.ext_dev.bm8563 maix.ext_dev.bm8563 module > You can use `maix.ext_dev.bm8563` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ## Variable {#Variable} ## Function {#Function} ## Class {#Class} ### BM8563 {#BM8563} Peripheral BM8563 class > C++ defination code: > ```cpp > class BM8563 > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, i2c_bus: int 1) > None ``` BM8563 constructor item description **type** func **param** **i2c_bus**: i2c bus number.<br> **static** False > C++ defination code: > ```cpp > BM8563(int i2c_bus 1) > ``` #### datetime {#datetime} ```python def datetime(self, timetuple: list[int] []) > list[int] ``` Get or set the date and time of the BM8563. item description **type** func **param** **timetuple**: time tuple, like (year, month, day[, hour[, minute[, second]]])<br> **return** time tuple, like (year, month, day[, hour[, minute[, second]]]) **static** False > C++ defination code: > ```cpp > std::vector<int> datetime(std::vector<int> timetuple std::vector<int>()) > ``` #### init {#init} ```python def init(self, timetuple: list[int]) > maix.err.Err ``` Initialise the BM8563. item description **type** func **param** **timetuple**: time tuple, like (year, month, day[, hour[, minute[, second]]])<br> **return** err::Err type, if init success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err init(std::vector<int> timetuple) > ``` #### now {#now} ```python def now(self) > list[int] ``` Get get the current datetime. item description **type** func **return** time tuple, like (year, month, day[, hour[, minute[, second]]]) **static** False > C++ defination code: > ```cpp > std::vector<int> now() > ``` #### deinit {#deinit} ```python def deinit(self) > maix.err.Err ``` Deinit the BM8563. item description **type** func **return** err::Err err::Err type, if deinit success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err deinit() > ``` #### hctosys {#hctosys} ```python def hctosys(self) > maix.err.Err ``` Set the system time from the BM8563 item description **type** func **return** err::Err type **static** False > C++ defination code: > ```cpp > err::Err hctosys() > ``` #### systohc {#systohc} ```python def systohc(self) > maix.err.Err ``` Set the BM8563 from the system time item description **type** func **return** err::Err type **static** False > C++ defination code: > ```cpp > err::Err systohc() > ```"},"/maixpy/api/maix/ext_dev/lsm6dsowtr.html":{"title":"maix.ext_dev.lsm6dsowtr","content":" title: maix.ext_dev.lsm6dsowtr maix.ext_dev.lsm6dsowtr module > You can use `maix.ext_dev.lsm6dsowtr` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ## Variable {#Variable} ## Function {#Function} ## Class {#Class} ### LSM6DSOWTR {#LSM6DSOWTR} LSM6DSOWTR driver class > C++ defination code: > ```cpp > class LSM6DSOWTR > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, mode: maix.ext_dev.imu.Mode ..., acc_scale: maix.ext_dev.imu.AccScale ..., acc_odr: maix.ext_dev.imu.AccOdr ..., gyro_scale: maix.ext_dev.imu.GyroScale ..., gyro_odr: maix.ext_dev.imu.GyroOdr ..., block: bool True) > None ``` Construct a new LSM6DSOWTR object, will open LSM6DSOWTR item description **type** func **param** **mode**: LSM6DSOWTR Mode: ACC_ONLY/GYRO_ONLY/DUAL<br>**acc_scale**: acc scale, see @imu::AccScale<br>**acc_odr**: acc output data rate, see @imu::AccOdr<br>**gyro_scale**: gyro scale, see @imu::GyroScale<br>**gyro_odr**: gyro output data rate, see @imu::GyroOdr<br>**block**: block or non block, defalut is true<br> **static** False > C++ defination code: > ```cpp > LSM6DSOWTR( > maix::ext_dev::imu::Mode mode maix::ext_dev::imu::Mode::DUAL, > maix::ext_dev::imu::AccScale acc_scale maix::ext_dev::imu::AccScale::ACC_SCALE_2G, > maix::ext_dev::imu::AccOdr acc_odr maix::ext_dev::imu::AccOdr::ACC_ODR_8000, > maix::ext_dev::imu::GyroScale gyro_scale maix::ext_dev::imu::GyroScale::GYRO_SCALE_16DPS, > maix::ext_dev::imu::GyroOdr gyro_odr maix::ext_dev::imu::GyroOdr::GYRO_ODR_8000, > bool block true) > ``` #### read {#read} ```python def read(self) > list[float] ``` Read data from LSM6DSOWTR. item description **type** func **return** list type. If only one of the outputs is initialized, only [x,y,z] of that output will be returned.<br>If all outputs are initialized, [acc_x, acc_y, acc_z, gyro_x, gyro_y, gyro_z] is returned. **static** False > C++ defination code: > ```cpp > std::vector<float> read() > ```"},"/maixpy/api/maix/camera.html":{"title":"maix.camera","content":" title: maix.camera maix.camera module, access camera device and get image from it > You can use `maix.camera` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### AeMode {#AeMode} Auto exposure mode item describe **values** **Invalid**: <br>**Auto**: <br>**Manual**: <br> > C++ defination code: > ```cpp > enum class AeMode { > Invalid 1, > Auto 0, > Manual 1 > } > ``` ### AwbMode {#AwbMode} Auto white balance mode item describe **values** **Invalid**: <br>**Auto**: <br>**Manual**: <br> > C++ defination code: > ```cpp > enum class AwbMode { > Invalid 1, > Auto 0, > Manual 1 > } > ``` ## Variable {#Variable} ## Function {#Function} ### list\\_devices {#list\\_devices} ```python def list_devices() > list[str] ``` List all supported camera devices. item description **return** Returns the path to the camera device. > C++ defination code: > ```cpp > std::vector<std::string> list_devices() > ``` ### set\\_regs\\_enable {#set\\_regs\\_enable} ```python def set_regs_enable(enable: bool True) > None ``` Enable set camera registers, default is false, if set to true, will not set camera registers, you can manually set registers by write_reg API. item description **param** **enable**: enable/disable set camera registers<br> > C++ defination code: > ```cpp > void set_regs_enable(bool enable true) > ``` ### get\\_device\\_name {#get\\_device\\_name} ```python def get_device_name() > str ``` Get device name. Most of the time, the returned name is the name of the sensor. > C++ defination code: > ```cpp > std::string get_device_name() > ``` ### get\\_sensor\\_size {#get\\_sensor\\_size} ```python def get_sensor_size() > list[int] ``` Get sensor size item description **return** Return a list of sensor sizes, the format is [w, h]. > C++ defination code: > ```cpp > std::vector<int> get_sensor_size() > ``` ## Class {#Class} ### Camera {#Camera} Camera class > C++ defination code: > ```cpp > class Camera > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, width: int 1, height: int 1, format: maix.image.Format ..., device: str None, fps: float 1, buff_num: int 3, open: bool True, raw: bool False) > None ``` Construct a new Camera object.\\nMaximum resolution support 2560x1440. item description **type** func **param** **width**: camera width, default is 1, means auto, mostly means max width of camera support<br>**height**: camera height, default is 1, means auto, mostly means max height of camera support<br>**format**: camera output format, default is image.Format.FMT_RGB888<br>**device**: camera device path, you can get devices by list_devices method, by default(value is NULL(None in MaixPy)) means the first device<br>**fps**: camera fps, default is 1, means auto, mostly means max fps of camera support<br>**buff_num**: camera buffer number, default is 3, means 3 buffer, one used by user, one used for cache the next frame,<br>more than one buffer will accelerate image read speed, but will cost more memory.<br>**open**: If true, camera will automatically call open() after creation. default is true.<br>**raw**: If true, you can use read_raw() to capture the raw image output from the sensor.<br> **static** False > C++ defination code: > ```cpp > Camera(int width 1, int height 1, image::Format format image::FMT_RGB888, const char *device nullptr, double fps 1, int buff_num 3, bool open true, bool raw false) > ``` #### get\\_ch\\_nums {#get\\_ch\\_nums} ```python def get_ch_nums(self) > int ``` Get the number of channels supported by the camera. item description **type** func **return** Returns the maximum number of channels. **static** False > C++ defination code: > ```cpp > int get_ch_nums() > ``` #### open {#open} ```python def open(self, width: int 1, height: int 1, format: maix.image.Format ..., fps: float 1, buff_num: int 1) > maix.err.Err ``` Open camera and run item description **type** func **param** **width**: camera width, default is 1, means auto, mostly means max width of camera support<br>**height**: camera height, default is 1, means auto, mostly means max height of camera support<br>**format**: camera output format, default same as the constructor's format argument<br>**fps**: camera fps, default is 1, means auto, mostly means max fps of camera support<br>**buff_num**: camera buffer number, default is 3, means 3 buffer, one used by user, one used for cache the next frame,<br>more than one buffer will accelerate image read speed, but will cost more memory.<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err open(int width 1, int height 1, image::Format format image::FMT_INVALID, double fps 1, int buff_num 1) > ``` #### read {#read} ```python def read(self, block: bool True, block_ms: int 1) > maix.image.Image ``` Get one frame image from camera buffer, must call open method before read.\\nIf open method not called, will call it automatically, if open failed, will throw exception!\\nSo call open method before read is recommended. item description **type** func **param** **block**: block read, default is true, means block util read image successfully,<br>if set to false, will return nullptr if no image in buffer<br>**block_ms**: block read timeout<br>For the MaixCam, due to some issues with the platform’s interface, setting block_ms too low may result in duplicate frames being output.<br> **return** image::Image object, if failed, return nullptr, you should delete if manually in C++ **static** False > C++ defination code: > ```cpp > image::Image *read(bool block true, int block_ms 1) > ``` #### read\\_raw {#read\\_raw} ```python def read_raw(self) > maix.image.Image ``` Read the raw image and obtain the width, height, and format of the raw image through the returned Image object. item description **type** func **note** The raw image is in a Bayer format, and its width and height are affected by the driver. Modifying the size and format is generally not allowed. **return** image::Image object, if failed, return nullptr, you should delete if manually in C++ **static** False > C++ defination code: > ```cpp > image::Image *read_raw() > ``` #### clear\\_buff {#clear\\_buff} ```python def clear_buff(self) > None ``` Clear buff to ensure the next read image is the latest image item description **type** func **static** False > C++ defination code: > ```cpp > void clear_buff() > ``` #### skip\\_frames {#skip\\_frames} ```python def skip_frames(self, num: int) > None ``` Read some frames and drop, this is usually used avoid read not stable image when camera just opened. item description **type** func **param** **num**: number of frames to read and drop<br> **static** False > C++ defination code: > ```cpp > void skip_frames(int num) > ``` #### close {#close} ```python def close(self) > None ``` Close camera item description **type** func **static** False > C++ defination code: > ```cpp > void close() > ``` #### add\\_channel {#add\\_channel} ```python def add_channel(self, width: int 1, height: int 1, format: maix.image.Format ..., fps: float 1, buff_num: int 3, open: bool True) > Camera ``` Add a new channel and return a new Camera object, you can use close() to close this channel. item description **type** func **param** **width**: camera width, default is 1, means auto, mostly means max width of camera support<br>**height**: camera height, default is 1, means auto, mostly means max height of camera support<br>**format**: camera output format, default is RGB888<br>**fps**: camera fps, default is 1, means auto, mostly means max fps of camera support<br>**buff_num**: camera buffer number, default is 3, means 3 buffer, one used by user, one used for cache the next frame,<br>more than one buffer will accelerate image read speed, but will cost more memory.<br>**open**: If true, camera will automatically call open() after creation. default is true.<br> **return** new Camera object **static** False > C++ defination code: > ```cpp > camera::Camera *add_channel(int width 1, int height 1, image::Format format image::FMT_RGB888, double fps 1, int buff_num 3, bool open true) > ``` #### is\\_opened {#is\\_opened} ```python def is_opened(self) > bool ``` Check if camera is opened item description **type** func **return** true if camera is opened, false if not **static** False > C++ defination code: > ```cpp > bool is_opened() > ``` #### is\\_closed {#is\\_closed} ```python def is_closed(self) > bool ``` check camera device is closed or not item description **type** func **return** closed or not, bool type **static** False > C++ defination code: > ```cpp > bool is_closed() > ``` #### width {#width} ```python def width(self) > int ``` Get camera width item description **type** func **return** camera width **static** False > C++ defination code: > ```cpp > int width() > ``` #### height {#height} ```python def height(self) > int ``` Get camera height item description **type** func **return** camera height **static** False > C++ defination code: > ```cpp > int height() > ``` #### fps {#fps} ```python def fps(self) > float ``` Get camera fps item description **type** func **return** camera fps **static** False > C++ defination code: > ```cpp > double fps() > ``` #### format {#format} ```python def format(self) > maix.image.Format ``` Get camera output format item description **type** func **return** camera output format, image::Format object **static** False > C++ defination code: > ```cpp > image::Format format() > ``` #### buff\\_num {#buff\\_num} ```python def buff_num(self) > int ``` Get camera buffer number item description **type** func **return** camera buffer number **static** False > C++ defination code: > ```cpp > int buff_num() > ``` #### hmirror {#hmirror} ```python def hmirror(self, value: int 1) > int ``` Set/Get camera horizontal mirror item description **type** func **return** camera horizontal mirror **static** False > C++ defination code: > ```cpp > int hmirror(int value 1) > ``` #### vflip {#vflip} ```python def vflip(self, value: int 1) > int ``` Set/Get camera vertical flip item description **type** func **return** camera vertical flip **static** False > C++ defination code: > ```cpp > int vflip(int value 1) > ``` #### device {#device} ```python def device(self) > str ``` Get camera device path item description **type** func **return** camera device path **static** False > C++ defination code: > ```cpp > std::string device() > ``` #### write\\_reg {#write\\_reg} ```python def write_reg(self, addr: int, data: int, bit_width: int 8) > maix.err.Err ``` Write camera register item description **type** func **param** **addr**: register address<br>**data**: register data<br>**bit_width**: register data bit width, default is 8<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err write_reg(int addr, int data, int bit_width 8) > ``` #### read\\_reg {#read\\_reg} ```python def read_reg(self, addr: int, bit_width: int 8) > int ``` Read camera register item description **type** func **param** **addr**: register address<br>**bit_width**: register data bit width, default is 8<br> **return** register data, 1 means failed **static** False > C++ defination code: > ```cpp > int read_reg(int addr, int bit_width 8) > ``` #### show\\_colorbar {#show\\_colorbar} ```python def show_colorbar(self, enable: bool) > maix.err.Err ``` Camera output color bar image for test item description **type** func **param** **enable**: enable/disable color bar<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err show_colorbar(bool enable) > ``` #### get\\_channel {#get\\_channel} ```python def get_channel(self) > int ``` Get channel of camera item description **type** func **return** channel number **static** False > C++ defination code: > ```cpp > int get_channel() > ``` #### set\\_resolution {#set\\_resolution} ```python def set_resolution(self, width: int, height: int) > maix.err.Err ``` Set camera resolution item description **type** func **param** **width**: new width<br>**height**: new height<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err set_resolution(int width, int height) > ``` #### set\\_fps {#set\\_fps} ```python def set_fps(self, fps: float) > maix.err.Err ``` Set camera fps item description **type** func **param** **fps**: new fps<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err set_fps(double fps) > ``` #### exposure {#exposure} ```python def exposure(self, value: int 1) > int ``` Set/Get camera exposure item description **type** func **attention** This method will affect the isp and thus the image, so please be careful with it. **param** **value**: exposure time. unit: us<br>If value 1, return exposure time.<br>If value ! 0, set and return exposure time.<br> **return** camera exposure time **static** False > C++ defination code: > ```cpp > int exposure(int value 1) > ``` #### gain {#gain} ```python def gain(self, value: int 1) > int ``` Set/Get camera gain item description **type** func **attention** This method will affect the isp and thus the image, so please be careful with it. **param** **value**: camera gain.<br>If value 1, returns camera gain.<br>If value ! 0, set and return camera gain.<br> **return** camera gain **static** False > C++ defination code: > ```cpp > int gain(int value 1) > ``` #### iso {#iso} ```python def iso(self, value: int 1) > int ``` Set/Get camera iso item description **type** func **attention** This method will affect the isp and thus the image, so please be careful with it. **param** **value**: camera iso.<br>If value 1, returns camera iso.<br>If value ! 0, set and return camera iso.<br> **return** camera iso **static** False > C++ defination code: > ```cpp > int iso(int value 1) > ``` #### luma {#luma} ```python def luma(self, value: int 1) > int ``` Set/Get camera luma item description **type** func **attention** This method will affect the isp and thus the image, so please be careful with it. **param** **value**: luma value, range is [0, 100]<br>If value 1, returns luma value.<br>If value ! 0, set and return luma value.<br> **return** returns luma value **static** False > C++ defination code: > ```cpp > int luma(int value 1) > ``` #### constrast {#constrast} ```python def constrast(self, value: int 1) > int ``` Set/Get camera constrast item description **type** func **attention** This method will affect the isp and thus the image, so please be careful with it. **param** **value**: constrast value, range is [0, 100]<br>If value 1, returns constrast value.<br>If value ! 0, set and return constrast value.<br> **return** returns constrast value **static** False > C++ defination code: > ```cpp > int constrast(int value 1) > ``` #### saturation {#saturation} ```python def saturation(self, value: int 1) > int ``` Set/Get camera saturation item description **type** func **attention** This method will affect the isp and thus the image, so please be careful with it. **param** **value**: saturation value, range is [0, 100]<br>If value 1, returns saturation value.<br>If value ! 0, set and return saturation value.<br> **return** returns saturation value **static** False > C++ defination code: > ```cpp > int saturation(int value 1) > ``` #### awb\\_mode {#awb\\_mode} ```python def awb_mode(self, value: AwbMode ...) > AwbMode ``` Set/Get white balance mode (deprecated interface) item description **type** func **attention** This method will affect the isp and thus the image, so please be careful with it.<br>This interface may be deprecated in the future, and there may be incompatibilities in the definition of the parameters of the new interface **param** **value**: value 0, means set white balance to auto mode, value 1, means set white balance to manual mode, default is auto mode.<br> **return** returns awb mode **static** False > C++ defination code: > ```cpp > camera::AwbMode awb_mode(camera::AwbMode value camera::AwbMode::Invalid) > ``` #### set\\_awb {#set\\_awb} ```python def set_awb(self, mode: int 1) > int ``` Set/Get white balance mode (deprecated interface) item description **type** func **attention** This method will affect the isp and thus the image, so please be careful with it. **param** **value**: value 0, means set white balance to manual mode, value 1, means set white balance to auto mode, default is auto mode.<br> **return** returns awb mode **static** False > C++ defination code: > ```cpp > int set_awb(int mode 1) > ``` #### set\\_wb\\_gain {#set\\_wb\\_gain} ```python def set_wb_gain(self, gains: list[float] []) > list[float] ``` This interface is used to manually set the white balance gains and disable auto white balance, you can re enable auto white balance using awb_mode(). item description **type** func **note** MaixCam can only manually set white balance by adjusting the gain. **param** **gains**: This is a float array representing the gains for r, gr, gb, and b respectively, with a value range of 0 to 1.0.<br>For MaixCam, the recommended initial values are [0.134, 0.0625, 0.0625, 0.1239]<br>For MaixCam2, the recommended initial values are[0.0682, 0, 0, 0.04897]<br>If no parameters are passed, the current gain values will be returned.<br> **return** Returns the current gain values. **static** False > C++ defination code: > ```cpp > std::vector<float> set_wb_gain(std::vector<float> gains std::vector<float>()) > ``` #### exp\\_mode {#exp\\_mode} ```python def exp_mode(self, value: AeMode ...) > AeMode ``` Set/Get exposure mode (deprecated interface) item description **type** func **attention** This method will affect the isp and thus the image, so please be careful with it.<br>This interface may be deprecated in the future, and there may be incompatibilities in the definition of the parameters of the new interface **param** **value**: value 0, means set exposure to auto mode, value 1, means set exposure to manual mode, default is auto mode.<br> **return** returns exposure mode **static** False > C++ defination code: > ```cpp > camera::AeMode exp_mode(camera::AeMode value camera::AeMode::Invalid) > ``` #### set\\_windowing {#set\\_windowing} ```python def set_windowing(self, roi: list[int]) > maix.err.Err ``` Set window size of camera item description **type** func **param** **roi**: Support two input formats, [x,y,w,h] set the coordinates and size of the window;<br>[w,h] set the size of the window, when the window is centred.<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err set_windowing(std::vector<int> roi) > ``` #### get\\_sensor\\_size {#get\\_sensor\\_size 2} ```python def get_sensor_size(self) > list[int] ``` Get sensor size item description **type** func **return** Return a list of sensor sizes, the format is [w, h]. **static** False > C++ defination code: > ```cpp > std::vector<int> get_sensor_size() > ```"},"/maixpy/api/maix/time.html":{"title":"maix.time","content":" title: maix.time maix.time module > You can use `maix.time` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ## Variable {#Variable} ## Function {#Function} ### time {#time} ```python def time() > float ``` Get current time in s item description **return** current time in s, double type **attention** If board have no RTC battery, when bootup and connect to network,<br>system will automatically sync time by NTP, will cause time() have big change,<br>e.g. before NTP: 10(s), after: 1718590639.5149617(s).<br>If you want to calculate time interval, please use ticks_s(). > C++ defination code: > ```cpp > double time() > ``` ### time\\_ms {#time\\_ms} ```python def time_ms() > int ``` Get current time in ms item description **return** current time in ms, uint64_t type **attention** If board have no RTC battery, when bootup and connect to network,<br>system will automatically sync time by NTP, will cause time() have big change,<br>e.g. before NTP: 10000(ms), after: 1718590639000(ms)<br>If you want to calculate time interval, please use ticks_ms(). > C++ defination code: > ```cpp > uint64_t time_ms() > ``` ### time\\_s {#time\\_s} ```python def time_s() > int ``` Get current time in s item description **return** current time in s, uint64_t type **attention** If board have no RTC battery, when bootup and connect to network,<br>system will automatically sync time by NTP, will cause time() have big change,<br>e.g. before NTP: 10(s), after: 1718590639(s) > C++ defination code: > ```cpp > uint64_t time_s() > ``` ### time\\_us {#time\\_us} ```python def time_us() > int ``` Get current time in us item description **return** current time in us, uint64_t type **attention** If board have no RTC battery, when bootup and connect to network,<br>system will automatically sync time by NTP, will cause time() have big change,<br>e.g. before NTP: 10000000(us), after: 1718590639000000(s)<br>If you want to calculate time interval, please use ticks_us(). > C++ defination code: > ```cpp > uint64_t time_us() > ``` ### time\\_diff {#time\\_diff} ```python def time_diff(last: float, now: float 1) > float ``` Calculate time difference in s. item description **param** **last**: last time<br>**now**: current time, can be 1 if use current time<br> **return** time difference **attention** If board have no RTC battery, when bootup and connect to network,<br>system will automatically sync time by NTP, will cause time() have big change, and lead to big value.<br>e.g. before NTP: 1(s), after: 1718590500(s)<br>If you want to calculate time interval, please use ticks_diff(). > C++ defination code: > ```cpp > double time_diff(double last, double now 1) > ``` ### ticks\\_s {#ticks\\_s} ```python def ticks_s() > float ``` Get current time in s since bootup item description **return** current time in s, double type > C++ defination code: > ```cpp > double ticks_s() > ``` ### ticks\\_ms {#ticks\\_ms} ```python def ticks_ms() > int ``` Get current time in ms since bootup item description **return** current time in ms, uint64_t type > C++ defination code: > ```cpp > uint64_t ticks_ms() > ``` ### ticks\\_us {#ticks\\_us} ```python def ticks_us() > int ``` Get current time in us since bootup item description **return** current time in us, uint64_t type > C++ defination code: > ```cpp > uint64_t ticks_us() > ``` ### ticks\\_diff {#ticks\\_diff} ```python def ticks_diff(last: float, now: float 1) > float ``` Calculate time difference in s. item description **param** **last**: last time<br>**now**: current time, can be 1 if use current time<br> **return** time difference > C++ defination code: > ```cpp > double ticks_diff(double last, double now 1) > ``` ### sleep {#sleep} Sleep seconds item description **param** **s**: seconds, double type<br> > C++ defination code: > ```cpp > void sleep(double s) > ``` ### sleep\\_ms {#sleep\\_ms} Sleep milliseconds item description **param** **ms**: milliseconds, uint64_t type<br> > C++ defination code: > ```cpp > void sleep_ms(uint64_t ms) > ``` ### sleep\\_us {#sleep\\_us} Sleep microseconds item description **param** **us**: microseconds, uint64_t type<br> > C++ defination code: > ```cpp > void sleep_us(uint64_t us) > ``` ### fps {#fps} ```python def fps() > float ``` Calculate FPS since last call this method.\\nAttention, this method is not multi thread safe, only call this method in one threads.\\nIf you want to use in multi threads, please use time.FPS class.\\nFPS is average value of recent n(buff_len) times, and you can call fps_set_buff_len(10) to change buffer length, default is 20.\\nMultiple invoke this function will calculate fps between two invoke, and you can also call fps_start() fisrt to manually assign fps calulate start point. item description **return** float type, current fps since last call this method > C++ defination code: > ```cpp > float fps() > ``` ### fps\\_start {#fps\\_start} ```python def fps_start() > None ``` Manually set fps calculation start point, then you can call fps() function to calculate fps between fps_start() and fps(). > C++ defination code: > ```cpp > void fps_start() > ``` ### fps\\_set\\_buff\\_len {#fps\\_set\\_buff\\_len} ```python def fps_set_buff_len(len: int) > None ``` Set fps method buffer length, by default the buffer length is 10. item description **param** **len**: Buffer length to store recent fps value.<br> > C++ defination code: > ```cpp > void fps_set_buff_len(int len) > ``` ### now {#now} ```python def now() > DateTime ``` Get current UTC date and time item description **return** current date and time, DateTime type > C++ defination code: > ```cpp > time::DateTime *now() > ``` ### localtime {#localtime} ```python def localtime() > DateTime ``` Get local time item description **return** local time, DateTime type > C++ defination code: > ```cpp > time::DateTime *localtime() > ``` ### strptime {#strptime} ```python def strptime(str: str, format: str) > DateTime ``` DateTime from string item description **param** **str**: date time string<br>**format**: date time format<br> **return** DateTime > C++ defination code: > ```cpp > time::DateTime *strptime(const std::string &str, const std::string &format) > ``` ### gmtime {#gmtime} ```python def gmtime(timestamp: float) > DateTime ``` timestamp to DateTime(time zone is UTC (value 0)) item description **param** **timestamp**: double timestamp<br> **return** DateTime > C++ defination code: > ```cpp > time::DateTime *gmtime(double timestamp) > ``` ### timezone {#timezone} ```python def timezone(timezone: str '') > str ``` Set or get timezone item description **param** **timezone**: string type, can be empty and default to empty, if empty, only return crrent timezone, a \"region/city\" string, e.g. Asia/Shanghai, Etc/UTC, you can get all by list_timezones function.<br> **return** string type, return current timezone setting. **attention** when set new timezone, time setting not take effect in this process for some API, so you need to restart program. > C++ defination code: > ```cpp > std::string timezone(const std::string &timezone \"\") > ``` ### timezone2 {#timezone2} ```python def timezone2(region: str '', city: str '') > list[str] ``` Set or get timezone item description **param** **region**: string type, which region to set, can be empty means only get current, default empty.<br>**city**: string type, which city to set, can be empty means only get current, default empty.<br> **return** list type, return current timezone setting, first is region, second is city. **attention** when set new timezone, time setting not take effect in this process for some API, so you need to restart program. > C++ defination code: > ```cpp > std::vector<std::string> timezone2(const std::string &region \"\", const std::string &city \"\") > ``` ### list\\_timezones {#list\\_timezones} ```python def list_timezones() > dict[str, list[str]] ``` List all timezone info item description **return** A dict with key are regions, and value are region's cities. > C++ defination code: > ```cpp > std::map<std::string, std::vector<std::string>> list_timezones() > ``` ### ntp\\_timetuple {#ntp\\_timetuple} ```python def ntp_timetuple(host: str, port: int 1, retry: int 3, timeout_ms: int 0) > list[int] ``` Retrieves time from an NTP server\\nThis function fetches the current time from the specified NTP server and port,\\nreturning a tuple containing the time details. item description **param** **host**: The hostname or IP address of the NTP server.<br>**port**: The port number of the NTP server. Use 1 for the default port 123.<br>**retry**: The number of retry attempts. Must be at least 1.<br>**timeout_ms**: The timeout duration in milliseconds. Must be non negative.<br> **return** A list of 6 elements: [year, month, day, hour, minute, second] > C++ defination code: > ```cpp > std::vector<int> ntp_timetuple(std::string host, int port 1, uint8_t retry 3, int timeout_ms 0) > ``` ### ntp\\_timetuple\\_with\\_config {#ntp\\_timetuple\\_with\\_config} ```python def ntp_timetuple_with_config(path: str) > list[int] ``` Retrieves time from an NTP server using a configuration file\\nThis function reads the configuration from a YAML file to fetch the current time\\nfrom a list of specified NTP servers, returning a tuple containing the time details. item description **param** **path**: The path to the YAML configuration file, which should include:<br> Config:<br> retry: Number of retry attempts (must be at least 1)<br> total_timeout_ms: Total timeout duration in milliseconds (must be non negative)<br> NtpServers:<br> host: Hostname or IP address of the NTP server<br> port: Port number of the NTP server (use 123 for default)<br>Example YAML configuration:<br>Config:<br> retry: 3<br> total_timeout_ms: 10000<br>NtpServers:<br> host: \"pool.ntp.org\"<br>port: 123<br> host: \"time.nist.gov\"<br>port: 123<br> host: \"time.windows.com\"<br>port: 123<br> **return** A list of 6 elements: [year, month, day, hour, minute, second] > C++ defination code: > ```cpp > std::vector<int> ntp_timetuple_with_config(std::string path) > ``` ### ntp\\_sync\\_sys\\_time {#ntp\\_sync\\_sys\\_time} ```python def ntp_sync_sys_time(host: str, port: int 1, retry: int 3, timeout_ms: int 0) > list[int] ``` Retrieves time from an NTP server and synchronizes the system time\\nThis function fetches the current time from the specified NTP server and port,\\nthen synchronizes the system time with the retrieved time. item description **param** **host**: The hostname or IP address of the NTP server.<br>**port**: The port number of the NTP server. Use 123 for the default port.<br>**retry**: The number of retry attempts. Must be at least 1.<br>**timeout_ms**: The timeout duration in milliseconds. Must be non negative.<br> **return** A list of 6 elements: [year, month, day, hour, minute, second] > C++ defination code: > ```cpp > std::vector<int> ntp_sync_sys_time(std::string host, int port 1, uint8_t retry 3, int timeout_ms 0) > ``` ### ntp\\_sync\\_sys\\_time\\_with\\_config {#ntp\\_sync\\_sys\\_time\\_with\\_config} ```python def ntp_sync_sys_time_with_config(path: str) > list[int] ``` Retrieves time from an NTP server using a configuration file and synchronizes the system time\\nThis function reads the configuration from a YAML file to fetch the current time\\nfrom a list of specified NTP servers, then synchronizes the system time with the retrieved time. item description **param** **path**: The path to the YAML configuration file, which should include:<br> Config:<br> retry: Number of retry attempts (must be at least 1)<br> total_timeout_ms: Total timeout duration in milliseconds (must be non negative)<br> NtpServers:<br> host: Hostname or IP address of the NTP server<br> port: Port number of the NTP server (use 123 for default)<br>Example YAML configuration:<br>Config:<br> retry: 3<br> total_timeout_ms: 10000<br>NtpServers:<br> host: \"pool.ntp.org\"<br>port: 123<br> host: \"time.nist.gov\"<br>port: 123<br> host: \"time.windows.com\"<br>port: 123<br> **return** A vector of integers containing the time details: [year, month, day, hour, minute, second] > C++ defination code: > ```cpp > std::vector<int> ntp_sync_sys_time_with_config(std::string path) > ``` ## Class {#Class} ### FPS {#FPS 2} FPS class to use average filter to calculate FPS. > C++ defination code: > ```cpp > class FPS > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, buff_len: int 20) > None ``` FPS class constructor item description **type** func **param** **buff_len**: Average buffer length, default 20, that is, fps() function will return the average fps in recent buff_len times fps.<br> **static** False > C++ defination code: > ```cpp > FPS(int buff_len 20) > ``` #### start {#start} ```python def start(self) > None ``` Manually set fps calculation start point, then you can call fps() function to calculate fps between start() and fps(). item description **type** func **static** False > C++ defination code: > ```cpp > void start() > ``` #### fps {#fps 3} ```python def fps(self) > float ``` The same as end function. item description **type** func **return** float type, current fps since last call this method **static** False > C++ defination code: > ```cpp > float fps() > ``` #### end {#end} ```python def end(self) > float ``` Calculate FPS since last call this method.\\nFPS is average value of recent n(buff_len) times, and you can call fps_set_buff_len(10) to change buffer length, default is 20.\\nMultiple invoke this function will calculate fps between two invoke, and you can also call fps_start() fisrt to manually assign fps calulate start point. item description **type** func **return** float type, current fps since last call this method **static** False > C++ defination code: > ```cpp > float end() > ``` #### set\\_buff\\_len {#set\\_buff\\_len} ```python def set_buff_len(self, len: int) > None ``` Set fps method buffer length, by default the buffer length is 10. item description **type** func **param** **len**: Buffer length to store recent fps value.<br> **static** False > C++ defination code: > ```cpp > void set_buff_len(int len) > ``` ### DateTime {#DateTime} Date and time class > C++ defination code: > ```cpp > class DateTime > ``` #### year {#year} Year item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int year > ``` #### month {#month} Month, 1~12 item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int month > ``` #### day {#day} Day item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int day > ``` #### hour {#hour} Hour item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int hour > ``` #### minute {#minute} Minute item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int minute > ``` #### second {#second} Second item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int second > ``` #### microsecond {#microsecond} Microsecond item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int microsecond > ``` #### yearday {#yearday} Year day item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int yearday > ``` #### weekday {#weekday} Weekday, 0 is Monday, 6 is Sunday item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int weekday > ``` #### zone {#zone} Time zone item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float zone > ``` #### zone\\_name {#zone\\_name} Time zone name item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string zone_name > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 2} ```python def __init__(self, year: int 0, month: int 0, day: int 0, hour: int 0, minute: int 0, second: int 0, microsecond: int 0, yearday: int 0, weekday: int 0, zone: int 0) > None ``` Constructor item description **type** func **param** **year**: year<br>**month**: month<br>**day**: day<br>**hour**: hour<br>**minute**: minute<br>**second**: second<br>**microsecond**: microsecond<br>**yearday**: year day<br>**weekday**: weekday<br>**zone**: time zone<br> **static** False > C++ defination code: > ```cpp > DateTime(int year 0, int month 0, int day 0, int hour 0, int minute 0, int second 0, int microsecond 0, int yearday 0, int weekday 0, int zone 0) > ``` #### strftime {#strftime} ```python def strftime(self, format: str) > str ``` Convert to string item description **type** func **return** date time string **static** False > C++ defination code: > ```cpp > std::string strftime(const std::string &format) > ``` #### timestamp {#timestamp} ```python def timestamp(self) > float ``` Convert to float timestamp item description **type** func **return** float timestamp **static** False > C++ defination code: > ```cpp > double timestamp() > ```"},"/maixpy/api/maix/log.html":{"title":"maix.log","content":" title: maix.log maix.log module > You can use `maix.log` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### LogLevel {#LogLevel} Error log level enums item describe **values** **LEVEL_NONE**: <br>**LEVEL_ERROR**: <br>**LEVEL_WARN**: <br>**LEVEL_INFO**: <br>**LEVEL_DEBUG**: <br>**LEVEL_MAX**: <br> > C++ defination code: > ```cpp > enum class LogLevel > { > LEVEL_NONE 0, > LEVEL_ERROR, > LEVEL_WARN, > LEVEL_INFO, > LEVEL_DEBUG, > LEVEL_MAX > } > ``` ## Variable {#Variable} ## Function {#Function} ### set\\_log\\_level {#set\\_log\\_level} ```python def set_log_level(level: LogLevel, color: bool) > None ``` Set log level globally, by default log level is LEVEL_INFO. item description **param** **level**: log level, @see maix.log.LogLevel<br>**color**: true to enable color, false to disable color<br> > C++ defination code: > ```cpp > void set_log_level(log::LogLevel level, bool color) > ``` ### get\\_log\\_level {#get\\_log\\_level} ```python def get_log_level() > LogLevel ``` Get current log level item description **return** current log level > C++ defination code: > ```cpp > log::LogLevel get_log_level() > ``` ### get\\_log\\_use\\_color {#get\\_log\\_use\\_color} ```python def get_log_use_color() > bool ``` Get whether log use color item description **return** true if log use color, else false > C++ defination code: > ```cpp > bool get_log_use_color() > ``` ## Class {#Class}"},"/maixpy/api/maix/touchscreen.html":{"title":"maix.touchscreen","content":" title: maix.touchscreen maix.touchscreen module > You can use `maix.touchscreen` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ## Variable {#Variable} ## Function {#Function} ## Class {#Class} ### TouchScreen {#TouchScreen} TouchScreen class > C++ defination code: > ```cpp > class TouchScreen > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, device: str '', open: bool True) > None ``` Construct a new TouchScreen object item description **type** func **param** **device**: touchscreen device path, you can get devices by list_devices method, by default(value is NULL(None in MaixPy)) means the first device<br>**open**: If true, touchscreen will automatically call open() after creation. default is true.<br> **static** False > C++ defination code: > ```cpp > TouchScreen(const std::string &device \"\", bool open true) > ``` #### open {#open} ```python def open(self) > maix.err.Err ``` open touchscreen device item description **type** func **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err open() > ``` #### close {#close} ```python def close(self) > maix.err.Err ``` close touchscreen device item description **type** func **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err close() > ``` #### read {#read} ```python def read(self) > list[int] ``` read touchscreen device item description **type** func **attention** This method will discard same event in buffer, that is:<br>if too many move event in buffer when call this method, it will only return the last one,<br>and if read pressed or released event, it will return immediately. **return** Returns a list include x, y, pressed state **static** False > C++ defination code: > ```cpp > std::vector<int> read() > ``` #### read0 {#read0} ```python def read0(self) > list[int] ``` read touchscreen device item description **type** func **attention** This method will return immediately if have event, so it's better to use available() to check if have more event in buffer,<br>or too much event in buffer when your program call this read() interval is too long will make your program slow. **return** Returns a list include x, y, pressed state **static** False > C++ defination code: > ```cpp > std::vector<int> read0() > ``` #### available {#available} ```python def available(self, timeout: int 0) > bool ``` If we need to read from touchscreen, for event driven touchscreen means have event or not item description **type** func **param** **timeout**: 1 means block, 0 means no block, >0 means timeout, default is 0, unit is ms.<br> **return** true if need to read(have event), false if not **static** False > C++ defination code: > ```cpp > bool available(int timeout 0) > ``` #### is\\_opened {#is\\_opened} ```python def is_opened(self) > bool ``` Check if touchscreen is opened item description **type** func **return** true if touchscreen is opened, false if not **static** False > C++ defination code: > ```cpp > bool is_opened() > ``` #### clear {#clear} ```python def clear(self) > None ``` Clear touchscreen event buffer item description **type** func **static** False > C++ defination code: > ```cpp > void clear() > ```"},"/maixpy/api/maix/protocol.html":{"title":"maix.protocol","content":" title: maix.protocol maix.protocol module > You can use `maix.protocol` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### CMD {#CMD} protocol cmd, more doc see MaixCDK document's convention doc item describe **note** max app custom CMD value should < CMD_APP_MAX **values** **CMD_APP_MAX**: 200, max app custom CMD value should < CMD_APP_MAX<br>**CMD_SET_REPORT**: set auto upload data mode<br>**CMD_APP_LIST**: <br>**CMD_START_APP**: <br>**CMD_EXIT_APP**: <br>**CMD_CUR_APP_INFO**: <br>**CMD_APP_INFO**: <br>**CMD_KEY**: <br>**CMD_TOUCH**: <br> > C++ defination code: > ```cpp > enum CMD > { > CMD_APP_MAX 0xC8, // 200, max app custom CMD value should < CMD_APP_MAX > > CMD_SET_REPORT 0xF8, // set auto upload data mode > CMD_APP_LIST 0xF9, > CMD_START_APP 0xFA, > CMD_EXIT_APP 0xFB, > CMD_CUR_APP_INFO 0xFC, > CMD_APP_INFO 0xFD, > CMD_KEY 0xFE, > CMD_TOUCH 0xFF, > } > ``` ### FLAGS {#FLAGS} protocol flags, more doc see MaixCDK document's convention doc item describe **values** **FLAG_REQ**: <br>**FLAG_RESP**: <br>**FLAG_IS_RESP_MASK**: <br>**FLAG_RESP_OK**: <br>**FLAG_RESP_ERR**: <br>**FLAG_RESP_OK_MASK**: <br>**FLAG_REPORT**: <br>**FLAG_REPORT_MASK**: <br>**FLAG_VERSION_MASK**: <br> > C++ defination code: > ```cpp > enum FLAGS > { > FLAG_REQ 0x00, > FLAG_RESP 0x80, > FLAG_IS_RESP_MASK 0x80, > > FLAG_RESP_OK 0x40, > FLAG_RESP_ERR 0x00, > FLAG_RESP_OK_MASK 0x40, > > FLAG_REPORT 0x20, > FLAG_REPORT_MASK 0x20, > > FLAG_VERSION_MASK 0x03 > } > ``` ## Variable {#Variable} ### VERSION {#VERSION} protocol version item description **value** **1** **readonly** True > C++ defination code: > ```cpp > const uint8_t VERSION 1 > ``` ### HEADER {#HEADER} protocol header item description **readonly** False > C++ defination code: > ```cpp > extern uint32_t HEADER > ``` ## Function {#Function} ### crc16\\_IBM {#crc16\\_IBM} ```python def crc16_IBM(data: maix.Bytes(bytes)) > int ``` CRC16 IBM item description **param** **data**: data, bytes type.<br> **return** CRC16 IBM value, uint16_t type. > C++ defination code: > ```cpp > uint16_t crc16_IBM(const Bytes *data) > ``` ## Class {#Class} ### MSG {#MSG} protocol msg > C++ defination code: > ```cpp > class MSG > ``` #### version {#version 2} protocol version item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > uint8_t version > ``` #### resp\\_ok {#resp\\_ok} Indicate response message type, true means CMD valid and the CMD processed correctly, (only for response msg) item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > uint8_t resp_ok > ``` #### has\\_been\\_replied {#has\\_been\\_replied} Flag whether CMD has been processed and responded to CMD sender.\\nE.g. CMD CMD_START_APP will be automatically processed in CommProtocol.get_msg function,\\nso the return msg will set this flag to true. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > bool has_been_replied{false} > ``` #### cmd {#cmd 2} CMD value item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > uint8_t cmd > ``` #### is\\_resp {#is\\_resp} message is response or not, contrast with is_req item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > bool is_resp > ``` #### is\\_req {#is\\_req} message is request or not, contrast with is_resp item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > bool is_req > ``` #### is\\_report {#is\\_report} message is request or not, contrast with is_resp item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > bool is_report > ``` #### body\\_len {#body\\_len} Message body length, read only, use set_body() to update item description **type** var **attention** DO NOT manually change this value **static** False **readonly** False > C++ defination code: > ```cpp > int body_len > ``` #### encode\\_resp\\_ok {#encode\\_resp\\_ok} ```python def encode_resp_ok(*args, **kwargs) ``` Encode response ok(success) message item description **type** func **param** **body**: response body, can be null<br> **return** encoded data, if nullptr, means error, and the error code is err.Err **static** False > C++ defination code: > ```cpp > Bytes *encode_resp_ok(Bytes *body nullptr) > ``` #### encode\\_report {#encode\\_report} ```python def encode_report(*args, **kwargs) ``` Encode proactively report message item description **type** func **param** **body**: report body, can be null<br> **return** encoded data, if nullptr, means error, and the error code is err.Err **static** False > C++ defination code: > ```cpp > Bytes *encode_report(Bytes *body nullptr) > ``` #### encode\\_resp\\_err {#encode\\_resp\\_err} ```python def encode_resp_err(*args, **kwargs) ``` Encode response error message item description **type** func **param** **code**: error code<br>**msg**: error message<br> **return** encoded data, if nullptr, means error, and the error code is err.Err **static** False > C++ defination code: > ```cpp > Bytes *encode_resp_err(err::Err code, const std::string &msg) > ``` #### set\\_body {#set\\_body} ```python def set_body(self, body_new: maix.Bytes(bytes)) > None ``` Update message body item description **type** func **param** **body_new**: new body data<br> **static** False > C++ defination code: > ```cpp > void set_body(Bytes *body_new) > ``` #### get\\_body {#get\\_body} ```python def get_body(*args, **kwargs) ``` Get message body item description **type** func **return** message body, bytes type **static** False > C++ defination code: > ```cpp > Bytes *get_body() > ``` ### Protocol {#Protocol} Communicate protocol > C++ defination code: > ```cpp > class Protocol > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, buff_size: int 1024, header: int 3148663466) > None ``` Construct a new Protocol object item description **type** func **param** **buff_size**: Data queue buffer size<br> **static** False > C++ defination code: > ```cpp > Protocol(int buff_size 1024, uint32_t header maix::protocol::HEADER) > ``` #### buff\\_size {#buff\\_size} ```python def buff_size(self) > int ``` Data queue buffer size item description **type** func **static** False > C++ defination code: > ```cpp > int buff_size() > ``` #### push\\_data {#push\\_data} ```python def push_data(self, new_data: maix.Bytes(bytes)) > maix.err.Err ``` Add data to data queue item description **type** func **param** **new_data**: new data<br> **return** error code, maybe err.Err.ERR_BUFF_FULL **static** False > C++ defination code: > ```cpp > err::Err push_data(const Bytes *new_data) > ``` #### decode {#decode} ```python def decode(self, new_data: maix.Bytes(bytes) None) > MSG ``` Decode data in data queue and return a message item description **type** func **param** **new_data**: new data add to data queue, if null, only decode.<br> **return** decoded message, if nullptr, means no message decoded. **static** False > C++ defination code: > ```cpp > protocol::MSG *decode(const Bytes *new_data nullptr) > ``` #### encode\\_resp\\_ok {#encode\\_resp\\_ok 2} ```python def encode_resp_ok(*args, **kwargs) ``` Encode response ok(success) message to buffer item description **type** func **param** **cmd**: CMD value<br>**body**: response body, can be null<br> **return** encoded data, if nullptr, means error, and the error code is err.Err **static** False > C++ defination code: > ```cpp > Bytes *encode_resp_ok(uint8_t cmd, Bytes *body nullptr) > ``` #### encode\\_report {#encode\\_report 2} ```python def encode_report(*args, **kwargs) ``` Encode proactively report message to buffer item description **type** func **param** **cmd**: CMD value<br>**body**: report body, can be null<br> **return** encoded data, if nullptr, means error, and the error code is err.Err **static** False > C++ defination code: > ```cpp > Bytes *encode_report(uint8_t cmd, Bytes *body nullptr) > ``` #### encode\\_resp\\_err {#encode\\_resp\\_err 2} ```python def encode_resp_err(*args, **kwargs) ``` Encode response error message to buffer item description **type** func **param** **cmd**: CMD value<br>**code**: error code<br>**msg**: error message<br> **return** encoded data, if nullptr, means error, and the error code is err.Err **static** False > C++ defination code: > ```cpp > Bytes *encode_resp_err(uint8_t cmd, err::Err code, const std::string &msg) > ```"},"/maixpy/api/maix/fs.html":{"title":"maix.fs","content":" title: maix.fs maix.fs module > You can use `maix.fs` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### SEEK {#SEEK} SEEK enums item describe **values** **FS_SEEK_SET**: Seek from beginning of file.<br>**FS_SEEK_CUR**: Seek from current position.<br>**FS_SEEK_END**: Seek from end of file.<br> > C++ defination code: > ```cpp > enum class SEEK > { > FS_SEEK_SET 0, // Seek from beginning of file. > FS_SEEK_CUR 1, // Seek from current position. > FS_SEEK_END 2, // Seek from end of file. > } > ``` ## Variable {#Variable} ## Function {#Function} ### isabs {#isabs} ```python def isabs(path: str) > bool ``` Check if the path is absolute path item description **param** **path**: path to check<br> **return** true if path is absolute path > C++ defination code: > ```cpp > bool isabs(const std::string &path) > ``` ### isdir {#isdir} ```python def isdir(path: str) > bool ``` Check if the path is a directory, if not exist, throw exception item description **param** **path**: path to check<br> **return** true if path is a directory > C++ defination code: > ```cpp > bool isdir(const std::string &path) > ``` ### isfile {#isfile} ```python def isfile(path: str) > bool ``` Check if the path is a file, if not exist, throw exception item description **param** **path**: path to check<br> **return** true if path is a file > C++ defination code: > ```cpp > bool isfile(const std::string &path) > ``` ### islink {#islink} ```python def islink(path: str) > bool ``` Check if the path is a link, if not exist, throw exception item description **param** **path**: path to check<br> **return** true if path is a link > C++ defination code: > ```cpp > bool islink(const std::string &path) > ``` ### symlink {#symlink} ```python def symlink(src: str, link: str, force: bool False) > maix.err.Err ``` Create soft link item description **param** **src**: real file path<br>**link**: link file path<br>**force**: force link, if already have link file, will delet it first then create.<br> > C++ defination code: > ```cpp > err::Err symlink(const std::string &src, const std::string &link, bool force false) > ``` ### exists {#exists} ```python def exists(path: str) > bool ``` Check if the path exists item description **param** **path**: path to check<br> **return** true if path exists > C++ defination code: > ```cpp > bool exists(const std::string &path) > ``` ### mkdir {#mkdir} ```python def mkdir(path: str, exist_ok: bool True, recursive: bool True) > maix.err.Err ``` Create a directory recursively item description **param** **path**: path to create<br>**exist_ok**: if true, also return true if directory already exists<br>**recursive**: if true, create directory recursively, otherwise, only create one directory, default is true<br> **return** err::ERR_NONE(err.Err.ERR_NONE in MaixPy) if success, other error code if failed > C++ defination code: > ```cpp > err::Err mkdir(const std::string &path, bool exist_ok true, bool recursive true) > ``` ### rmdir {#rmdir} ```python def rmdir(path: str, recursive: bool False) > maix.err.Err ``` Remove a directory item description **param** **path**: path to remove<br>**recursive**: if true, remove directory recursively, otherwise, only remove empty directory, default is false<br> **return** err::ERR_NONE(err.Err.ERR_NONE in MaixPy) if success, other error code if failed > C++ defination code: > ```cpp > err::Err rmdir(const std::string &path, bool recursive false) > ``` ### remove {#remove} ```python def remove(path: str) > maix.err.Err ``` Remove a file item description **param** **path**: path to remove<br> **return** err::ERR_NONE(err.Err.ERR_NONE in MaixPy) if success, other error code if failed > C++ defination code: > ```cpp > err::Err remove(const std::string &path) > ``` ### rename {#rename} ```python def rename(src: str, dst: str) > maix.err.Err ``` Rename a file or directory item description **param** **src**: source path<br>**dst**: destination path, if destination dirs not exist, will auto create<br> **return** err::ERR_NONE(err.Err.ERR_NONE in MaixPy) if success, other error code if failed > C++ defination code: > ```cpp > err::Err rename(const std::string &src, const std::string &dst) > ``` ### sync {#sync} ```python def sync() > None ``` Sync files, ensure they're wrriten to disk from RAM > C++ defination code: > ```cpp > void sync() > ``` ### getsize {#getsize} ```python def getsize(path: str) > int ``` Get file size item description **param** **path**: path to get size<br> **return** file size if success, err::Err code if failed > C++ defination code: > ```cpp > int getsize(const std::string &path) > ``` ### dirname {#dirname} ```python def dirname(path: str) > str ``` Get directory name of path item description **param** **path**: path to get dirname<br> **return** dirname if success, empty string if failed > C++ defination code: > ```cpp > std::string dirname(const std::string &path) > ``` ### basename {#basename} ```python def basename(path: str) > str ``` Get base name of path item description **param** **path**: path to get basename<br> **return** basename if success, empty string if failed > C++ defination code: > ```cpp > std::string basename(const std::string &path) > ``` ### abspath {#abspath} ```python def abspath(path: str) > str ``` Get absolute path item description **param** **path**: path to get absolute path<br> **return** absolute path if success, empty string if failed > C++ defination code: > ```cpp > std::string abspath(const std::string &path) > ``` ### getcwd {#getcwd} ```python def getcwd() > str ``` Get current working directory item description **return** current working directory absolute path > C++ defination code: > ```cpp > std::string getcwd() > ``` ### realpath {#realpath} ```python def realpath(path: str) > str ``` Get realpath of path item description **param** **path**: path to get realpath<br> **return** realpath if success, empty string if failed > C++ defination code: > ```cpp > std::string realpath(const std::string &path) > ``` ### splitext {#splitext} ```python def splitext(path: str) > list[str] ``` Get file extension item description **param** **path**: path to get extension<br> **return** prefix_path and extension list if success, empty string if failed > C++ defination code: > ```cpp > std::vector<std::string> splitext(const std::string &path) > ``` ### listdir {#listdir} ```python def listdir(path: str, recursive: bool False, full_path: bool False) > list[str] ``` List files in directory item description **param** **path**: path to list<br>**recursive**: if true, list recursively, otherwise, only list current directory, default is false<br>**full_path**: if true, return full path, otherwise, only return basename, default is false<br> **return** files list if success, nullptr if failed, you should manually delete it in C++. > C++ defination code: > ```cpp > std::vector<std::string> *listdir(const std::string &path, bool recursive false, bool full_path false) > ``` ### join {#join} ```python def join(paths: list[str]) > str ``` Join paths item description **param** **paths**: paths to join<br> **return** joined path if success, empty string if failed > C++ defination code: > ```cpp > std::string join(const std::vector<std::string> &paths) > ``` ### open {#open} ```python def open(path: str, mode: str) > File ``` Open a file, and return a File object item description **param** **path**: path to open<br>**mode**: open mode, support \"r\", \"w\", \"a\", \"r+\", \"w+\", \"a+\", \"rb\", \"wb\", \"ab\", \"rb+\", \"wb+\", \"ab+\"<br> **return** File object if success(need to delete object manually in C/C++), nullptr if failed > C++ defination code: > ```cpp > fs::File *open(const std::string &path, const std::string &mode) > ``` ### tempdir {#tempdir} ```python def tempdir() > str ``` Get temp files directory item description **return** temp files directory > C++ defination code: > ```cpp > std::string tempdir() > ``` ## Class {#Class} ### File {#File} File read write ops > C++ defination code: > ```cpp > class File > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, path: str '', mode: str 'r') > None ``` Construct File object item description **type** func **static** False > C++ defination code: > ```cpp > File(const std::string path \"\", const std::string &mode \"r\") > ``` #### open {#open 2} ```python def open(self, path: str, mode: str) > maix.err.Err ``` Open a file item description **type** func **param** **path**: path to open<br>**mode**: open mode, support \"r\", \"w\", \"a\", \"r+\", \"w+\", \"a+\", \"rb\", \"wb\", \"ab\", \"rb+\", \"wb+\", \"ab+\"<br> **return** err::ERR_NONE(err.Err.ERR_NONE in MaixPy) if success, other error code if failed **static** False > C++ defination code: > ```cpp > err::Err open(const std::string &path, const std::string &mode) > ``` #### close {#close} ```python def close(self) > None ``` Close a file. item description **type** func **attention** not ensure data is written to disk, you can use sync() before close to ensure data is written to disk. **static** False > C++ defination code: > ```cpp > void close() > ``` #### read {#read} ```python def read(self, size: int) > list[int] ``` Read data from file API2 item description **type** func **param** **size**: max read size<br> **return** bytes data if success(need delete manually in C/C++), nullptr if failed **static** False > C++ defination code: > ```cpp > std::vector<uint8_t> *read(int size) > ``` #### readline {#readline} ```python def readline(self) > str ``` Read line from file item description **type** func **return** line if success, None(nullptr in C++) if failed. You need to delete the returned object manually in C/C++. **static** False > C++ defination code: > ```cpp > std::string *readline() > ``` #### eof {#eof} ```python def eof(self) > int ``` End of file or not item description **type** func **return** 0 if not reach end of file, else eof. **static** False > C++ defination code: > ```cpp > int eof() > ``` #### write {#write} ```python def write(self, buf: list[int]) > int ``` Write data to file API2 item description **type** func **param** **buf**: buffer to write<br> **attention** will not ensure data is flush to kernel or written to disk, you can use flush() to flush data to kernel,<br>and sync() to ensure data is written to disk. **return** write size if success, err::Err code if failed **static** False > C++ defination code: > ```cpp > int write(const std::vector<uint8_t> &buf) > ``` #### seek {#seek 2} ```python def seek(self, offset: int, whence: int) > int ``` Seek file position item description **type** func **param** **offset**: offset to seek<br>**whence**: @see maix.fs.SEEK<br> **return** new position if success, err::Err code if failed **static** False > C++ defination code: > ```cpp > int seek(int offset, int whence) > ``` #### tell {#tell} ```python def tell(self) > int ``` Get file position item description **type** func **return** file position if success, err::Err code if failed **static** False > C++ defination code: > ```cpp > int tell() > ``` #### size {#size} ```python def size(self) > int ``` Get file size item description **type** func **attention** will change file seek position temporarily when get file size. **return** file size if success, err::Err code if failed **static** False > C++ defination code: > ```cpp > int size() > ``` #### flush {#flush} ```python def flush(self) > maix.err.Err ``` Flush file, ensure data is written to kernel buffer. item description **type** func **attention** not ensure data is written to disk, use sync() to ensure data is written to disk. **return** err::ERR_NONE(err.Err.ERR_NONE in MaixPy) if success, other error code if failed **static** False > C++ defination code: > ```cpp > err::Err flush() > ``` #### sync {#sync 2} ```python def sync(self) > maix.err.Err ``` Sync file, ensure data is written to disk. item description **type** func **return** err::ERR_NONE(err.Err.ERR_NONE in MaixPy) if success, other error code if failed **static** False > C++ defination code: > ```cpp > err::Err sync() > ```"},"/maixpy/api/maix/app.html":{"title":"maix.app","content":" title: maix.app maix.app module > You can use `maix.app` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ## Variable {#Variable} ## Function {#Function} ### app\\_id {#app\\_id} ```python def app_id() > str ``` Get current APP ID. item description **return** APP ID. > C++ defination code: > ```cpp > string app_id() > ``` ### set\\_app\\_id {#set\\_app\\_id} ```python def set_app_id(app_id: str) > str ``` Set current APP ID. item description **param** **app_id**: APP ID.<br> > C++ defination code: > ```cpp > string set_app_id(const string &app_id) > ``` ### get\\_apps\\_info\\_path {#get\\_apps\\_info\\_path} ```python def get_apps_info_path() > str ``` Get APP info file path. > C++ defination code: > ```cpp > string get_apps_info_path() > ``` ### get\\_apps\\_info {#get\\_apps\\_info} ```python def get_apps_info(ignore_launcher: bool False, ignore_app_store: bool False) > list[APP_Info] ``` Get APP info list. item description **param** **ignore_launcher**: if true, ignore launcher APP. default false.<br>**ignore_app_store**: if true, ignore app store APP. default false.<br> **return** APP info list. APP_Info object list. > C++ defination code: > ```cpp > vector<app::APP_Info> &get_apps_info(bool ignore_launcher false, bool ignore_app_store false) > ``` ### get\\_app\\_info {#get\\_app\\_info} ```python def get_app_info(app_id: str) > APP_Info ``` Get app info by app id. item description **return** app.APP_Info type. > C++ defination code: > ```cpp > app::APP_Info get_app_info(const std::string &app_id) > ``` ### get\\_app\\_data\\_path {#get\\_app\\_data\\_path} ```python def get_app_data_path() > str ``` Get APP info, APP can store private data in this directory. item description **return** APP data path \"./data\", just return the data folder in current path because APP executed in app install path or project path.<br>So, you must execute your program in you project path to use the project/data folder when you debug your APP. > C++ defination code: > ```cpp > string get_app_data_path() > ``` ### get\\_app\\_path {#get\\_app\\_path} ```python def get_app_path(app_id: str '') > str ``` Get APP path. item description **param** **app_id**: APP ID, if empty, return current APP path, else return the APP path by app_id.<br> **return** APP path, just return the current path because APP executed in app install path or project path.<br>So, you must execute your program in you project path to use the project/data folder when you debug your APP. > C++ defination code: > ```cpp > string get_app_path(const string &app_id \"\") > ``` ### get\\_tmp\\_path {#get\\_tmp\\_path} ```python def get_tmp_path() > str ``` Get global temporary data path, APPs can use this path as temporary data directory. item description **return** temporary data path. > C++ defination code: > ```cpp > string get_tmp_path() > ``` ### get\\_share\\_path {#get\\_share\\_path} ```python def get_share_path() > str ``` Get data path of share, shared data like picture and video will put in this directory item description **return** share data path. > C++ defination code: > ```cpp > string get_share_path() > ``` ### get\\_picture\\_path {#get\\_picture\\_path} ```python def get_picture_path() > str ``` Get picture path of share, shared picture will put in this directory item description **return** share picture path. > C++ defination code: > ```cpp > string get_picture_path() > ``` ### get\\_video\\_path {#get\\_video\\_path} ```python def get_video_path() > str ``` Get video path of share, shared video will put in this directory item description **return** share video path. > C++ defination code: > ```cpp > string get_video_path() > ``` ### get\\_font\\_path {#get\\_font\\_path} ```python def get_font_path() > str ``` Get font path of share, shared font will put in this directory item description **return** share font path. > C++ defination code: > ```cpp > string get_font_path() > ``` ### get\\_icon\\_path {#get\\_icon\\_path} ```python def get_icon_path() > str ``` Get icon path of share, shared icon will put in this directory item description **return** share icon path. > C++ defination code: > ```cpp > string get_icon_path() > ``` ### get\\_sys\\_config\\_kv {#get\\_sys\\_config\\_kv} ```python def get_sys_config_kv(item: str, key: str, value: str '', from_cache: bool True) > str ``` Get system config item value.\\nYou can find all supported config items in https://wiki.sipeed.com/maixpy/doc/zh/basic/app.html . item description **param** **item**: name of setting item, e.g. wifi, language. more see settings APP.<br>**key**: config key, e.g. for wifi, key can be ssid, for language, key can be locale.<br>**value**: default value, if not found, return this value.<br>**from_cache**: if true, read from cache, if false, read from file.<br> **return** config value, always string type, if not found, return empty string. > C++ defination code: > ```cpp > string get_sys_config_kv(const string &item, const string &key, const string &value \"\", bool from_cache true) > ``` ### set\\_sys\\_config\\_kv {#set\\_sys\\_config\\_kv} ```python def set_sys_config_kv(item: str, key: str, value: str, write_file: bool True) > maix.err.Err ``` Set system config item value. item description **attention** It's not recommend to use this method in your APP, this method should only called by settings APP.<br>If you have to do set config in your APP, some settings will not take effect until restart APP or reboot.<br>For example, if you change wifi ssid here, wifi will not take effect until reboot, it is recommend to call wifi API to connect. > C++ defination code: > ```cpp > err::Err set_sys_config_kv(const string &item, const string &key, const string &value, bool write_file true) > ``` ### get\\_app\\_config\\_kv {#get\\_app\\_config\\_kv} ```python def get_app_config_kv(item: str, key: str, value: str '', from_cache: bool True) > str ``` Get APP config item value. item description **param** **item**: name of setting item, e.g. user_info<br>**key**: config key, e.g. for user_info, key can be name, age etc.<br>**value**: default value, if not found, return this value.<br>**from_cache**: if true, read from cache, if false, read from file.<br> **return** config value, always string type, if not found, return empty string. > C++ defination code: > ```cpp > string get_app_config_kv(const string &item, const string &key, const string &value \"\", bool from_cache true) > ``` ### set\\_app\\_config\\_kv {#set\\_app\\_config\\_kv} ```python def set_app_config_kv(item: str, key: str, value: str, write_file: bool True) > maix.err.Err ``` Set APP config item value. item description **param** **item**: name of setting item, e.g. user_info<br>**key**: config key, e.g. for user_info, key can be name, age etc.<br>**value**: config value, always string type.<br>**write_file**: if true, write to file, if false, just write to cache.<br> **return** err::Err > C++ defination code: > ```cpp > err::Err set_app_config_kv(const string &item, const string &key, const string &value, bool write_file true) > ``` ### get\\_app\\_config\\_path {#get\\_app\\_config\\_path} ```python def get_app_config_path() > str ``` Get APP config path, ini format, so you can use your own ini parser to parse it like `configparser` in Python.\\nAll APP config info is recommended to store in this file. item description **return** APP config path(ini format). > C++ defination code: > ```cpp > string get_app_config_path() > ``` ### set\\_exit\\_msg {#set\\_exit\\_msg} ```python def set_exit_msg(code: maix.err.Err, msg: str) > maix.err.Err ``` Set APP exit code and exit message.\\nIf code ! 0, the launcher will show a dialog to user, and display the msg. item description **param** **code**: exit code, 0 means success, other means error, if code is 0, do nothing.<br>**msg**: exit message, if code is 0, msg is not used.<br> **return** exit code, the same as arg @code. > C++ defination code: > ```cpp > err::Err set_exit_msg(err::Err code, const string &msg) > ``` ### get\\_exit\\_msg {#get\\_exit\\_msg} ```python def get_exit_msg(cache: bool False) > tuple[str, maix.err.Err, str] ``` Get APP exit code and exit message. item description **param** **cache**: if true, read from cache, if false, read from file. default false.<br> **return** exit return app_id, exit code and exit message. > C++ defination code: > ```cpp > tuple<string, err::Err, string> get_exit_msg(bool cache false) > ``` ### have\\_exit\\_msg {#have\\_exit\\_msg} ```python def have_exit_msg(cache: bool False) > bool ``` Check if have exit msg item description **param** **cache**: if true, just check from cache, if false, check from file. default false.<br> **return** true if have exit msg, false if not. > C++ defination code: > ```cpp > bool have_exit_msg(bool cache false) > ``` ### switch\\_app {#switch\\_app} ```python def switch_app(app_id: str, idx: int 1, start_param: str '') > None ``` Exit this APP and start another APP(by launcher).\\nCall this API will call set_exit_flag(true), you should check app::need_exit() in your code.\\nAnd exit this APP if app::need_exit() return true. item description **param** **app_id**: APP ID which will be started. app_id and idx must have one is valid.<br>**idx**: APP index. app_id and idx must have one is valid.<br>**start_param**: string type, will send to app, app can get this param by `app.get_start_param()`<br> **attention** If app id or idx the same as current app, do nothing. > C++ defination code: > ```cpp > void switch_app(const string &app_id, int idx 1, const std::string &start_param \"\") > ``` ### get\\_start\\_param {#get\\_start\\_param} ```python def get_start_param() > str ``` Get start param set by caller item description **return** param, string type > C++ defination code: > ```cpp > const std::string get_start_param() > ``` ### need\\_exit {#need\\_exit} ```python def need_exit() > bool ``` Shoule this APP exit? item description **return** true if this APP should exit, false if not. **attention** This API is a function, not a variable. > C++ defination code: > ```cpp > bool need_exit() > ``` ### running {#running} ```python def running() > bool ``` App should running? The same as !app::need_exit() (not app::need_exit() in MaixPy). item description **return** true if this APP should running, false if not. **attention** This API is a function, not a variable. > C++ defination code: > ```cpp > bool running() > ``` ### set\\_exit\\_flag {#set\\_exit\\_flag} ```python def set_exit_flag(exit: bool) > None ``` Set exit flag. You can get exit flag by app.need_exit(). item description **param** **exit**: true if this APP should exit, false if not.<br> > C++ defination code: > ```cpp > void set_exit_flag(bool exit) > ``` ## Class {#Class} ### Version {#Version} APP version > C++ defination code: > ```cpp > class Version > ``` #### \\_\\_str\\_\\_ {#\\_\\_str\\_\\_} ```python def __str__(self) > str ``` Convert to string, e.g. 1.0.0 item description **type** func **static** False > C++ defination code: > ```cpp > std::string __str__() > ``` #### from\\_str {#from\\_str} ```python def from_str(version_str: str) > Version ``` Convert from string, e.g. \\\"1.0.0\\\" item description **type** func **static** True > C++ defination code: > ```cpp > static app::Version from_str(const string &version_str) > ``` ### APP\\_Info {#APP\\_Info} APP info > C++ defination code: > ```cpp > class APP_Info > ``` #### id {#id} APP id item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > string id > ``` #### name {#name} APP name item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > string name > ``` #### icon {#icon} APP icon item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > string icon > ``` #### version {#version 2} APP version item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > Version version > ``` #### exec {#exec} APP exec item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > string exec > ``` #### author {#author} APP author item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > string author > ``` #### desc {#desc} APP desc item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > string desc > ``` #### names {#names} APP names item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > map<string, string> names > ``` #### descs {#descs} APP descs item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > map<string, string> descs > ```"},"/maixpy/api/maix/err.html":{"title":"maix.err","content":" title: maix.err maix.err module > You can use `maix.err` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### Err {#Err} Maix Error code item describe **values** **ERR_NONE**: No error<br>**ERR_ARGS**: Invalid arguments<br>**ERR_NO_MEM**: No memory<br>**ERR_NOT_IMPL**: Not implemented<br>**ERR_NOT_READY**: Not ready<br>**ERR_NOT_INIT**: Not initialized<br>**ERR_NOT_OPEN**: Not opened<br>**ERR_NOT_PERMIT**: Not permitted<br>**ERR_REOPEN**: Re open<br>**ERR_BUSY**: Busy<br>**ERR_READ**: Read error<br>**ERR_WRITE**: Write error<br>**ERR_TIMEOUT**: Timeout<br>**ERR_RUNTIME**: Runtime error<br>**ERR_IO**: IO error<br>**ERR_NOT_FOUND**: Not found<br>**ERR_ALREAY_EXIST**: Already exist<br>**ERR_BUFF_FULL**: Buffer full<br>**ERR_BUFF_EMPTY**: Buffer empty<br>**ERR_CANCEL**: Cancel<br>**ERR_OVERFLOW**: Overflow<br>**ERR_MAX**: <br> > C++ defination code: > ```cpp > enum Err > { > // !!! fixed error code, DO NOT change number already defined, only append new error code > ERR_NONE 0, // No error > ERR_ARGS , // Invalid arguments > ERR_NO_MEM , // No memory > ERR_NOT_IMPL , // Not implemented > ERR_NOT_READY , // Not ready > ERR_NOT_INIT , // Not initialized > ERR_NOT_OPEN , // Not opened > ERR_NOT_PERMIT , // Not permitted > ERR_REOPEN , // Re open > ERR_BUSY , // Busy > ERR_READ , // Read error > ERR_WRITE , // Write error > ERR_TIMEOUT , // Timeout > ERR_RUNTIME , // Runtime error > ERR_IO , // IO error > ERR_NOT_FOUND , // Not found > ERR_ALREAY_EXIST , // Already exist > ERR_BUFF_FULL , // Buffer full > ERR_BUFF_EMPTY , // Buffer empty > ERR_CANCEL , // Cancel > ERR_OVERFLOW , // Overflow > ERR_MAX, > } > ``` ## Variable {#Variable} ## Function {#Function} ### to\\_str {#to\\_str} ```python def to_str(e: Err) > str ``` Error code to string item description **param** **e**: direction [in], error code, err::Err type<br> **return** error string > C++ defination code: > ```cpp > std::string to_str(err::Err e) > ``` ### get\\_error {#get\\_error} ```python def get_error() > str ``` get last error string item description **return** error string > C++ defination code: > ```cpp > std::string& get_error() > ``` ### set\\_error {#set\\_error} ```python def set_error(str: str) > None ``` set last error string item description **param** **str**: direction [in], error string<br> > C++ defination code: > ```cpp > void set_error(const std::string &str) > ``` ### check\\_raise {#check\\_raise} ```python def check_raise(e: Err, msg: str '') > None ``` Check error code, if not ERR_NONE, raise err.Exception item description **param** **e**: direction [in], error code, err::Err type<br>**msg**: direction [in], error message<br> > C++ defination code: > ```cpp > void check_raise(err::Err e, const std::string &msg \"\") > ``` ### check\\_bool\\_raise {#check\\_bool\\_raise} ```python def check_bool_raise(ok: bool, msg: str '') > None ``` Check condition, if false, raise err.Exception item description **param** **ok**: direction [in], condition, if true, do nothing, if false, raise err.Exception<br>**msg**: direction [in], error message<br> > C++ defination code: > ```cpp > void check_bool_raise(bool ok, const std::string &msg \"\") > ``` ### check\\_null\\_raise {#check\\_null\\_raise} ```python def check_null_raise(ptr: capsule, msg: str '') > None ``` Check NULL pointer, if NULL, raise exception item description **param** **ptr**: direction [in], pointer<br>**msg**: direction [in], error message<br> > C++ defination code: > ```cpp > void check_null_raise(void *ptr, const std::string &msg \"\") > ``` ## Class {#Class} ### Exception {#Exception} Maix Exception > C++ defination code: > ```cpp > class Exception : public std::exception > ```"},"/maixpy/api/index.html":{"title":"MaixPy API -- Maix AI machine vision platform Python API","content":" title: MaixPy API Maix AI machine vision platform Python API **You can read API doc at [MaixPy API on Sipeed Wiki](https://wiki.sipeed.com/maixpy/api/index.html)** If you want to **preview API doc offline**, two ways: 1. Download offline doc files from [Releases page](https://github.com/sipeed/MaixPy/releases), file name is `maixpy_vx.x.x_doc.zip`. 2. Build MaixPy, and API doc will be generated in `MaixPy/docs/api/` directory. > For MaixPy developer: This API documentation is generated from the source code, DO NOT edit this file manually! MaixPy API documentation, modules: module brief [maix.err](./maix/err.html) maix.err module [maix.tensor](./maix/tensor.html) maix.tensor module [maix.image](./maix/image.html) maix.image module, image related definition and functions [maix.camera](./maix/camera.html) maix.camera module, access camera device and get image from it [maix.display](./maix/display.html) maix.display module, control display device and show image on it [maix.ext_dev](./maix/ext_dev.html) maix.ext_dev module [maix.nn](./maix/nn.html) maix.nn module [maix.audio](./maix/audio.html) maix.audio module [maix.network](./maix/network.html) maix.network module [maix.comm](./maix/comm.html) maix.comm module [maix.example](./maix/example.html) example module, this will be maix.example module in MaixPy, maix::example namespace in MaixCDK [maix.log](./maix/log.html) maix.log module [maix.app](./maix/app.html) maix.app module [maix.thread](./maix/thread.html) maix.thread module [maix.protocol](./maix/protocol.html) maix.protocol module [maix.sys](./maix/sys.html) maix.sys module [maix.fs](./maix/fs.html) maix.fs module [maix.i18n](./maix/i18n.html) maix.i18n module [maix.time](./maix/time.html) maix.time module [maix.util](./maix/util.html) maix.util module [maix.touchscreen](./maix/touchscreen.html) maix.touchscreen module [maix.rtmp](./maix/rtmp.html) maix.rtmp module [maix.tracker](./maix/tracker.html) maix.tracker module [maix.video](./maix/video.html) maix.video module [maix.uvc](./maix/uvc.html) maix.uvc module [maix.pipeline](./maix/pipeline.html) maix.pipeline module, video stream processing via pipeline [maix.http](./maix/http.html) maix.http module [maix.rtsp](./maix/rtsp.html) maix.rtsp module [maix.peripheral](./maix/peripheral.html) Chip's peripheral driver [maix.ahrs](./maix/ahrs.html) maix.ahrs module "},"/maixpy/api/README2.html":{"title":"Where is the API docs?","content":"Where is the API docs? API docs is generated from source code comments, and can be read online at [MaixPy API on Sipeed Wiki](https://wiki.sipeed.com/maixpy/api/index.html). If you want to preview API doc offline, there are two ways: 1. Download offline docs file(`maixpy_vx.x.x_doc.zip`) from [MaixPy releases page](https://github.com/sipeed/MaixPy/releases). 2. Build MaixPy project, and API doc will be generated in `MaixPy/docs/api/` directory."},"/maixpy/api/maix/rtsp.html":{"title":"maix.rtsp","content":" title: maix.rtsp maix.rtsp module > You can use `maix.rtsp` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### RtspStreamType {#RtspStreamType} The stream type of rtsp item describe **values** **RTSP_STREAM_NONE**: format invalid<br>**RTSP_STREAM_H264**: <br>**RTSP_STREAM_H265**: <br> > C++ defination code: > ```cpp > enum RtspStreamType > { > RTSP_STREAM_NONE 0, // format invalid > RTSP_STREAM_H264, > RTSP_STREAM_H265, > } > ``` ## Variable {#Variable} ## Function {#Function} ## Class {#Class} ### Region {#Region} Region class > C++ defination code: > ```cpp > class Region > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, x: int, y: int, width: int, height: int, format: maix.image.Format, camera: maix.camera.Camera) > None ``` Construct a new Region object item description **type** func **param** **x**: region coordinate x<br>**y**: region coordinate y<br>**width**: region width<br>**height**: region height<br>**format**: region format<br>**camera**: bind region to camera<br> **static** False > C++ defination code: > ```cpp > Region(int x, int y, int width, int height, image::Format format, camera::Camera *camera) > ``` #### get\\_canvas {#get\\_canvas} ```python def get_canvas(self) > maix.image.Image ``` Return an image object from region item description **type** func **return** image object **static** False > C++ defination code: > ```cpp > image::Image *get_canvas() > ``` #### update\\_canvas {#update\\_canvas} ```python def update_canvas(self) > maix.err.Err ``` Update canvas item description **type** func **return** error code **static** False > C++ defination code: > ```cpp > err::Err update_canvas() > ``` ### Rtsp {#Rtsp} Rtsp class > C++ defination code: > ```cpp > class Rtsp > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 2} ```python def __init__(self, ip: str '', port: int 8554, fps: int 30, stream_type: RtspStreamType ..., bitrate: int 3000000) > None ``` Construct a new Video object item description **type** func **param** **ip**: rtsp ip<br>**port**: rtsp port<br>**fps**: rtsp fps<br>**stream_type**: rtsp stream type<br>**bitrate**: rtsp bitrate<br> **static** False > C++ defination code: > ```cpp > Rtsp(std::string ip std::string(), int port 8554, int fps 30, rtsp::RtspStreamType stream_type rtsp::RtspStreamType::RTSP_STREAM_H264, int bitrate 3000 * 1000) > ``` #### start {#start} ```python def start(self) > maix.err.Err ``` start rtsp item description **type** func **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err start() > ``` #### stop {#stop} ```python def stop(self) > maix.err.Err ``` stop rtsp item description **type** func **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err stop() > ``` #### bind\\_camera {#bind\\_camera} ```python def bind_camera(self, camera: maix.camera.Camera) > maix.err.Err ``` Bind camera item description **type** func **param** **camera**: camera object<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err bind_camera(camera::Camera *camera) > ``` #### bind\\_audio\\_recorder {#bind\\_audio\\_recorder} ```python def bind_audio_recorder(self, recorder: maix.audio.Recorder) > maix.err.Err ``` Bind audio recorder item description **type** func **note** If the audio_recorder object is bound, the audio_recorder object cannot be used elsewhere. **param** **recorder**: audio_recorder object<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err bind_audio_recorder(audio::Recorder *recorder) > ``` #### write {#write} ```python def write(self, frame: maix.video.Frame) > maix.err.Err ``` Write data to rtsp(This function will be removed in the future) item description **type** func **param** **frame**: video frame data<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err write(video::Frame &frame) > ``` #### get\\_url {#get\\_url} ```python def get_url(self) > str ``` Get url of rtsp item description **type** func **return** url of rtsp **static** False > C++ defination code: > ```cpp > std::string get_url() > ``` #### get\\_urls {#get\\_urls} ```python def get_urls(self) > list[str] ``` Get url list of rtsp item description **type** func **return** url list of rtsp **static** False > C++ defination code: > ```cpp > std::vector<std::string> get_urls() > ``` #### to\\_camera {#to\\_camera} ```python def to_camera(self) > maix.camera.Camera ``` Get camera object from rtsp item description **type** func **return** camera object **static** False > C++ defination code: > ```cpp > camera::Camera *to_camera() > ``` #### add\\_region {#add\\_region} ```python def add_region(self, x: int, y: int, width: int, height: int, format: maix.image.Format ...) > Region ``` return a region object, you can draw image on the region.(This function will be removed in the future) item description **type** func **param** **x**: region coordinate x<br>**y**: region coordinate y<br>**width**: region width<br>**height**: region height<br>**format**: region format, support Format::FMT_BGRA8888 only<br> **return** the reigon object **static** False > C++ defination code: > ```cpp > rtsp::Region *add_region(int x, int y, int width, int height, image::Format format image::Format::FMT_BGRA8888) > ``` #### update\\_region {#update\\_region} ```python def update_region(self, region: Region) > maix.err.Err ``` update and show region(This function will be removed in the future) item description **type** func **return** error code **static** False > C++ defination code: > ```cpp > err::Err update_region(rtsp::Region &region) > ``` #### del\\_region {#del\\_region} ```python def del_region(self, region: Region) > maix.err.Err ``` del region(This function will be removed in the future) item description **type** func **return** error code **static** False > C++ defination code: > ```cpp > err::Err del_region(rtsp::Region *region) > ``` #### draw\\_rect {#draw\\_rect} ```python def draw_rect(self, id: int, x: int, y: int, width: int, height: int, color: maix.image.Color, thickness: int 1) > maix.err.Err ``` Draw a rectangle on the canvas(This function will be removed in the future) item description **type** func **param** **id**: region id<br>**x**: rectangle coordinate x<br>**y**: rectangle coordinate y<br>**width**: rectangle width<br>**height**: rectangle height<br>**color**: rectangle color<br>**thickness**: rectangle thickness. If you set it to 1, the rectangle will be filled.<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err draw_rect(int id, int x, int y, int width, int height, image::Color color, int thickness 1) > ``` #### draw\\_string {#draw\\_string} ```python def draw_string(self, id: int, x: int, y: int, str: str, color: maix.image.Color, size: int 16, thickness: int 1) > maix.err.Err ``` Draw a string on the canvas(This function will be removed in the future) item description **type** func **param** **id**: region id<br>**x**: string coordinate x<br>**y**: string coordinate y<br>**str**: string<br>**color**: string color<br>**size**: string size<br>**thickness**: string thickness<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err draw_string(int id, int x, int y, const char *str, image::Color color, int size 16, int thickness 1) > ```"},"/maixpy/api/maix/pipeline.html":{"title":"maix.pipeline","content":" title: maix.pipeline maix.pipeline module, video stream processing via pipeline > You can use `maix.pipeline` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ## Variable {#Variable} ## Function {#Function} ## Class {#Class} ### Stream {#Stream} Stream class, saved the video stream data > C++ defination code: > ```cpp > class Stream > ``` #### data\\_count {#data\\_count} ```python def data_count(self) > int ``` Since a single stream may contain multiple pieces of data, this returns the number of data segments present. item description **type** func **static** False > C++ defination code: > ```cpp > int data_count() > ``` #### data {#data} ```python def data(*args, **kwargs) ``` Get the data stream at index item description **type** func **param** **idx**: data index, must be less than data_count().<br> **return** Returns the data at index. Note: when using C++, you need to manually release the memory. **static** False > C++ defination code: > ```cpp > Bytes *data(int idx) > ``` #### data\\_size {#data\\_size} ```python def data_size(self, idx: int) > int ``` Get the data size at index item description **type** func **param** **idx**: data index, must be less than data_count().<br> **return** Returns the data size at index. **static** False > C++ defination code: > ```cpp > int data_size(int idx) > ``` #### get\\_sps\\_frame {#get\\_sps\\_frame} ```python def get_sps_frame(*args, **kwargs) ``` Get the SPS frame data; if the frame does not exist, return null. item description **type** func **return** SPS frame data. **static** False > C++ defination code: > ```cpp > Bytes *get_sps_frame() > ``` #### get\\_pps\\_frame {#get\\_pps\\_frame} ```python def get_pps_frame(*args, **kwargs) ``` Get the PPS frame data; if the frame does not exist, return null. item description **type** func **return** PPS frame data. **static** False > C++ defination code: > ```cpp > Bytes *get_pps_frame() > ``` #### get\\_i\\_frame {#get\\_i\\_frame} ```python def get_i_frame(*args, **kwargs) ``` Get the I frame data; if the frame does not exist, return null. item description **type** func **return** I frame data. **static** False > C++ defination code: > ```cpp > Bytes *get_i_frame() > ``` #### get\\_p\\_frame {#get\\_p\\_frame} ```python def get_p_frame(*args, **kwargs) ``` Get the PTS(Presentation Timestamp) of the stream. item description **type** func **return** P frame data. **static** False > C++ defination code: > ```cpp > Bytes *get_p_frame() > ``` #### has\\_pps\\_frame {#has\\_pps\\_frame} ```python def has_pps_frame(self) > bool ``` Check if the stream has PPS frame. item description **type** func **return** PPS frame data. **static** False > C++ defination code: > ```cpp > bool has_pps_frame() > ``` #### has\\_sps\\_frame {#has\\_sps\\_frame} ```python def has_sps_frame(self) > bool ``` Check if the stream has SPS frame. item description **type** func **return** SPS frame data. **static** False > C++ defination code: > ```cpp > bool has_sps_frame() > ``` #### has\\_i\\_frame {#has\\_i\\_frame} ```python def has_i_frame(self) > bool ``` Check if the stream has I frame. item description **type** func **return** True if the stream has I frame, otherwise false. **static** False > C++ defination code: > ```cpp > bool has_i_frame() > ``` #### has\\_p\\_frame {#has\\_p\\_frame} ```python def has_p_frame(self) > bool ``` Check if the stream has P frame. item description **type** func **return** True if the stream has P frame, otherwise false. **static** False > C++ defination code: > ```cpp > bool has_p_frame() > ``` #### pts {#pts} ```python def pts(self) > int ``` Get the pts(Presentation Timestamp) of the stream item description **type** func **return** Returns the pts of the stream. **static** False > C++ defination code: > ```cpp > size_t pts() > ``` ### Frame {#Frame} Frame class, saved the image data > C++ defination code: > ```cpp > class Frame > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, frame: capsule, auto_delete: bool False, from: str '') > None ``` Construct a new Frame object item description **type** func **param** **frame**: frame handle<br>**auto_delete**: auto delete frame when object is destroyed<br>**from**: When releasing the object, the 'from' parameter will be referenced to determine the release method.<br> **static** False > C++ defination code: > ```cpp > Frame(void *frame, bool auto_delete false, std::string from \"\") > ``` #### width {#width} ```python def width(self) > int ``` Get the width of the frame item description **type** func **return** Returns the width of the frame. **static** False > C++ defination code: > ```cpp > int width() > ``` #### height {#height} ```python def height(self) > int ``` Get the height of the frame item description **type** func **return** Returns the height of the frame. **static** False > C++ defination code: > ```cpp > int height() > ``` #### format {#format} ```python def format(self) > maix.image.Format ``` Get the format of the frame item description **type** func **return** Returns the format of the frame. **static** False > C++ defination code: > ```cpp > image::Format format() > ``` #### to\\_image {#to\\_image} ```python def to_image(self) > maix.image.Image ``` Convert the frame to an image item description **type** func **return** Returns an image object. **static** False > C++ defination code: > ```cpp > image::Image *to_image() > ``` #### stride {#stride} ```python def stride(self, idx: int) > int ``` Get the stride of the plane. Stride represents the number of bytes occupied in memory by each row of image data.\\nIt is usually greater than or equal to the number of bytes actually used by the pixels in that row.\\nIn image processing, different image formats are divided into multiple planes.\\nTypically, RGB images have only one valid plane, while NV21/NV12 images have two valid planes. item description **type** func **param** **idx**: plane index.<br> **return** Returns the stride of the frame. **static** False > C++ defination code: > ```cpp > int stride(int idx) > ``` #### virtual\\_address {#virtual\\_address} ```python def virtual_address(self, idx: int) > int ``` Get the virtual address of the plane. In image processing, different image formats are divided into multiple planes.\\nTypically, RGB images have only one valid plane, while NV21/NV12 images have two valid planes. item description **type** func **note** You can read image data from this address, but you need to be very careful.<br>If the current object has been released, operating on this address is prohibited. **param** **idx**: plane index.<br> **return** Returns the virtual address of the frame. **static** False > C++ defination code: > ```cpp > uint64_t virtual_address(int idx) > ``` #### physical\\_address {#physical\\_address} ```python def physical_address(self, idx: int) > int ``` Get the physical address of the plane. In image processing, different image formats are divided into multiple planes.\\nTypically, RGB images have only one valid plane, while NV21/NV12 images have two valid planes. item description **type** func **note** Don’t operate on this address. **param** **idx**: plane index.<br> **return** Returns the physical address of the frame. **static** False > C++ defination code: > ```cpp > uint64_t physical_address(int idx) > ```"},"/maixpy/api/maix/video.html":{"title":"maix.video","content":" title: maix.video maix.video module > You can use `maix.video` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### VideoType {#VideoType} Video type item describe **values** **VIDEO_NONE**: format invalid<br>**VIDEO_ENC_H265_CBR**: Deprecated<br>**VIDEO_ENC_MP4_CBR**: Deprecated<br>**VIDEO_DEC_H265_CBR**: Deprecated<br>**VIDEO_DEC_MP4_CBR**: Deprecated<br>**VIDEO_H264_CBR**: Deprecated<br>**VIDEO_H265_CBR**: Deprecated<br>**VIDEO_H264_CBR_MP4**: Deprecated<br>**VIDEO_H265_CBR_MP4**: Deprecated<br>**VIDEO_H264**: <br>**VIDEO_H264_MP4**: <br>**VIDEO_H264_FLV**: <br>**VIDEO_H265**: <br>**VIDEO_H265_MP4**: <br> > C++ defination code: > ```cpp > enum VideoType > { > VIDEO_NONE 0, // format invalid > VIDEO_ENC_H265_CBR, // Deprecated > VIDEO_ENC_MP4_CBR, // Deprecated > VIDEO_DEC_H265_CBR, // Deprecated > VIDEO_DEC_MP4_CBR, // Deprecated > VIDEO_H264_CBR, // Deprecated > VIDEO_H265_CBR, // Deprecated > VIDEO_H264_CBR_MP4, // Deprecated > VIDEO_H265_CBR_MP4, // Deprecated > > VIDEO_H264, > VIDEO_H264_MP4, > VIDEO_H264_FLV, > VIDEO_H265, > VIDEO_H265_MP4, > } > ``` ### MediaType {#MediaType} Video type item describe **values** **MEDIA_TYPE_UNKNOWN**: Represents an unknown media type, which is usually treated as AVMEDIA_TYPE_DATA.<br>**MEDIA_TYPE_VIDEO**: Represents a video stream, such as video content encoded in H.264, MPEG 4, etc.<br>**MEDIA_TYPE_AUDIO**: Represents an audio stream, such as audio content encoded in AAC, MP3, etc.<br>**MEDIA_TYPE_DATA**: Represents opaque data streams that are usually continuous. This type of stream is not necessarily audio or video and may be used for other data purposes.<br>**MEDIA_TYPE_SUBTITLE**: Represents a subtitle stream used for displaying text or subtitle information, such as SRT, ASS, etc.<br>**MEDIA_TYPE_ATTACHMENT**: Represents attachment streams that are usually sparse. Attachment streams can include images, fonts, or other files that need to be bundled with the media.<br>**MEDIA_TYPE_NB**: Represents the number of media types (count) and indicates the total number of media types defined in this enumeration. It is not a media type itself but is used for counting enumeration items.<br> > C++ defination code: > ```cpp > enum MediaType > { > MEDIA_TYPE_UNKNOWN 1, // Represents an unknown media type, which is usually treated as AVMEDIA_TYPE_DATA. > MEDIA_TYPE_VIDEO, // Represents a video stream, such as video content encoded in H.264, MPEG 4, etc. > MEDIA_TYPE_AUDIO, // Represents an audio stream, such as audio content encoded in AAC, MP3, etc. > MEDIA_TYPE_DATA, // Represents opaque data streams that are usually continuous. This type of stream is not necessarily audio or video and may be used for other data purposes. > MEDIA_TYPE_SUBTITLE, // Represents a subtitle stream used for displaying text or subtitle information, such as SRT, ASS, etc. > MEDIA_TYPE_ATTACHMENT, // Represents attachment streams that are usually sparse. Attachment streams can include images, fonts, or other files that need to be bundled with the media. > MEDIA_TYPE_NB // Represents the number of media types (count) and indicates the total number of media types defined in this enumeration. It is not a media type itself but is used for counting enumeration items. > } > ``` ## Variable {#Variable} ## Function {#Function} ### timebase\\_to\\_us {#timebase\\_to\\_us} ```python def timebase_to_us(timebase: list[int], value: int) > float ``` Convert a value in timebase units to microseconds. value * 1000000 / (timebase[1] / timebase[0]) item description **param** **timebse**: Time base, used as the unit for calculating playback time. It must be an array containing two parameters,<br>in the format [num, den], where the first parameter is the numerator of the time base, and the second parameter is the denominator of the time base.<br>**value**: Input value<br> **return** Return the result in microseconds. > C++ defination code: > ```cpp > double timebase_to_us(std::vector<int> timebase, uint64_t value) > ``` ### timebase\\_to\\_ms {#timebase\\_to\\_ms} ```python def timebase_to_ms(timebase: list[int], value: int) > float ``` Convert a value in timebase units to milliseconds. item description **param** **timebse**: Time base, used as the unit for calculating playback time. It must be an array containing two parameters,<br>in the format [num, den], where the first parameter is the numerator of the time base, and the second parameter is the denominator of the time base.<br>**value**: Input value<br> **return** Return the result in milliseconds. > C++ defination code: > ```cpp > double timebase_to_ms(std::vector<int> timebase, uint64_t value) > ``` ## Class {#Class} ### Context {#Context} Context class > C++ defination code: > ```cpp > class Context > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, media_type: MediaType, timebase: list[int]) > None ``` Construct a new Context object item description **type** func **param** **media_type**: enable capture, if true, you can use capture() function to get an image object<br>**timebase**: Time base, used as the unit for calculating playback time. It must be an array containing two parameters,<br>in the format [num, den], where the first parameter is the numerator of the time base, and the second parameter is the denominator of the time base.<br> **static** False > C++ defination code: > ```cpp > Context(video::MediaType media_type, std::vector<int> timebase) > ``` #### audio\\_sample\\_rate {#audio\\_sample\\_rate} ```python def audio_sample_rate(self) > int ``` Get sample rate of audio (only valid in the context of audio) item description **type** func **return** sample rate **static** False > C++ defination code: > ```cpp > int audio_sample_rate() > ``` #### audio\\_channels {#audio\\_channels} ```python def audio_channels(self) > int ``` Get channels of audio (only valid in the context of audio) item description **type** func **return** channels **static** False > C++ defination code: > ```cpp > int audio_channels() > ``` #### audio\\_format {#audio\\_format} ```python def audio_format(self) > maix.audio.Format ``` Get format of audio (only valid in the context of audio) item description **type** func **return** audio format. @see audio::Format **static** False > C++ defination code: > ```cpp > audio::Format audio_format() > ``` #### set\\_pcm {#set\\_pcm} ```python def set_pcm(self, data: maix.Bytes(bytes), duration: int 0, pts: int 0, copy: bool True) > maix.err.Err ``` Set pcm data (only valid in the context of audio) item description **type** func **param** **duration**: Duration of the current pcm. unit: timebase<br>**pts**: The start time of this pcm playback. If it is 0, it means this parameter is not supported. unit: timebase<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err set_pcm(maix::Bytes *data, int duration 0, uint64_t pts 0, bool copy true) > ``` #### get\\_pcm {#get\\_pcm} ```python def get_pcm(*args, **kwargs) ``` Get pcm data (only valid in the context of audio) item description **type** func **attention** Note that if you call this interface, you are responsible for releasing the memory of the data, and this interface cannot be called again. **return** Bytes **static** False > C++ defination code: > ```cpp > Bytes *get_pcm() > ``` #### image {#image} ```python def image(self) > maix.image.Image ``` Retrieve the image data to be played. item description **type** func **attention** Note that if you call this interface, you are responsible for releasing the memory of the image, and this interface cannot be called again. **static** False > C++ defination code: > ```cpp > image::Image *image() > ``` #### media\\_type {#media\\_type} ```python def media_type(self) > MediaType ``` Get the media type to determine whether it is video, audio, or another media type. item description **type** func **static** False > C++ defination code: > ```cpp > video::MediaType media_type() > ``` #### pts {#pts} ```python def pts(self) > int ``` Get the start time of the current playback., in units of time base. item description **type** func **static** False > C++ defination code: > ```cpp > uint64_t pts() > ``` #### last\\_pts {#last\\_pts} ```python def last_pts(self) > int ``` Get the start time of the previous playback, in units of time base. item description **type** func **static** False > C++ defination code: > ```cpp > uint64_t last_pts() > ``` #### timebase {#timebase} ```python def timebase(self) > list[int] ``` Get the time base. item description **type** func **static** False > C++ defination code: > ```cpp > std::vector<int> timebase() > ``` #### duration {#duration} ```python def duration(self) > int ``` Duration of the current frame. unit: timebase item description **type** func **static** False > C++ defination code: > ```cpp > int duration() > ``` #### duration\\_us {#duration\\_us} ```python def duration_us(self) > int ``` Duration of the current frame. unit: us item description **type** func **static** False > C++ defination code: > ```cpp > uint64_t duration_us() > ``` ### Frame {#Frame} Frame class > C++ defination code: > ```cpp > class Frame > ``` #### to\\_bytes {#to\\_bytes} ```python def to_bytes(*args, **kwargs) ``` Get raw data of packet item description **type** func **param** **copy**: if true, will alloc memory and copy data to new buffer<br> **return** raw data **static** False > C++ defination code: > ```cpp > Bytes *to_bytes(bool copy false) > ``` #### size {#size} ```python def size(self) > int ``` Get raw data size of packet item description **type** func **return** size of raw data **static** False > C++ defination code: > ```cpp > size_t size() > ``` #### is\\_valid {#is\\_valid} ```python def is_valid(self) > bool ``` Check packet is valid item description **type** func **return** true, packet is valid; false, packet is invalid **static** False > C++ defination code: > ```cpp > bool is_valid() > ``` #### set\\_pts {#set\\_pts} ```python def set_pts(self, pts: int) > None ``` Set pts item description **type** func **param** **pts**: presentation time stamp. unit: time_base<br> **static** False > C++ defination code: > ```cpp > void set_pts(uint64_t pts) > ``` #### set\\_dts {#set\\_dts} ```python def set_dts(self, dts: int) > None ``` Set dts item description **type** func **param** **dts**: decoding time stamp. unit: time_base<br> **static** False > C++ defination code: > ```cpp > void set_dts(uint64_t dts) > ``` #### set\\_duration {#set\\_duration} ```python def set_duration(self, duration: int) > None ``` Set duration item description **type** func **param** **duration**: packet display time. unit: time_base<br> **static** False > C++ defination code: > ```cpp > void set_duration(uint64_t duration) > ``` #### get\\_pts {#get\\_pts} ```python def get_pts(self) > int ``` Set pts item description **type** func **param** **pts**: presentation time stamp. unit: time_base<br> **return** pts value **static** False > C++ defination code: > ```cpp > uint64_t get_pts() > ``` #### get\\_dts {#get\\_dts} ```python def get_dts(self) > int ``` Set dts item description **type** func **param** **dts**: decoding time stamp. unit: time_base<br> **return** dts value **static** False > C++ defination code: > ```cpp > uint64_t get_dts() > ``` #### get\\_duration {#get\\_duration} ```python def get_duration(self) > int ``` Get duration item description **type** func **return** duration value **static** False > C++ defination code: > ```cpp > uint64_t get_duration() > ``` #### type {#type} ```python def type(self) > VideoType ``` Get frame type item description **type** func **return** video type. @see video::VideoType **static** False > C++ defination code: > ```cpp > video::VideoType type() > ``` ### Packet {#Packet} Packet class > C++ defination code: > ```cpp > class Packet > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 2} ```python def __init__(self, data: int, len: int, pts: int 1, dts: int 1, duration: int 0) > None ``` Packet number (pair of numerator and denominator). item description **type** func **param** **data**: src data pointer, use pointers directly without copying.<br>Note: this object will try to free this memory<br>**len**: data len<br>**pts**: presentation time stamp. unit: time_base<br>**dts**: decoding time stamp. unit: time_base<br>**duration**: packet display time. unit: time_base<br> **static** False > C++ defination code: > ```cpp > Packet(uint8_t *data, int len, uint64_t pts 1, uint64_t dts 1, int64_t duration 0) > ``` #### get {#get} ```python def get(self) > list[int] ``` Get raw data of packet item description **type** func **return** raw data **static** False > C++ defination code: > ```cpp > std::vector<uint8_t> get() > ``` #### data {#data} ```python def data(self) > int ``` Get raw data of packet item description **type** func **return** raw data **static** False > C++ defination code: > ```cpp > uint8_t *data() > ``` #### data\\_size {#data\\_size} ```python def data_size(self) > int ``` Get raw data size of packet item description **type** func **return** size of raw data **static** False > C++ defination code: > ```cpp > size_t data_size() > ``` #### is\\_valid {#is\\_valid 2} ```python def is_valid(self) > bool ``` Check packet is valid item description **type** func **return** true, packet is valid; false, packet is invalid **static** False > C++ defination code: > ```cpp > bool is_valid() > ``` #### set\\_pts {#set\\_pts 2} ```python def set_pts(self, pts: int) > None ``` Set pts item description **type** func **param** **pts**: presentation time stamp. unit: time_base<br> **return** true, packet is valid; false, packet is invalid **static** False > C++ defination code: > ```cpp > void set_pts(uint64_t pts) > ``` #### set\\_dts {#set\\_dts 2} ```python def set_dts(self, dts: int) > None ``` Set dts item description **type** func **param** **dts**: decoding time stamp. unit: time_base<br> **return** true, packet is valid; false, packet is invalid **static** False > C++ defination code: > ```cpp > void set_dts(uint64_t dts) > ``` #### set\\_duration {#set\\_duration 2} ```python def set_duration(self, duration: int) > None ``` Set duration item description **type** func **param** **duration**: packet display time. unit: time_base<br> **return** true, packet is valid; false, packet is invalid **static** False > C++ defination code: > ```cpp > void set_duration(uint64_t duration) > ``` ### Encoder {#Encoder} Encode class > C++ defination code: > ```cpp > class Encoder > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 3} ```python def __init__(self, path: str '', width: int 2560, height: int 1440, format: maix.image.Format ..., type: VideoType ..., framerate: int 30, gop: int 50, bitrate: int 3000000, time_base: int 1000, capture: bool False, block: bool True) > None ``` Construct a new Video object item description **type** func **param** **width**: picture width. this value may be set automatically. default is 2560.<br>**height**: picture height. this value may be set automatically. default is 1440.<br>**format**: picture format. default is image::Format::FMT_YVU420SP. @see image::Format<br>**type**: video encode/decode type. default is ENC_H265_CBR. @see EncodeType<br>**framerate**: frame rate. framerate default is 30, means 30 frames per second<br>for video. 1/time_base is not the average frame rate if the frame rate is not constant.<br>**gop**: for h264/h265 encoding, the interval between two I frames, default is 50.<br>**bitrate**: for h264/h265 encoding, used to limit the bandwidth used by compressed data, default is 3000kbps<br>**time_base**: frame time base. time_base default is 1000, means 1/1000 ms (not used)<br>**capture**: enable capture, if true, you can use capture() function to get an image object<br>**block**: This parameter determines whether encoding should block until it is complete.<br>If set to true, it will wait until encoding is finished before returning.<br>If set to false, it will return the current encoding result on the next call.<br> **static** False > C++ defination code: > ```cpp > Encoder(std::string path \"\", int width 2560, int height 1440, image::Format format image::Format::FMT_YVU420SP, video::VideoType type video::VideoType::VIDEO_H264, int framerate 30, int gop 50, int bitrate 3000 * 1000, int time_base 1000, bool capture false, bool block true) > ``` #### bind\\_camera {#bind\\_camera} ```python def bind_camera(self, camera: maix.camera.Camera) > maix.err.Err ``` Bind camera item description **type** func **param** **camera**: camera object<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err bind_camera(camera::Camera *camera) > ``` #### encode {#encode} ```python def encode(self, img: maix.image.Image ..., pcm: maix.Bytes(bytes) b'') > Frame ``` Encode image. item description **type** func **param** **img**: the image will be encode.<br>if the img is NULL, this function will try to get image from camera, you must use bind_camera() function to bind the camera.<br>**pcm**: the pcm data will be encode.<br> **return** encode result **static** False > C++ defination code: > ```cpp > video::Frame *encode(image::Image *img maix::video::Encoder::NoneImage, Bytes *pcm maix::video::Encoder::NoneBytes) > ``` #### push {#push} ```python def push(self, frame: ...) > maix.err.Err ``` Push a pipeline frame to encoder. item description **type** func **param** **frame**: the frame will be push.<br> **return** push result **static** False > C++ defination code: > ```cpp > err::Err push(pipeline::Frame *frame) > ``` #### pop {#pop} ```python def pop(self, block_ms: int 1000) > ... ``` Pop a frame from encoder. item description **type** func **note** If encoder buffer is empty, it will return null. **param** **block_ms**: block read, if block_ms 1, block indefinitely until an image is read; if block_ms 0, do not block and return immediately<br> **return** pop result. @see pipeline::Stream **static** False > C++ defination code: > ```cpp > pipeline::Stream *pop(int block_ms 1000) > ``` #### capture {#capture} ```python def capture(self) > maix.image.Image ``` Capture image item description **type** func **attention** Each time encode is called, the last captured image will be released. **return** error code **static** False > C++ defination code: > ```cpp > image::Image *capture() > ``` #### width {#width} ```python def width(self) > int ``` Get video width item description **type** func **return** video width **static** False > C++ defination code: > ```cpp > int width() > ``` #### height {#height} ```python def height(self) > int ``` Get video height item description **type** func **return** video height **static** False > C++ defination code: > ```cpp > int height() > ``` #### format {#format} ```python def format(self) > maix.image.Format ``` Get video format item description **type** func **return** video format **static** False > C++ defination code: > ```cpp > image::Format format() > ``` #### type {#type 2} ```python def type(self) > VideoType ``` Get video encode type item description **type** func **return** VideoType **static** False > C++ defination code: > ```cpp > video::VideoType type() > ``` #### framerate {#framerate} ```python def framerate(self) > int ``` Get video encode framerate item description **type** func **return** frame rate **static** False > C++ defination code: > ```cpp > int framerate() > ``` #### gop {#gop} ```python def gop(self) > int ``` Get video encode gop item description **type** func **return** gop value **static** False > C++ defination code: > ```cpp > int gop() > ``` #### bitrate {#bitrate} ```python def bitrate(self) > int ``` Get video encode bitrate item description **type** func **return** bitrate value **static** False > C++ defination code: > ```cpp > int bitrate() > ``` #### time\\_base {#time\\_base} ```python def time_base(self) > int ``` Get video encode time base item description **type** func **return** time base value **static** False > C++ defination code: > ```cpp > int time_base() > ``` ### Decoder {#Decoder} Decoder class > C++ defination code: > ```cpp > class Decoder > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 4} ```python def __init__(self, path: str, format: maix.image.Format ...) > None ``` Construct a new decoder object item description **type** func **param** **path**: Path to the file to be decoded. Supports files with .264 and .mp4 extensions. Note that only mp4 files containing h.264 streams are supported.<br>**format**: Decoded output format, currently only support GRAYSCALE and YUV420SP<br> **static** False > C++ defination code: > ```cpp > Decoder(std::string path, image::Format format image::Format::FMT_YVU420SP) > ``` #### decode\\_video {#decode\\_video} ```python def decode_video(self, block: bool True) > Context ``` Decode the video stream, returning the image of the next frame each time. item description **type** func **param** **block**: Whether it blocks or not. If true, it will wait for the decoding to complete and return the current frame.<br>If false, it will return the result of the previous frame's decoding. If the previous frame's decoding result is empty,<br>it will return an unknown Context, and you can use the media_type method of the Context to determine if a valid result exists.<br>default is true.<br> **return** Decoded context information. **static** False > C++ defination code: > ```cpp > video::Context * decode_video(bool block true) > ``` #### decode\\_audio {#decode\\_audio} ```python def decode_audio(self) > Context ``` Decode the video stream, returning the image of the next frame each time. item description **type** func **return** Decoded context information. **static** False > C++ defination code: > ```cpp > video::Context * decode_audio() > ``` #### decode {#decode} ```python def decode(self, block: bool True) > Context ``` Decode the video and audio stream item description **type** func **param** **block**: Whether it blocks or not. If true, it will wait for the decoding to complete and return the current frame.<br>If false, it will return the result of the previous frame's decoding. If the previous frame's decoding result is empty,<br>it will return an unknown Context, and you can use the media_type method of the Context to determine if a valid result exists.<br>default is true.<br> **return** Decoded context information. **static** False > C++ defination code: > ```cpp > video::Context * decode(bool block true) > ``` #### push {#push 2} ```python def push(self, stream: ...) > maix.err.Err ``` Push a pipeline frame to encoder. item description **type** func **param** **stream**: the frame will be push.<br> **return** push result **static** False > C++ defination code: > ```cpp > err::Err push(pipeline::Stream *stream) > ``` #### pop {#pop 2} ```python def pop(self, block_ms: int 1000) > ... ``` Pop a frame from encoder. item description **type** func **note** If encoder buffer is empty, it will return null. **param** **block_ms**: block read, if block_ms 1, block indefinitely until an image is read; if block_ms 0, do not block and return immediately<br> **return** pop result. @see pipeline::Frame **static** False > C++ defination code: > ```cpp > pipeline::Frame *pop(int block_ms 1000) > ``` #### audio\\_sample\\_rate {#audio\\_sample\\_rate 2} ```python def audio_sample_rate(self) > int ``` Get sample rate of audio (only valid in the context of audio) item description **type** func **return** sample rate **static** False > C++ defination code: > ```cpp > int audio_sample_rate() > ``` #### audio\\_channels {#audio\\_channels 2} ```python def audio_channels(self) > int ``` Get channels of audio (only valid in the context of audio) item description **type** func **return** channels **static** False > C++ defination code: > ```cpp > int audio_channels() > ``` #### audio\\_format {#audio\\_format 2} ```python def audio_format(self) > maix.audio.Format ``` Get format of audio (only valid in the context of audio) item description **type** func **return** audio format. @see audio::Format **static** False > C++ defination code: > ```cpp > audio::Format audio_format() > ``` #### width {#width 2} ```python def width(self) > int ``` Get the video width item description **type** func **return** video width **static** False > C++ defination code: > ```cpp > int width() > ``` #### height {#height 2} ```python def height(self) > int ``` Get the video height item description **type** func **return** video height **static** False > C++ defination code: > ```cpp > int height() > ``` #### bitrate {#bitrate 2} ```python def bitrate(self) > int ``` Get the video bitrate item description **type** func **return** bitrate value **static** False > C++ defination code: > ```cpp > int bitrate() > ``` #### fps {#fps} ```python def fps(self) > int ``` Get the video fps item description **type** func **return** fps value **static** False > C++ defination code: > ```cpp > int fps() > ``` #### seek {#seek} ```python def seek(self, time: float 1) > float ``` Seek to the required playback position item description **type** func **param** **time**: timestamp value, unit: s<br> **return** return the current position, unit: s **static** False > C++ defination code: > ```cpp > double seek(double time 1) > ``` #### duration {#duration 2} ```python def duration(self) > float ``` Get the maximum duration of the video. If it returns 0, it means it cannot be predicted. item description **type** func **return** duration value, unit: s **static** False > C++ defination code: > ```cpp > double duration() > ``` #### timebase {#timebase 2} ```python def timebase(self) > list[int] ``` Get the time base. item description **type** func **static** False > C++ defination code: > ```cpp > std::vector<int> timebase() > ``` #### has\\_audio {#has\\_audio} ```python def has_audio(self) > bool ``` If find audio data, return true item description **type** func **static** False > C++ defination code: > ```cpp > bool has_audio() > ``` #### has\\_video {#has\\_video} ```python def has_video(self) > bool ``` If find video data, return true item description **type** func **static** False > C++ defination code: > ```cpp > bool has_video() > ``` ### Video {#Video} Video class > C++ defination code: > ```cpp > class Video > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 5} ```python def __init__(self, path: str '', width: int 2560, height: int 1440, format: maix.image.Format ..., time_base: int 30, framerate: int 30, capture: bool False, open: bool True) > None ``` Construct a new Video object item description **type** func **param** **path**: video path. the path determines the location where you load or save the file, if path is none, the video module will not save or load file.<br>xxx.h265 means video format is H265, xxx.mp4 means video format is MP4<br>**width**: picture width. this value may be set automatically. default is 2560.<br>**height**: picture height. this value may be set automatically. default is 1440.<br>**format**: picture pixel format. this value may be set automatically. default is FMT_YVU420SP.<br>**time_base**: frame time base. time_base default is 30, means 1/30 ms<br>**framerate**: frame rate. framerate default is 30, means 30 frames per second<br>for video. 1/time_base is not the average frame rate if the frame rate is not constant.<br>**capture**: enable capture, if true, you can use capture() function to get an image object<br>**open**: If true, video will automatically call open() after creation. default is true.<br> **static** False > C++ defination code: > ```cpp > Video(std::string path std::string(), int width 2560, int height 1440, image::Format format image::Format::FMT_YVU420SP, int time_base 30, int framerate 30, bool capture false, bool open true) > ``` #### open {#open} ```python def open(self, path: str '', fps: float 30.0) > maix.err.Err ``` Open video and run item description **type** func **param** **path**: video path. the path determines the location where you load or save the file, if path is none, the video module will not save or load file.<br>xxx.h265 means video format is H265, xxx.mp4 means video format is MP4<br>**fps**: video fps<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err open(std::string path std::string(), double fps 30.0) > ``` #### close {#close} ```python def close(self) > None ``` Close video item description **type** func **static** False > C++ defination code: > ```cpp > void close() > ``` #### bind\\_camera {#bind\\_camera 2} ```python def bind_camera(self, camera: maix.camera.Camera) > maix.err.Err ``` Bind camera item description **type** func **param** **camera**: camera object<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err bind_camera(camera::Camera *camera) > ``` #### encode {#encode 2} ```python def encode(self, img: maix.image.Image ...) > Packet ``` Encode image. item description **type** func **param** **img**: the image will be encode.<br>if the img is NULL, this function will try to get image from camera, you must use bind_camera() function to bind the camera.<br> **return** encode result **static** False > C++ defination code: > ```cpp > video::Packet *encode(image::Image *img maix::video::Video::NoneImage) > ``` #### decode {#decode 2} ```python def decode(self, frame: Frame None) > maix.image.Image ``` Decode frame item description **type** func **param** **frame**: the frame will be decode<br> **return** decode result **static** False > C++ defination code: > ```cpp > image::Image *decode(video::Frame *frame nullptr) > ``` #### finish {#finish} ```python def finish(self) > maix.err.Err ``` Encode or decode finish item description **type** func **return** error code **static** False > C++ defination code: > ```cpp > err::Err finish() > ``` #### capture {#capture 2} ```python def capture(self) > maix.image.Image ``` Capture image item description **type** func **attention** Each time encode is called, the last captured image will be released. **return** error code **static** False > C++ defination code: > ```cpp > image::Image *capture() > ``` #### is\\_recording {#is\\_recording} ```python def is_recording(self) > bool ``` Check if video is recording item description **type** func **return** true if video is recording, false if not **static** False > C++ defination code: > ```cpp > bool is_recording() > ``` #### is\\_opened {#is\\_opened} ```python def is_opened(self) > bool ``` Check if video is opened item description **type** func **return** true if video is opened, false if not **static** False > C++ defination code: > ```cpp > bool is_opened() > ``` #### is\\_closed {#is\\_closed} ```python def is_closed(self) > bool ``` check video device is closed or not item description **type** func **return** closed or not, bool type **static** False > C++ defination code: > ```cpp > bool is_closed() > ``` #### width {#width 3} ```python def width(self) > int ``` Get video width item description **type** func **return** video width **static** False > C++ defination code: > ```cpp > int width() > ``` #### height {#height 3} ```python def height(self) > int ``` Get video height item description **type** func **return** video height **static** False > C++ defination code: > ```cpp > int height() > ``` ### VideoRecorder {#VideoRecorder} Video Recorder class. This module is not fully supported and may be deprecated in the future. You can use the camera, encoder, and audio modules to achieve similar functionality. > C++ defination code: > ```cpp > class VideoRecorder > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 6} ```python def __init__(self, open: bool True) > None ``` Construct a new VideoRecorder object. This is an object that integrates recording, video capturing, and display functions, which can be used to achieve high resolution video input when needed. item description **type** func **param** **open**: If true, video will automatically call open() after creation. default is true.<br> **static** False > C++ defination code: > ```cpp > VideoRecorder(bool open true) > ``` #### lock {#lock} ```python def lock(self, timeout: int 1) > maix.err.Err ``` lock video item description **type** func **param** **timeout**: timeout in ms. unit:ms<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err lock(int64_t timeout 1) > ``` #### unlock {#unlock} ```python def unlock(self) > maix.err.Err ``` unlock video item description **type** func **return** error code **static** False > C++ defination code: > ```cpp > err::Err unlock() > ``` #### open {#open 2} ```python def open(self) > maix.err.Err ``` Start a thread to handle the input function. item description **type** func **return** error code **static** False > C++ defination code: > ```cpp > err::Err open() > ``` #### close {#close 2} ```python def close(self) > maix.err.Err ``` Stop the thread, and reset the object. item description **type** func **return** error code **static** False > C++ defination code: > ```cpp > err::Err close() > ``` #### is\\_opened {#is\\_opened 2} ```python def is_opened(self) > bool ``` Check whether the object is opened. item description **type** func **static** False > C++ defination code: > ```cpp > bool is_opened() > ``` #### bind\\_display {#bind\\_display} ```python def bind_display(self, display: maix.display.Display, fit: maix.image.Fit ...) > maix.err.Err ``` Bind a Display object. if this object is not bound, it will not be displayed. item description **type** func **param** **display**: display object<br>**fit**: fit mode. It is recommended to fill in FIT_COVER or FIT_FILL. For maixcam, using FIT_CONTAIN may affect the<br>functionality of the second layer created by add_channel() in the Display. default is FIT_COVER.<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err bind_display(display::Display *display, image::Fit fit image::FIT_COVER) > ``` #### bind\\_camera {#bind\\_camera 3} ```python def bind_camera(self, camera: maix.camera.Camera) > maix.err.Err ``` Bind a Camera object. if this object is not bound, images cannot be captured. item description **type** func **param** **camera**: camera object<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err bind_camera(camera::Camera *camera) > ``` #### bind\\_audio {#bind\\_audio} ```python def bind_audio(self, audio: maix.audio.Recorder) > maix.err.Err ``` Bind a AudioRecorder object. if this object is not bound, audio cannot be captured. item description **type** func **param** **audio**: audio recorder object<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err bind_audio(audio::Recorder *audio) > ``` #### bind\\_imu {#bind\\_imu} ```python def bind_imu(self, imu: capsule) > maix.err.Err ``` Bind a IMU object. if this object is not bound, imu data cannot be captured. item description **type** func **param** **imu**: imu object<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err bind_imu(void *imu) > ``` #### reset {#reset} ```python def reset(self) > maix.err.Err ``` Reset the video recorder. item description **type** func **note** It will not reset the bound object; if you have already bound the display using bind_display(), there is no need to rebind the display after calling reset(). **return** error code **static** False > C++ defination code: > ```cpp > err::Err reset() > ``` #### config\\_path {#config\\_path} ```python def config_path(self, path: str) > maix.err.Err ``` The recorded video will be saved to this path, and this API cannot be called during runtime. item description **type** func **param** **path**: The path of the video file to be saved<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err config_path(std::string path) > ``` #### get\\_path {#get\\_path} ```python def get_path(self) > str ``` Get the path of the video file to be saved item description **type** func **return** path **static** False > C++ defination code: > ```cpp > std::string get_path() > ``` #### config\\_snapshot {#config\\_snapshot} ```python def config_snapshot(self, enable: bool, resolution: list[int] [], format: maix.image.Format ...) > maix.err.Err ``` Set the snapshot parameters item description **type** func **note** Enabling snapshot functionality may result in some performance loss. **param** **enable**: enable or disable snapshot<br>**resolution**: image resolution of snapshot<br>**format**: image format of snapshot<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err config_snapshot(bool enable, std::vector<int> resolution std::vector<int>(), image::Format format image::Format::FMT_YVU420SP) > ``` #### config\\_resolution {#config\\_resolution} ```python def config_resolution(self, resolution: list[int]) > maix.err.Err ``` Set the resolution of the video, and this API cannot be called during runtime. item description **type** func **note** You must bind the camera first, and this interface will modify the camera's resolution. The width must be divisible by 32. **param** **resolution**: The resolution of the video<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err config_resolution(std::vector<int> resolution) > ``` #### get\\_resolution {#get\\_resolution} ```python def get_resolution(self) > list[int] ``` Get the resolution of the video item description **type** func **return** the resolution of the video **static** False > C++ defination code: > ```cpp > std::vector<int> get_resolution() > ``` #### config\\_fps {#config\\_fps} ```python def config_fps(self, fps: int) > maix.err.Err ``` Set the fps of the video, and this API cannot be called during runtime. item description **type** func **note** This interface only affect the fps of the encoded file. **return** error code **static** False > C++ defination code: > ```cpp > err::Err config_fps(int fps) > ``` #### get\\_fps {#get\\_fps} ```python def get_fps(self) > int ``` Get the fps of the video. item description **type** func **return** fps value **static** False > C++ defination code: > ```cpp > int get_fps() > ``` #### config\\_bitrate {#config\\_bitrate} ```python def config_bitrate(self, bitrate: int) > maix.err.Err ``` Set the bitrate of the video, and this API cannot be called during runtime. item description **type** func **return** error code **static** False > C++ defination code: > ```cpp > err::Err config_bitrate(int bitrate) > ``` #### get\\_bitrate {#get\\_bitrate} ```python def get_bitrate(self) > int ``` Get the bitrate of the video. item description **type** func **return** bitrate value **static** False > C++ defination code: > ```cpp > int get_bitrate() > ``` #### mute {#mute} ```python def mute(self, data: int 1) > int ``` Set/Get the mute of the video item description **type** func **param** **data**: If the parameter is true, mute; if false, unmute; if no parameter is provided, return the mute status.<br> **return** error code **static** False > C++ defination code: > ```cpp > int mute(int data 1) > ``` #### volume {#volume} ```python def volume(self, data: int 1) > int ``` Set/Get the volume of the video item description **type** func **param** **data**: The volume of the video, the range is 0 100. if no parameter is provided, return the volume.<br> **return** error code **static** False > C++ defination code: > ```cpp > int volume(int data 1) > ``` #### seek {#seek 2} ```python def seek(self) > int ``` Get the current position of the video item description **type** func **return** current position, unit: ms **static** False > C++ defination code: > ```cpp > int64_t seek() > ``` #### record\\_start {#record\\_start} ```python def record_start(self) > maix.err.Err ``` Start recording item description **type** func **note** You must bind the camera at a minimum during input. Additionally,<br>if you bind a display, the input image will be shown,<br>if you bind a audio, audio will be recorded,<br>if you bind a IMU, IMU data will be logged. **return** error code **static** False > C++ defination code: > ```cpp > err::Err record_start() > ``` #### snapshot {#snapshot} ```python def snapshot(self) > maix.image.Image ``` Take a snapshot item description **type** func **return** image::Image **static** False > C++ defination code: > ```cpp > image::Image *snapshot() > ``` #### record\\_finish {#record\\_finish} ```python def record_finish(self) > maix.err.Err ``` Stop recording and save the video item description **type** func **return** error code **static** False > C++ defination code: > ```cpp > err::Err record_finish() > ``` #### draw\\_rect {#draw\\_rect} ```python def draw_rect(self, id: int, x: int, y: int, w: int, h: int, color: maix.image.Color ..., thickness: int 1, hidden: bool False) > maix.err.Err ``` Draw a rect on the video item description **type** func **param** **id**: id of the rect, range is [0, 15]<br>**x**: x coordinate<br>**y**: y coordinate<br>**w**: width<br>**h**: height<br>**color**: color<br>**tickness**: The line width of the rectangular box; if set to 1, it indicates that the rectangular box will be filled.<br>**hidden**: Hide or show the rectangular box<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err draw_rect(int id, int x, int y, int w, int h, image::Color color image::COLOR_WHITE, int thickness 1, bool hidden false) > ```"},"/maixpy/api/maix/uvc.html":{"title":"maix.uvc","content":" title: maix.uvc maix.uvc module > You can use `maix.uvc` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ## Variable {#Variable} ## Function {#Function} ### helper\\_fill\\_mjpg\\_image {#helper\\_fill\\_mjpg\\_image} ```python def helper_fill_mjpg_image(buf: capsule, size: int, img: maix.image.Image) > int ``` helper_fill_mjpg_image item description **param** **buf**: to be filled<br>**size**: to be set<br>**img**: image::Image<br> **return** int > C++ defination code: > ```cpp > int helper_fill_mjpg_image(void* buf, uint32_t* size, image::Image *img) > ``` ## Class {#Class} ### UvcServer {#UvcServer} UvcServer class > C++ defination code: > ```cpp > class UvcServer > ``` #### set\\_cb {#set\\_cb} ```python def set_cb(self, cb: typing.Callable[[capsule, int], int]) > None ``` set UvcServer's cb item description **type** func **param** **cb**: callback function<br> **return** void **static** False > C++ defination code: > ```cpp > void set_cb(std::function<int(void* buf, uint32_t* size)> cb) > ``` #### run {#run} ```python def run(self) > None ``` run UvcServer item description **type** func **return** void **static** False > C++ defination code: > ```cpp > void run() > ``` #### stop {#stop} ```python def stop(self) > None ``` stop UvcServer item description **type** func **return** void **static** False > C++ defination code: > ```cpp > void stop() > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, cb: typing.Callable[[capsule, int], int] None) > None ``` Construct a new jpeg server object item description **type** func **note** You can get the picture stream through http://host:port/stream, you can also get it through http://ip:port, and you can add personal style through set_html() at this time **static** False > C++ defination code: > ```cpp > UvcServer(std::function<int(void* buf, uint32_t* size)> cb nullptr) > ``` ### UvcStreamer {#UvcStreamer} UvcStreamer class > C++ defination code: > ```cpp > class UvcStreamer > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 2} ```python def __init__(self) > None ``` Construct a new jpeg streamer object item description **type** func **note** You can get the picture stream through http://host:port/stream, you can also get it through http://ip:port, and you can add personal style through set_html() at this time **static** False > C++ defination code: > ```cpp > UvcStreamer() > ``` #### show {#show} ```python def show(self, img: maix.image.Image) > maix.err.Err ``` Write data to uvc item description **type** func **param** **img**: image object<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err show(image::Image *img) > ``` #### use\\_mjpg {#use\\_mjpg} ```python def use_mjpg(self, b: int 1) > None ``` use mjpg on uvc item description **type** func **param** **b**: using mjpg: 0 for NOT, others to use<br> **return** void **static** False > C++ defination code: > ```cpp > void use_mjpg(uint32_t b 1) > ```"},"/maixpy/api/maix/example.html":{"title":"maix.example","content":" title: maix.example example module, this will be maix.example module in MaixPy, maix::example namespace in MaixCDK > You can use `maix.example` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### Kind {#Kind} Example enum(not recommend! See Kind2) item describe **values** **KIND_NONE**: Kind none, value always 0, other enum value will auto increase<br>**KIND_DOG**: Kind dog<br>**KIND_CAT**: Kind cat, value is auto generated according to KING_DOG<br>**KIND_BIRD**: <br>**KIND_MAX**: Max Kind quantity<br>You can get max Kind value by KIND_MAX 1<br> > C++ defination code: > ```cpp > enum Kind > { > KIND_NONE 0, /** Kind none, value always 0, other enum value will auto increase */ > KIND_DOG, /** Kind dog*/ > KIND_CAT, // Kind cat, value is auto generated according to KING_DOG > KIND_BIRD, > KIND_MAX /* Max Kind quantity, > You can get max Kind value by KIND_MAX 1 > */ > } > ``` ### Kind2 {#Kind2} Example enum class(recommend!) item describe **values** **NONE**: Kind none, value always 0, other enum value will auto increase<br>**DOG**: Kind dog<br>**CAT**: Kind cat, value is auto generated according to KING_DOG<br>**BIRD**: <br>**MAX**: Max Kind quantity<br>You can get max Kind value by KIND_MAX 1<br> > C++ defination code: > ```cpp > enum class Kind2 > { > NONE 0, /** Kind none, value always 0, other enum value will auto increase */ > DOG, /** Kind dog*/ > CAT, // Kind cat, value is auto generated according to KING_DOG > BIRD, > MAX /* Max Kind quantity, > You can get max Kind value by KIND_MAX 1 > */ > } > ``` ## Variable {#Variable} ### var1 {#var1} Example module variable item description **attention** It's a copy of this variable in MaixPy,<br>so change it in C++ (e.g. update var in hello function) will not take effect the var inMaixPy.<br>So we add const for this var to avoid this mistake. **value** **\"Sipeed\"** **readonly** True > C++ defination code: > ```cpp > const std::string var1 \"Sipeed\" > ``` ### list\\_var {#list\\_var} Tensor data type size in bytes item description **attention** **1**. DO NOT use C/C++ array directly for python API, the python wrapper not support it.<br>Use std::vector instead.<br>**2**. It's a copy of this variable in MaixPy,<br>so change it in C++ (e.g. update var in hello function) will not take effect the var inMaixPy.<br>So we add const for this var to avoid this mistake.<br> **value** **{<br> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9}** **readonly** True > C++ defination code: > ```cpp > const std::vector<int> list_var { > 0, 1, 2, 3, 4, 5, 6, 7, 8, 9} > ``` ### test\\_var {#test\\_var} Example module variable test_var item description **attention** It's a copy of this variable in MaixPy, so if you change it in C++, it will not take effect in MaixPy.<br>And change it in MaixPy will not take effect in C++ as well !!!<br>If you want to use vars shared between C++ and MaixPy, you can create a class and use its member. **value** **100** **readonly** False > C++ defination code: > ```cpp > int test_var 100 > ``` ## Function {#Function} ### hello {#hello} ```python def hello(name: str) > str ``` say hello to someone item description **param** **name**: direction [in], name of someone, string type<br> **return** string type, content is hello + name > C++ defination code: > ```cpp > std::string hello(std::string name) > ``` ### change\\_arg\\_name {#change\\_arg\\_name} ```python def change_arg_name(e: Example) > Example ``` Change arg name example item description **param** **e**: Example object<br> **return** same as arg > C++ defination code: > ```cpp > example::Example *change_arg_name(example::Example *e) > ``` ### change\\_arg\\_name2 {#change\\_arg\\_name2} ```python def change_arg_name2(e: Example) > None ``` Change arg name example item description **param** **e**: Example object<br> > C++ defination code: > ```cpp > void change_arg_name2(example::Example &e) > ``` ## Class {#Class} ### Test {#Test} Test class > C++ defination code: > ```cpp > class Test > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self) > None ``` Test constructor item description **type** func **static** False > C++ defination code: > ```cpp > Test() > ``` ### Example {#Example} Example class\\nthis class will be export to MaixPy as maix.example.Example > C++ defination code: > ```cpp > class Example > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 2} ```python def __init__(self, name: str, age: int 18, pet: Kind ...) > None ``` Example constructor\\nthis constructor will be export to MaixPy as maix.example.Example.__init__ item description **type** func **param** **name**: direction [in], name of Example, string type<br>**age**: direction [in], age of Example, int type, default is 18, value range is [0, 100]<br> **attention** to make auto generate code work, param Kind should with full namespace name `example::Kind` instead of `Kind`,<br>namespace `maix` can be ignored. **static** False > C++ defination code: > ```cpp > Example(std::string &name, int age 18, example::Kind pet example::KIND_NONE) > ``` #### get\\_name {#get\\_name} ```python def get_name(self) > str ``` get name of Example\\nyou can also get name by property `name`. item description **type** func **return** name of Example, string type **static** False > C++ defination code: > ```cpp > std::string get_name() > ``` #### get\\_age {#get\\_age} ```python def get_age(self) > int ``` get age of Example item description **type** func **return** age of Example, int type, value range is [0, 100] **static** False > C++ defination code: > ```cpp > int get_age() > ``` #### set\\_name {#set\\_name} ```python def set_name(self, name: str) > None ``` set name of Example item description **type** func **param** **name**: name of Example, string type<br> **static** False > C++ defination code: > ```cpp > void set_name(std::string name) > ``` #### set\\_age {#set\\_age} ```python def set_age(self, age: int) > None ``` set age of Example item description **type** func **param** **age**: age of Example, int type, value range is [0, 100]<br> **static** False > C++ defination code: > ```cpp > void set_age(int age) > ``` #### set\\_pet {#set\\_pet} ```python def set_pet(self, pet: Kind) > None ``` Example enum member item description **type** func **attention** **static** False > C++ defination code: > ```cpp > void set_pet(example::Kind pet) > ``` #### get\\_pet {#get\\_pet} ```python def get_pet(self) > Kind ``` Example enum member item description **type** func **static** False > C++ defination code: > ```cpp > example::Kind get_pet() > ``` #### get\\_list {#get\\_list} ```python def get_list(self, in: list[int]) > list[int] ``` get list example item description **type** func **param** **in**: direction [in], input list, items are int type.<br>In MaixPy, you can pass list or tuple to this API<br> **return** list, items are int type, content is [1, 2, 3] + in. Alloc item, del in MaixPy will auto free memory. **static** False > C++ defination code: > ```cpp > std::vector<int> *get_list(std::vector<int> in) > ``` #### get\\_dict {#get\\_dict} ```python def get_dict(self, in: dict[str, int]) > dict[str, int] ``` Example dict API item description **type** func **param** **in**: direction [in], input dict, key is string type, value is int type.<br>In MaixPy, you can pass `dict` to this API<br> **return** dict, key is string type, value is int type, content is {\"a\": 1} + in<br>In MaixPy, return type is `dict` object **static** False > C++ defination code: > ```cpp > std::map<std::string, int> get_dict(std::map<std::string, int> &in) > ``` #### hello {#hello 2} ```python def hello(name: str) > str ``` say hello to someone item description **type** func **param** **name**: name of someone, string type<br> **return** string type, content is Example::hello_str + name **static** True > C++ defination code: > ```cpp > static std::string hello(std::string name) > ``` #### hello\\_bytes {#hello\\_bytes} ```python def hello_bytes(*args, **kwargs) ``` param is bytes example item description **type** func **param** **bytes**: bytes type param<br> **return** bytes type, return value is bytes changed value **static** True > C++ defination code: > ```cpp > static Bytes *hello_bytes(Bytes &bytes) > ``` #### callback {#callback} ```python def callback(cb: typing.Callable[[int, int], int]) > int ``` Callback example item description **type** func **param** **cb**: callback function, param is two int type, return is int type<br> **return** int type, return value is cb's return value. **static** True > C++ defination code: > ```cpp > static int callback(std::function<int(int, int)> cb) > ``` #### callback2 {#callback2} ```python def callback2(cb: typing.Callable[[list[int], int], int]) > int ``` Callback example item description **type** func **param** **cb**: callback function, param is a int list type and int type, return is int type<br> **return** int type, return value is cb's return value. **static** True > C++ defination code: > ```cpp > static int callback2(std::function<int(std::vector<int>, int)> cb) > ``` #### hello\\_dict {#hello\\_dict} ```python def hello_dict(dict: dict[str, int]) > dict[str, int] ``` Dict param example item description **type** func **param** **dict**: dict type param, key is string type, value is int type<br> **static** True > C++ defination code: > ```cpp > static std::map<std::string, int> *hello_dict(std::map<std::string, int> *dict) > ``` #### name {#name} name member of Example item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string name > ``` #### age {#age} age member of Example, value range should be [0, 100] item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int age > ``` #### hello\\_str {#hello\\_str} hello_str member of Example, default value is \\\"hello \\\" item description **type** var **static** True **readonly** False > C++ defination code: > ```cpp > static std::string hello_str > ``` #### var1 {#var1 2} Example module readonly variable item description **type** var **static** False **readonly** True > C++ defination code: > ```cpp > const std::string var1 \"Example.var1\" > ``` #### var2 {#var2} Example module readonly variable item description **type** var **static** False **readonly** True > C++ defination code: > ```cpp > std::string var2 \"Example.var2\" > ``` #### dict\\_test {#dict\\_test} ```python def dict_test() > dict[str, Test] ``` dict_test, return dict type, and element is pointer type(alloc in C++).\\nHere when the returned Tensor object will auto delete by Python GC. item description **type** func **static** True > C++ defination code: > ```cpp > static std::map<std::string, example::Test *> *dict_test() > ```"},"/maixpy/api/maix/network/wifi.html":{"title":"maix.network.wifi","content":" title: maix.network.wifi maix.network.wifi module > You can use `maix.network.wifi` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ## Variable {#Variable} ## Function {#Function} ### list\\_devices {#list\\_devices} ```python def list_devices() > list[str] ``` List WiFi interfaces item description **return** WiFi interface list, string type > C++ defination code: > ```cpp > std::vector<std::string> list_devices() > ``` ## Class {#Class} ### AP\\_Info {#AP\\_Info} WiFi AP info > C++ defination code: > ```cpp > class AP_Info > ``` #### ssid {#ssid} WiFi AP info SSID item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<uint8_t> ssid > ``` #### bssid {#bssid} WiFi AP info BSSID item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string bssid > ``` #### security {#security} WiFi AP info security item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string security > ``` #### channel {#channel} WiFi AP info channel item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int channel > ``` #### frequency {#frequency} WiFi AP info frequency item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int frequency > ``` #### rssi {#rssi} WiFi AP info rssi item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int rssi > ``` #### ssid\\_str {#ssid\\_str} ```python def ssid_str(self) > str ``` WiFi AP info ssid_str item description **type** func **static** False > C++ defination code: > ```cpp > std::string ssid_str() > ``` ### Wifi {#Wifi} Wifi class > C++ defination code: > ```cpp > class Wifi > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, iface: str 'wlan0') > None ``` Wifi class item description **type** func **param** **iface**: wifi interface name, default is wlan0<br> **static** False > C++ defination code: > ```cpp > Wifi(std::string iface \"wlan0\") > ``` #### get\\_ip {#get\\_ip} ```python def get_ip(self) > str ``` Get current WiFi ip item description **type** func **return** ip, string type, if network not connected, will return empty string. **static** False > C++ defination code: > ```cpp > std::string get_ip() > ``` #### get\\_mac {#get\\_mac} ```python def get_mac(self) > str ``` Get current WiFi MAC address item description **type** func **return** ip, string type. **static** False > C++ defination code: > ```cpp > std::string get_mac() > ``` #### get\\_ssid {#get\\_ssid} ```python def get_ssid(self, from_cache: bool True) > str ``` Get current WiFi SSID item description **type** func **param** **from_cache**: if true, will not read config from file, direct use ssid in cache.<br>attention, first time call this method will auto matically read config from file, and if call connect method will set cache.<br> **return** SSID, string type. **static** False > C++ defination code: > ```cpp > std::string get_ssid(bool from_cache true) > ``` #### get\\_gateway {#get\\_gateway} ```python def get_gateway(self) > str ``` Get current WiFi ip item description **type** func **return** ip, string type, if network not connected, will return empty string. **static** False > C++ defination code: > ```cpp > std::string get_gateway() > ``` #### start\\_scan {#start\\_scan} ```python def start_scan(self) > maix.err.Err ``` WiFi start scan AP info around in background. item description **type** func **return** If success, return err.Err.ERR_NONE, else means failed. **static** False > C++ defination code: > ```cpp > err::Err start_scan() > ``` #### get\\_scan\\_result {#get\\_scan\\_result} ```python def get_scan_result(self) > list[AP_Info] ``` Get WiFi scan AP info. item description **type** func **return** wifi.AP_Info list. **static** False > C++ defination code: > ```cpp > std::vector<network::wifi::AP_Info> get_scan_result() > ``` #### stop\\_scan {#stop\\_scan} ```python def stop_scan(self) > None ``` Stop WiFi scan AP info. item description **type** func **static** False > C++ defination code: > ```cpp > void stop_scan() > ``` #### connect {#connect} ```python def connect(self, ssid: str, password: str, wait: bool True, timeout: int 60) > maix.err.Err ``` Connect to WiFi AP. item description **type** func **param** **ssid**: SSID of AP<br>**password**: password of AP, if no password, leave it empty.<br>**wait**: wait for got IP or failed or timeout.<br>**timeout**: connect timeout internal, unit second.<br> **return** If success, return err.Err.ERR_NONE, else means failed. **static** False > C++ defination code: > ```cpp > err::Err connect(const std::string &ssid, const std::string &password, bool wait true, int timeout 60) > ``` #### disconnect {#disconnect} ```python def disconnect(self) > maix.err.Err ``` Disconnect from WiFi AP. item description **type** func **return** If success, return err.Err.ERR_NONE, else means failed. **static** False > C++ defination code: > ```cpp > err::Err disconnect() > ``` #### is\\_connected {#is\\_connected} ```python def is_connected(self) > bool ``` See if WiFi is connected to AP. item description **type** func **return** If connected return true, else false. **static** False > C++ defination code: > ```cpp > bool is_connected() > ``` #### start\\_ap {#start\\_ap} ```python def start_ap(self, ssid: str, password: str, mode: str 'g', channel: int 0, ip: str '192.168.66.1', netmask: str '255.255.255.0', hidden: bool False) > maix.err.Err ``` Start WiFi AP. item description **type** func **param** **ssid**: SSID of AP.<br>**password**: password of AP, if no password, leave it empty.<br>**ip**: ip address of hostap, default empty string means auto generated one according to hardware.<br>**netmask**: netmask, default 255.255.255.0, now only support 255.255.255.0 .<br>**mode**: WiFi mode, default g(IEEE 802.11g (2.4 GHz)), a IEEE 802.11a (5 GHz), b IEEE 802.11b (2.4 GHz).<br>**channel**: WiFi channel number, 0 means auto select. MaixCAM not support auto, will default channel 1.<br>**hidden**: hidden SSID or not.<br> **return** If success, return err.Err.ERR_NONE, else means failed. **static** False > C++ defination code: > ```cpp > err::Err start_ap(const std::string &ssid, const std::string &password, > std::string mode \"g\", int channel 0, > const std::string &ip \"192.168.66.1\", const std::string &netmask \"255.255.255.0\", > bool hidden false) > ``` #### stop\\_ap {#stop\\_ap} ```python def stop_ap(self) > maix.err.Err ``` Stop WiFi AP. item description **type** func **return** If success, return err.Err.ERR_NONE, else means failed. **static** False > C++ defination code: > ```cpp > err::Err stop_ap() > ``` #### is\\_ap\\_mode {#is\\_ap\\_mode} ```python def is_ap_mode(self) > bool ``` Whether WiFi is AP mode item description **type** func **return** True if AP mode now, or False. **static** False > C++ defination code: > ```cpp > bool is_ap_mode() > ```"},"/maixpy/api/maix/sys.html":{"title":"maix.sys","content":" title: maix.sys maix.sys module > You can use `maix.sys` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### Feature {#Feature} Special features enumerate for sys.is_support to query platform support feature or not. item describe **values** **AI_ISP**: <br>**MAX**: <br> > C++ defination code: > ```cpp > enum class Feature > { > AI_ISP 0, > MAX > } > ``` ## Variable {#Variable} ## Function {#Function} ### os\\_version {#os\\_version} ```python def os_version() > str ``` Get system version item description **return** version string, e.g. \"maixcam 2024 08 13 maixpy v4.4.20\" > C++ defination code: > ```cpp > std::string os_version() > ``` ### maixpy\\_version {#maixpy\\_version} ```python def maixpy_version() > str ``` Get MaixPy version, if get failed will return empty string. item description **return** version string, e.g. \"4.4.21\" > C++ defination code: > ```cpp > std::string maixpy_version() > ``` ### runtime\\_version {#runtime\\_version} ```python def runtime_version() > str ``` Get runtime version item description **return** current runtime version > C++ defination code: > ```cpp > std::string runtime_version() > ``` ### device\\_configs {#device\\_configs} ```python def device_configs(cache: bool True) > dict[str, str] ``` Get device configs, we also say board configs. e.g. for MaixCAM it read form /boot/board item description **param** **cache**: read config from cache(if exists, or will call device_configs first internally) if true,<br>if false, always read fron config file.<br> **return** device config,json format **throw** If board config file error will throw out exception(err.Exception) > C++ defination code: > ```cpp > std::map<std::string, std::string> device_configs(bool cache true) > ``` ### device\\_id {#device\\_id} ```python def device_id(cache: bool True) > str ``` Get device id item description **param** **cache**: read id from cache(if exists, or will call device_configs first internally) if true,<br>if false, always read fron config file.<br> **return** device id, e.g. \"maixcam\" \"maixcam_pro\" > C++ defination code: > ```cpp > std::string device_id(bool cache true) > ``` ### device\\_name {#device\\_name} ```python def device_name(cache: bool True) > str ``` Get device name item description **param** **cache**: read id from cache(if exists, or will call device_configs first internally) if true,<br>if false, always read fron config file.<br> **return** device name, e.g. \"MaixCAM\" \"MaixCAM Pro\" > C++ defination code: > ```cpp > std::string device_name(bool cache true) > ``` ### host\\_name {#host\\_name} ```python def host_name() > str ``` Get host name item description **return** host name, e.g. \"maixcam 2f9f\" > C++ defination code: > ```cpp > std::string host_name() > ``` ### host\\_domain {#host\\_domain} ```python def host_domain() > str ``` Get host domain item description **return** host domain, e.g. \"maixcam 2f9f.local\" > C++ defination code: > ```cpp > std::string host_domain() > ``` ### ip\\_address {#ip\\_address} ```python def ip_address() > dict[str, str] ``` Get ip address item description **return** ip address, dict type, e.g. {\"eth0\": \"192.168.0.195\", \"wlan0\": \"192.168.0.123\", \"usb0\": \"10.47.159.1\"} > C++ defination code: > ```cpp > std::map<std::string, std::string> ip_address() > ``` ### mac\\_address {#mac\\_address} ```python def mac_address() > dict[str, str] ``` Get mac address item description **return** mac address, dict type, e.g. {\"eth0\": \"00:0c:29:2f:9f:00\", \"wlan0\": \"00:0c:29:2f:9f:01\", \"usb0\": \"00:0c:29:2f:9f:02\"} > C++ defination code: > ```cpp > std::map<std::string, std::string> mac_address() > ``` ### device\\_key {#device\\_key} ```python def device_key() > str ``` Get device key, can be unique id of device item description **return** device key, 32 bytes hex string, e.g. \"1234567890abcdef1234567890abcdef\" > C++ defination code: > ```cpp > std::string device_key() > ``` ### memory\\_info {#memory\\_info} ```python def memory_info() > dict[str, int] ``` Get memory info item description **return** memory info, dict type, e.g. {\"total\": 1024, \"used\": 512, \"hw_total\": 256*1024*1024}<br>total: total memory size in Byte.<br>used: used memory size in Byte.<br>hw_total: total memory size in Byte of hardware, the total < hw_total，<br>OS kernel may reserve some memory for some hardware like camera, npu, display etc.<br>cmm_total: Board or Chip custom memory management area, we call them cmm memory here. For example, for MaixCAM is IOA, for MaixCAM2 is CMM.<br>cmm_used: Board or Chip custom memory management area used size, we call them cmm memory here.<br>cma_total: Contiguous Memory Allocator (Linux CMA standard) total size in Byte.<br>cma_used: Contiguous Memory Allocator (Linux CMA standard) used size in Byte. > C++ defination code: > ```cpp > std::map<std::string, int64_t> memory_info() > ``` ### bytes\\_to\\_human {#bytes\\_to\\_human} ```python def bytes_to_human(bytes: int, precision: int 2, base: int 1024, units: list[str] [], sep: str ' ') > str ``` Bytes to human readable string item description **param** **bytes:**: bytes size，e.g. 1234B 1234/1024 1.205 KB<br>**precision:**: decimal precision, default 2<br>**base:**: base number, default 1024<br>**unit:**: unit string, e.g. \"B\"<br>**sep:**: separator string, e.g. \" \"<br> **return** human readable string, e.g. \"1.21 KB\" > C++ defination code: > ```cpp > std::string bytes_to_human(unsigned long long bytes, int precision 2, int base 1024, const std::vector<std::string> &units std::vector<std::string>(), const std::string &sep \" \") > ``` ### cpu\\_freq {#cpu\\_freq} ```python def cpu_freq() > dict[str, int] ``` Get CPU frequency item description **return** CPU frequency, dict type, e.g. {\"cpu0\": 1000000000, \"cpu1\": 1000000000} > C++ defination code: > ```cpp > std::map<std::string, unsigned long> cpu_freq() > ``` ### cpu\\_temp {#cpu\\_temp} ```python def cpu_temp() > dict[str, float] ``` Get CPU temperature item description **return** CPU temperature, unit dgree, dict type, e.g. {\"cpu\": 50.0, \"cpu0\": 50, \"cpu1\": 50} > C++ defination code: > ```cpp > std::map<std::string, float> cpu_temp() > ``` ### cpu\\_usage {#cpu\\_usage} ```python def cpu_usage() > dict[str, float] ``` Get CPU usage item description **return** CPU usage, dict type, e.g. {\"cpu\": 50.0, \"cpu0\": 50, \"cpu1\": 50} > C++ defination code: > ```cpp > std::map<std::string, float> cpu_usage() > ``` ### npu\\_freq {#npu\\_freq} ```python def npu_freq() > dict[str, int] ``` Get NPU frequency item description **return** NPU frequency, dict type, e.g. {\"npu0\": 500000000}, value 1 means not support query on this platform.<br>If get from system failed, will return last time value. > C++ defination code: > ```cpp > std::map<std::string, unsigned long> npu_freq() > ``` ### npu\\_usage {#npu\\_usage} ```python def npu_usage() > dict[str, float] ``` Get NPU usage item description **return** NPU usage, dict type, e.g. {\"npu\": 50.0, \"npu0\": 50, \"npu1\": 50} > C++ defination code: > ```cpp > std::map<std::string, float> npu_usage() > ``` ### disk\\_usage {#disk\\_usage} ```python def disk_usage(path: str '/') > dict[str, int] ``` Get disk usage item description **param** **path:**: disk path, default \"/\"<br> **return** disk usage, dict type, e.g. {\"total\": 1024, \"used\": 512} > C++ defination code: > ```cpp > std::map<std::string, unsigned long long> disk_usage(const std::string &path \"/\") > ``` ### disk\\_partitions {#disk\\_partitions} ```python def disk_partitions(only_disk: bool True) > list[dict[str, str]] ``` Get disk partition and mount point info item description **param** **only_disk**: only return real disk, tempfs sysfs etc. not return, default true.<br> **return** disk partition and mount point info, list type, e.g. [{\"device\": \"/dev/mmcblk0p1\", \"mountpoint\": \"/mnt/sdcard\", \"fstype\": \"vfat\"}] > C++ defination code: > ```cpp > std::vector<std::map<std::string, std::string>> disk_partitions(bool only_disk true) > ``` ### register\\_default\\_signal\\_handle {#register\\_default\\_signal\\_handle} register default signal handle > C++ defination code: > ```cpp > void register_default_signal_handle() > ``` ### poweroff {#poweroff} ```python def poweroff() > None ``` Power off device > C++ defination code: > ```cpp > void poweroff() > ``` ### reboot {#reboot} ```python def reboot() > None ``` Power off device and power on > C++ defination code: > ```cpp > void reboot() > ``` ### is\\_support {#is\\_support} ```python def is_support(feature: Feature) > bool ``` Query is board support special feature or not. item description **param** **feature**: which feature you want to query, see sys.Feature enumerate.<br> > C++ defination code: > ```cpp > bool is_support(sys::Feature feature) > ``` ## Class {#Class}"},"/maixpy/api/maix/rtmp.html":{"title":"maix.rtmp","content":" title: maix.rtmp maix.rtmp module > You can use `maix.rtmp` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### TagType {#TagType} Video type item describe **values** **TAG_NONE**: <br>**TAG_VIDEO**: <br>**TAG_AUDIO**: <br>**TAG_SCRIPT**: <br> > C++ defination code: > ```cpp > enum TagType > { > TAG_NONE, > TAG_VIDEO, > TAG_AUDIO, > TAG_SCRIPT, > } > ``` ## Variable {#Variable} ## Function {#Function} ## Class {#Class} ### Rtmp {#Rtmp} Rtmp class > C++ defination code: > ```cpp > class Rtmp > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, host: str 'localhost', port: int 1935, app: str '', stream: str '', bitrate: int 1000000) > None ``` Construct a new Video object item description **type** func **note** Rtmp url : rtmp://host:prot/app/stream<br>example:<br>r Rtmp(\"localhost\", 1935, \"live\", \"stream\")<br>means rtmp url is rtmp://localhost:1935/live/stream **param** **host**: rtmp ip<br>**port**: rtmp port, default is 1935.<br>**app**: rtmp app name<br>**stream**: rtmp stream name<br>**bitrate**: rtmp bitrate, default is 1000 * 1000<br> **static** False > C++ defination code: > ```cpp > Rtmp(std::string host \"localhost\", int port 1935, std::string app std::string(), std::string stream std::string(), int bitrate 1000 * 1000) > ``` #### bitrate {#bitrate} ```python def bitrate(self) > int ``` Get bitrate item description **type** func **return** bitrate **static** False > C++ defination code: > ```cpp > int bitrate() > ``` #### bind\\_camera {#bind\\_camera} ```python def bind_camera(self, cam: maix.camera.Camera) > maix.err.Err ``` Bind camera item description **type** func **note** If the cam object is bound, the cam object cannot be used elsewhere. **param** **cam**: camera object<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err bind_camera(camera::Camera *cam) > ``` #### bind\\_audio\\_recorder {#bind\\_audio\\_recorder} ```python def bind_audio_recorder(self, recorder: maix.audio.Recorder) > maix.err.Err ``` Bind audio recorder item description **type** func **note** If the audio_recorder object is bound, the audio_recorder object cannot be used elsewhere. **param** **recorder**: audio_recorder object<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err bind_audio_recorder(audio::Recorder *recorder) > ``` #### bind\\_display {#bind\\_display} ```python def bind_display(self, display: maix.display.Display) > maix.err.Err ``` Bind display item description **type** func **note** If the display object is bound, the display object cannot be used elsewhere. **param** **disaply**: display object<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err bind_display(display::Display *display) > ``` #### get\\_camera {#get\\_camera} ```python def get_camera(self) > maix.camera.Camera ``` If you bind a camera, return the camera object. item description **type** func **return** Camera object **static** False > C++ defination code: > ```cpp > camera::Camera *get_camera() > ``` #### start {#start} ```python def start(self, path: str '') > maix.err.Err ``` Start push stream item description **type** func **note** only support flv file now **param** **path**: File path, if you passed file path, cyclic push the file, else if you bound camera, push the camera image.(This parameter has been deprecated)<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err start(std::string path std::string()) > ``` #### stop {#stop} ```python def stop(self) > maix.err.Err ``` Stop push stream item description **type** func **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err stop() > ``` #### get\\_path {#get\\_path} ```python def get_path(self) > str ``` Get the file path of the push stream item description **type** func **return** file path **static** False > C++ defination code: > ```cpp > std::string get_path() > ``` #### is\\_started {#is\\_started} ```python def is_started(self) > bool ``` Check whether push streaming has started item description **type** func **return** If rtmp thread is running, returns true **static** False > C++ defination code: > ```cpp > bool is_started() > ```"},"/maixpy/api/maix/audio.html":{"title":"maix.audio","content":" title: maix.audio maix.audio module > You can use `maix.audio` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### Format {#Format} Audio type item describe **values** **FMT_NONE**: format invalid<br>**FMT_S8**: unsigned 8 bits<br>**FMT_S16_LE**: signed 16 bits, little endian<br>**FMT_S32_LE**: signed 32 bits, little endian<br>**FMT_S16_BE**: signed 16 bits, big endian<br>**FMT_S32_BE**: signed 32 bits, big endian<br>**FMT_U8**: unsigned 8 bits<br>**FMT_U16_LE**: unsigned 16 bits, little endian<br>**FMT_U32_LE**: unsigned 32 bits, little endian<br>**FMT_U16_BE**: unsigned 16 bits, big endian<br>**FMT_U32_BE**: unsigned 32 bits, big endian<br> > C++ defination code: > ```cpp > enum Format > { > FMT_NONE 0, // format invalid > FMT_S8, // unsigned 8 bits > FMT_S16_LE, // signed 16 bits, little endian > FMT_S32_LE, // signed 32 bits, little endian > FMT_S16_BE, // signed 16 bits, big endian > FMT_S32_BE, // signed 32 bits, big endian > FMT_U8, // unsigned 8 bits > FMT_U16_LE, // unsigned 16 bits, little endian > FMT_U32_LE, // unsigned 32 bits, little endian > FMT_U16_BE, // unsigned 16 bits, big endian > FMT_U32_BE, // unsigned 32 bits, big endian > } > ``` ## Variable {#Variable} ### fmt\\_bits {#fmt\\_bits} Map the audio format to the number of bits item description **param** **format**: audio format<br> **return** number of bits **value** **{<br> 0, 8, 16, 32, 16, 32, 8, 16, 32, 16, 32<br> }** **readonly** True > C++ defination code: > ```cpp > const std::vector<int> fmt_bits { > 0, 8, 16, 32, 16, 32, 8, 16, 32, 16, 32 > } > ``` ## Function {#Function} ## Class {#Class} ### File {#File} Audio file reader > C++ defination code: > ```cpp > class File: public AudioFile<float> > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, sample_rate: int 16000, channels: int 1, bits_per_sample: int 16) > None ``` Construct a new File object. item description **type** func **param** **path**: wav or pcm file path<br>**sample_rate**: sample rate, need to be filled in when parsing .pcm files<br>**channels**: channels, need to be filled in when parsing .pcm files<br>**bits_per_sample**: bits per sample, need to be filled in when parsing .pcm files<br> **static** False > C++ defination code: > ```cpp > File(int sample_rate 16000, int channels 1, int bits_per_sample 16) > ``` #### load {#load} ```python def load(self, path: str, sample_rate: int 16000, channels: int 1, bits_per_sample: int 16) > maix.err.Err ``` Loads an audio file from a given file path. item description **type** func **param** **path**: The file path to load the audio file from.<br>**sample_rate**: The sample rate of the audio file. Only required for PCM files<br>**channels**: The number of channels in the audio file. Only required for PCM files<br>**bits_per_sample**: The number of bits per sample in the audio file. Only required for PCM files<br> **return** An error code indicating whether the operation was successful or not. **static** False > C++ defination code: > ```cpp > err::Err load(std::string path, int sample_rate 16000, int channels 1, int bits_per_sample 16) > ``` #### save {#save} ```python def save(self, path: str) > maix.err.Err ``` Saves an audio file to a given file path. item description **type** func **param** **path**: The path to the file where the audio file will be saved.<br> **return** An error code indicating whether the operation was successful or not. **static** False > C++ defination code: > ```cpp > err::Err save(std::string path) > ``` #### get\\_pcm {#get\\_pcm} ```python def get_pcm(*args, **kwargs) ``` Get pcm data item description **type** func **return** pcm data. datatype @see Bytes **static** False > C++ defination code: > ```cpp > Bytes *get_pcm(bool copy true) > ``` #### set\\_pcm {#set\\_pcm} ```python def set_pcm(self, new_pcm: maix.Bytes(bytes), copy: bool True) > None ``` Set pcm data item description **type** func **param** **new_pcm**: pcm data. datatype @see Bytes<br> **static** False > C++ defination code: > ```cpp > void set_pcm(Bytes *new_pcm, bool copy true) > ``` #### sample\\_bits {#sample\\_bits} ```python def sample_bits(self, new_sample_bits: int 1) > int ``` Get sample bit item description **type** func **param** **new_sample_bit**: if new_sample_bit > 0, set sample bit<br> **return** current sample bit **static** False > C++ defination code: > ```cpp > int sample_bits(int new_sample_bits 1) > ``` #### channels {#channels} ```python def channels(self, new_channels: int 1) > int ``` Get channels item description **type** func **param** **new_channels**: if new_channels > 0, change channels<br> **return** current channels **static** False > C++ defination code: > ```cpp > int channels(int new_channels 1) > ``` #### sample\\_rate {#sample\\_rate} ```python def sample_rate(self, new_sample_rate: int 1) > int ``` Get sample rate item description **type** func **param** **new_sample_rate**: if new_sample_rate > 0, change sample rate<br> **return** current sample rate **static** False > C++ defination code: > ```cpp > int sample_rate(int new_sample_rate 1) > ``` ### Recorder {#Recorder} Recorder class > C++ defination code: > ```cpp > class Recorder > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 2} ```python def __init__(self, path: str '', sample_rate: int 48000, format: Format ..., channel: int 1, block: bool True) > None ``` Construct a new Recorder object. currectly only pcm and wav formats supported. item description **type** func **param** **path**: record path. the path determines the location where you save the file, if path is none, the audio module will not save file.<br>**sample_rate**: record sample rate, default is 48000(48KHz), means 48000 samples per second.<br>**format**: record sample format, default is audio::Format::FMT_S16_LE, means sampling 16 bits at a time and save as signed 16 bits, little endian. see @audio::Format<br>**channel**: record sample channel, default is 1, means 1 channel sampling at the same time<br>**block**: block record, default is true, means block record, if false, record will not block<br> **static** False > C++ defination code: > ```cpp > Recorder(std::string path std::string(), int sample_rate 48000, audio::Format format audio::Format::FMT_S16_LE, int channel 1, bool block true) > ``` #### volume {#volume} ```python def volume(self, value: int 1) > int ``` Set/Get record volume item description **type** func **param** **value**: volume value, If you use this parameter, audio will set the value to volume,<br>if you don't, it will return the current volume. range is [0, 100].<br> **return** the current volume **static** False > C++ defination code: > ```cpp > int volume(int value 1) > ``` #### mute {#mute} ```python def mute(self, data: int 1) > bool ``` Mute item description **type** func **note** MaixCAM2 dose not support this api. **param** **data**: mute data, If you set this parameter to true, audio will set the value to mute,<br>if you don't, it will return the current mute status.<br> **return** Returns whether mute is currently enabled. **static** False > C++ defination code: > ```cpp > bool mute(int data 1) > ``` #### reset {#reset} ```python def reset(self, start: bool True) > None ``` Reset record status item description **type** func **param** **start**: start prepare audio data, default is True<br> **static** False > C++ defination code: > ```cpp > void reset(bool start true) > ``` #### record {#record} ```python def record(*args, **kwargs) ``` Record, Read all cached data in buffer and return. If there is no audio data in the buffer, may return empty data. item description **type** func **note** **1**. Do not set the time too low, for example: 1ms, as the buffer may not be ready with audio data, which could corrupt the internal state.<br>**2**. In non blocking mode, you need to actively execute reset() before you can start capturing audio.<br>Additionally, in non blocking mode, if the buffer does not have enough data, only the currently prepared audio data will be returned.<br>the length of the actual output audio data may not match the length of the captured audio data.<br> **param** **record_ms**: Block and record audio data lasting `record_ms` milliseconds and save it to a file.<br> **return** pcm data. datatype @see Bytes. For MaixCDK users, you need to manually release the returned PCM object. **static** False > C++ defination code: > ```cpp > maix::Bytes *record(int record_ms 1) > ``` #### finish {#finish} ```python def finish(self) > maix.err.Err ``` Finish the record, if you have passed in the path, this api will save the audio data to file. item description **type** func **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err finish() > ``` #### frame\\_size {#frame\\_size} ```python def frame_size(self, frame_count: int 1) > int ``` Returns the number of bytes for frame_count frames. item description **type** func **param** **frame_count**: frame count<br> **return** frame bytes **static** False > C++ defination code: > ```cpp > int frame_size(int frame_count 1) > ``` #### get\\_remaining\\_frames {#get\\_remaining\\_frames} ```python def get_remaining_frames(self) > int ``` Return the number of frames available for reading during recording, unit is frame. item description **type** func **note** **1**. MaixCAM2 dose not support this api.<br>**2**. The number of bytes per frame can be calculated using frame_size().<br> **return** remaining frames **static** False > C++ defination code: > ```cpp > int get_remaining_frames() > ``` #### period\\_size {#period\\_size} ```python def period_size(self, period_size: int 1) > int ``` Set/Get the audio buffer size, unit: frame. item description **type** func **note** **1**. Generally, the buffer size needs to be modified during non blocking operations.<br>**2**. The number of bytes per frame can be calculated using frame_size().<br> **param** **period_size**: When period_size is less than 0, the current value of period_size will be returned;<br>when period_size is greater than 0, period_size will be updated, and the size of period_size after setting will be returned.<br> **return** the current period size **static** False > C++ defination code: > ```cpp > int period_size(int period_size 1) > ``` #### period\\_count {#period\\_count} ```python def period_count(self, period_count: int 1) > int ``` Set/Get the audio buffer count, unit: frame. item description **type** func **note** Generally, the buffer size needs to be modified during non blocking operations. **param** **period_count**: When period_count is less than 0, the current value of period_count will be returned;<br>when period_count is greater than 0, period_count will be updated, and the size of period_count after setting will be returned.<br> **return** the current period size **static** False > C++ defination code: > ```cpp > int period_count(int period_count 1) > ``` #### sample\\_rate {#sample\\_rate 2} ```python def sample_rate(self) > int ``` Get sample rate item description **type** func **return** returns sample rate **static** False > C++ defination code: > ```cpp > int sample_rate() > ``` #### format {#format 2} ```python def format(self) > Format ``` Get sample format item description **type** func **return** returns sample format **static** False > C++ defination code: > ```cpp > audio::Format format() > ``` #### channel {#channel} ```python def channel(self) > int ``` Get sample channel item description **type** func **return** returns sample channel **static** False > C++ defination code: > ```cpp > int channel() > ``` ### Player {#Player} Player class > C++ defination code: > ```cpp > class Player > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 3} ```python def __init__(self, path: str '', sample_rate: int 48000, format: Format ..., channel: int 1, block: bool True) > None ``` Construct a new Player object item description **type** func **param** **path**: player path. the path determines the location where you save the file, if path is none, the audio module will not save file.<br>**sample_rate**: player sample rate, default is 48000(48KHz), means 48000 samples per second.<br>**format**: player sample format, default is audio::Format::FMT_S16_LE, means sampling 16 bits at a time and save as signed 16 bits, little endian. see @audio::Format<br>**channel**: player sample channel, default is 1, means 1 channel sampling at the same time<br>**block**: block record, default is true, means block record, if false, record will not block<br> **static** False > C++ defination code: > ```cpp > Player(std::string path std::string(), int sample_rate 48000, audio::Format format audio::Format::FMT_S16_LE, int channel 1, bool block true) > ``` #### volume {#volume 2} ```python def volume(self, value: int 1) > int ``` Set/Get player volume item description **type** func **param** **value**: volume value, If you use this parameter, audio will set the value to volume,<br>if you don't, it will return the current volume. range is [0, 100].<br> **return** the current volume **static** False > C++ defination code: > ```cpp > int volume(int value 1) > ``` #### play {#play} ```python def play(self, data: maix.Bytes(bytes) b'') > maix.err.Err ``` Play item description **type** func **param** **data**: audio data, must be raw data<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err play(maix::Bytes *data maix::audio::Player::NoneBytes) > ``` #### frame\\_size {#frame\\_size 2} ```python def frame_size(self, frame_count: int 1) > int ``` Returns the number of bytes for frame_count frames. item description **type** func **param** **frame_count**: frame count<br> **return** frame bytes **static** False > C++ defination code: > ```cpp > int frame_size(int frame_count 1) > ``` #### get\\_remaining\\_frames {#get\\_remaining\\_frames 2} ```python def get_remaining_frames(self) > int ``` Return the number of idle frames available for writing during playback, unit: frame. if there are no idle frames, it will cause blocking. item description **type** func **note** **1**. MaixCAM2 dose not support this api.<br>**2**. The number of bytes per frame can be calculated using frame_size().<br> **return** remaining frames **static** False > C++ defination code: > ```cpp > int get_remaining_frames() > ``` #### period\\_size {#period\\_size 2} ```python def period_size(self, period_size: int 1) > int ``` Set/Get the audio buffer size, unit: frame. item description **type** func **note** **1**. Generally, the buffer size needs to be modified during non blocking operations.<br>**2**. The number of bytes per frame can be calculated using frame_size().<br> **param** **period_size**: When period_size is less than 0, the current value of period_size will be returned;<br>when period_size is greater than 0, period_size will be updated, and the size of period_size after setting will be returned.<br> **return** the current period size **static** False > C++ defination code: > ```cpp > int period_size(int period_size 1) > ``` #### period\\_count {#period\\_count 2} ```python def period_count(self, period_count: int 1) > int ``` Set/Get the audio buffer count, unit: frame. item description **type** func **note** Generally, the buffer size needs to be modified during non blocking operations. **param** **period_count**: When period_count is less than 0, the current value of period_count will be returned;<br>when period_count is greater than 0, period_count will be updated, and the size of period_count after setting will be returned.<br> **return** the current period count **static** False > C++ defination code: > ```cpp > int period_count(int period_count 1) > ``` #### reset {#reset 2} ```python def reset(self, start: bool False) > None ``` Reset player status item description **type** func **param** **start**: start play audio data, default is False<br> **static** False > C++ defination code: > ```cpp > void reset(bool start false) > ``` #### sample\\_rate {#sample\\_rate 3} ```python def sample_rate(self) > int ``` Get sample rate item description **type** func **return** returns sample rate **static** False > C++ defination code: > ```cpp > int sample_rate() > ``` #### format {#format 3} ```python def format(self) > Format ``` Get sample format item description **type** func **return** returns sample format **static** False > C++ defination code: > ```cpp > audio::Format format() > ``` #### channel {#channel 2} ```python def channel(self) > int ``` Get sample channel item description **type** func **return** returns sample channel **static** False > C++ defination code: > ```cpp > int channel() > ```"},"/maixpy/api/maix/display.html":{"title":"maix.display","content":" title: maix.display maix.display module, control display device and show image on it > You can use `maix.display` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ## Variable {#Variable} ## Function {#Function} ### send\\_to\\_maixvision {#send\\_to\\_maixvision} ```python def send_to_maixvision(img: maix.image.Image) > None ``` Send image to MaixVision work station if connected.\\nIf you want to debug your program an don't want to initialize display, use this method. item description **param** **img**: image to send, image.Image object<br> > C++ defination code: > ```cpp > void send_to_maixvision(image::Image &img) > ``` ### set\\_trans\\_image\\_quality {#set\\_trans\\_image\\_quality} ```python def set_trans_image_quality(value: int) > None ``` Set image transport quality(only for JPEG) item description **param** **quality**: default 95, value from 51 ~ 100<br> > C++ defination code: > ```cpp > void set_trans_image_quality(const int value) > ``` ## Class {#Class} ### Display {#Display} Display class > C++ defination code: > ```cpp > class Display > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, width: int 1, height: int 1, format: maix.image.Format ..., device: str '', open: bool True) > None ``` Construct a new Display object item description **type** func **param** **width**: display width, by default(value is 1) means auto detect,<br>if width > max device supported width, will auto set to max device supported width<br>**height**: display height, by default(value is 1) means auto detect,<br>if height > max device supported height, will auto set to max device supported height<br>**device**: display device name, you can get devices by list_devices method, by default(value is NULL(None in MaixPy)) means the first device<br>**open**: If true, display will automatically call open() after creation. default is true.<br> **static** False > C++ defination code: > ```cpp > Display(int width 1, int height 1, image::Format format image::FMT_RGB888, const std::string &device \"\", bool open true) > ``` #### width {#width} ```python def width(self) > int ``` Get display width item description **type** func **return** width **static** False > C++ defination code: > ```cpp > int width() > ``` #### height {#height} ```python def height(self) > int ``` Get display height item description **type** func **param** **ch**: channel to get, by default(value is 0) means the first channel<br> **return** height **static** False > C++ defination code: > ```cpp > int height() > ``` #### size {#size} ```python def size(self) > list[int] ``` Get display size item description **type** func **param** **ch**: channel to get, by default(value is 0) means the first channel<br> **return** size A list type in MaixPy, [width, height] **static** False > C++ defination code: > ```cpp > std::vector<int> size() > ``` #### format {#format} ```python def format(self) > maix.image.Format ``` Get display format item description **type** func **return** format **static** False > C++ defination code: > ```cpp > image::Format format() > ``` #### open {#open} ```python def open(self, width: int 1, height: int 1, format: maix.image.Format ...) > maix.err.Err ``` open display device, if already opened, will return err.ERR_NONE. item description **type** func **param** **width**: display width, default is 1, means auto, mostly means max width of display support<br>**height**: display height, default is 1, means auto, mostly means max height of display support<br>**format**: display output format, default is RGB888<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err open(int width 1, int height 1, image::Format format image::FMT_INVALID) > ``` #### close {#close} ```python def close(self) > maix.err.Err ``` close display device item description **type** func **return** error code **static** False > C++ defination code: > ```cpp > err::Err close() > ``` #### add\\_channel {#add\\_channel} ```python def add_channel(self, width: int 1, height: int 1, format: maix.image.Format ..., open: bool True) > Display ``` Add a new channel and return a new Display object, you can use close() to close this channel. item description **type** func **attention** If a new disp channel is created, it is recommended to set fit image::FIT_COVER or fit image::FIT_FILL when running show for the main channel,<br>otherwise the display of the new disp channel may be abnormal. **param** **width**: display width, default is 1, means auto, mostly means max width of display support. Maximum width must not exceed the main channel.<br>**height**: display height, default is 1, means auto, mostly means max height of display support. Maximum height must not exceed the main channel.<br>**format**: display output format, default is FMT_BGRA8888<br>**open**: If true, display will automatically call open() after creation. default is true.<br> **return** new Display object **static** False > C++ defination code: > ```cpp > display::Display *add_channel(int width 1, int height 1, image::Format format image::FMT_BGRA8888, bool open true) > ``` #### is\\_opened {#is\\_opened} ```python def is_opened(self) > bool ``` check display device is opened or not item description **type** func **return** opened or not, bool type **static** False > C++ defination code: > ```cpp > bool is_opened() > ``` #### is\\_closed {#is\\_closed} ```python def is_closed(self) > bool ``` check display device is closed or not item description **type** func **return** closed or not, bool type **static** False > C++ defination code: > ```cpp > bool is_closed() > ``` #### show {#show} ```python def show(self, img: maix.image.Image, fit: maix.image.Fit ...) > maix.err.Err ``` show image on display device, and will also send to MaixVision work station if connected. item description **type** func **param** **img**: image to show, image.Image object,<br>if the size of image smaller than display size, will show in the center of display;<br>if the size of image bigger than display size, will auto resize to display size and keep ratio, fill blank with black color.<br>**fit**: image in screen fit mode, by default(value is image.FIT_CONTAIN), @see image.Fit for more details<br>e.g. image.FIT_CONTAIN means resize image to fit display size and keep ratio, fill blank with black color.<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err show(image::Image &img, image::Fit fit image::FIT_CONTAIN) > ``` #### push {#push} ```python def push(self, frame: ..., fit: maix.image.Fit ...) > maix.err.Err ``` push pipeline frame to display item description **type** func **param** **frame**: pipeline frame<br>**fit**: image in screen fit mode, by default(value is image.FIT_CONTAIN), @see image.Fit for more details<br>e.g. image.FIT_CONTAIN means resize image to fit display size and keep ratio, fill blank with black color.<br> **return** error code **static** False > C++ defination code: > ```cpp > err::Err push(pipeline::Frame *frame, image::Fit fit image::FIT_CONTAIN) > ``` #### device {#device} ```python def device(self) > str ``` Get display device path item description **type** func **return** display device path **static** False > C++ defination code: > ```cpp > std::string device() > ``` #### set\\_backlight {#set\\_backlight} ```python def set_backlight(self, value: float) > None ``` Set display backlight item description **type** func **param** **value**: backlight value, float type, range is [0, 100]<br> **static** False > C++ defination code: > ```cpp > void set_backlight(float value) > ``` #### get\\_backlight {#get\\_backlight} ```python def get_backlight(self) > float ``` Get display backlight item description **type** func **return** value backlight value, float type, range is [0, 100] **static** False > C++ defination code: > ```cpp > float get_backlight() > ``` #### set\\_backlight\\_on {#set\\_backlight\\_on} ```python def set_backlight_on(self, ms: int 500, wait: bool False) > None ``` Trun on display backlight in milliseconds item description **type** func **param** **ms**: time in milliseconds to turn on backlight, default 500ms, 0 means immediate<br>**wait**: If true, will wait until the backlight is turned on before returning, or will turn on in background. Default is false.<br> **static** False > C++ defination code: > ```cpp > void set_backlight_on(int ms 500, bool wait false) > ``` #### set\\_backlight\\_off {#set\\_backlight\\_off} ```python def set_backlight_off(self, ms: int 500, wait: bool False) > None ``` Trun off display backlight in milliseconds item description **type** func **param** **ms**: time in milliseconds to turn off backlight, default 500ms, 0 means immediate<br>**wait**: If true, will wait until the backlight is turned off before returning, or will turn off in background. Default is false.<br> **static** False > C++ defination code: > ```cpp > void set_backlight_off(int ms 500, bool wait false) > ``` #### set\\_backlight\\_toggle {#set\\_backlight\\_toggle} ```python def set_backlight_toggle(self, ms: int 500, wait: bool False) > None ``` Toggle display backlight state in milliseconds item description **type** func **param** **ms**: time in milliseconds to toggle backlight, default 500ms, 0 means immediate<br>**wait**: If true, will wait until the backlight is turned off before returning, or will turn off in background. Default is false.<br> **static** False > C++ defination code: > ```cpp > void set_backlight_toggle(int ms 500, bool wait false) > ``` #### is\\_setting\\_backlight {#is\\_setting\\_backlight} ```python def is_setting_backlight(self) > bool ``` Check if backlight is in setting status item description **type** func **return** true if backlight is in setting status, false if backlight is stable(on or off) **static** False > C++ defination code: > ```cpp > bool is_setting_backlight() > ``` #### set\\_hmirror {#set\\_hmirror} ```python def set_hmirror(self, en: bool) > maix.err.Err ``` Set display mirror item description **type** func **param** **en**: enable/disable mirror<br> **static** False > C++ defination code: > ```cpp > err::Err set_hmirror(bool en) > ``` #### set\\_vflip {#set\\_vflip} ```python def set_vflip(self, en: bool) > maix.err.Err ``` Set display flip item description **type** func **param** **en**: enable/disable flip<br> **static** False > C++ defination code: > ```cpp > err::Err set_vflip(bool en) > ```"},"/maixpy/api/maix/comm/modbus.html":{"title":"maix.comm.modbus","content":" title: maix.comm.modbus maix.comm.modbus module > You can use `maix.comm.modbus` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### Mode {#Mode} modbus mode item describe **values** **RTU**: <br>**TCP**: <br> > C++ defination code: > ```cpp > enum class Mode : unsigned char { > RTU, > TCP > } > ``` ### RequestType {#RequestType} Modbus request types enumeration.\\nThis enumeration defines the various Modbus request types,\\nincluding functions for reading and writing coils, registers,\\nas well as diagnostics and identification. item describe **values** **READ_COILS**: < Read Coils<br>**READ_DISCRETE_INPUTS**: < Read Discrete Inputs<br>**READ_HOLDING_REGISTERS**: < Read Holding Registers<br>**READ_INPUT_REGISTERS**: < Read Input Registers<br>**WRITE_SINGLE_COIL**: < Write Single Coil<br>**WRITE_SINGLE_REGISTER**: < Write Single Register<br>**DIAGNOSTICS**: < Diagnostics (Serial Line only)<br>**GET_COMM_EVENT_COUNTER**: < Get Comm Event Counter (Serial Line only)<br>**WRITE_MULTIPLE_COILS**: < Write Multiple Coils<br>**WRITE_MULTIPLE_REGISTERS**: < Write Multiple Registers<br>**REPORT_SERVER_ID**: < Report Slave ID (Serial Line only)<br>**MASK_WRITE_REGISTER**: < Mask Write Register<br>**READ_WRITE_MULTIPLE_REGISTERS**: < Read/Write Multiple Registers<br>**READ_DEVICE_IDENTIFICATION**: < Read Device Identification<br>**UNKNOWN**: < Unknown Request Type<br> > C++ defination code: > ```cpp > enum class RequestType : unsigned char { > READ_COILS 0x01, ///< Read Coils > READ_DISCRETE_INPUTS 0x02, ///< Read Discrete Inputs > READ_HOLDING_REGISTERS 0x03, ///< Read Holding Registers > READ_INPUT_REGISTERS 0x04, ///< Read Input Registers > WRITE_SINGLE_COIL 0x05, ///< Write Single Coil > WRITE_SINGLE_REGISTER 0x06, ///< Write Single Register > DIAGNOSTICS 0x08, ///< Diagnostics (Serial Line only) > GET_COMM_EVENT_COUNTER 0x0B, ///< Get Comm Event Counter (Serial Line only) > WRITE_MULTIPLE_COILS 0x0F, ///< Write Multiple Coils > WRITE_MULTIPLE_REGISTERS 0x10, ///< Write Multiple Registers > REPORT_SERVER_ID 0x11, ///< Report Slave ID (Serial Line only) > MASK_WRITE_REGISTER 0x16, ///< Mask Write Register > READ_WRITE_MULTIPLE_REGISTERS 0x17, ///< Read/Write Multiple Registers > READ_DEVICE_IDENTIFICATION 0x2B, ///< Read Device Identification > UNKNOWN 0xFF ///< Unknown Request Type > } > ``` ## Variable {#Variable} ## Function {#Function} ### set\\_master\\_debug {#set\\_master\\_debug} ```python def set_master_debug(debug: bool) > None ``` Set the master debug ON/OFF item description **param** **debug**: True(ON) or False(OFF)<br> > C++ defination code: > ```cpp > void set_master_debug(bool debug) > ``` ## Class {#Class} ### Slave {#Slave} Class for modbus Slave > C++ defination code: > ```cpp > class Slave > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, mode: Mode, ip_or_device: str, coils_start: int 0, coils_size: int 0, discrete_start: int 0, discrete_size: int 0, holding_start: int 0, holding_size: int 0, input_start: int 0, input_size: int 0, rtu_baud: int 115200, rtu_slave: int 1, tcp_port: int 502, debug: bool False) > None ``` Modbus Slave constructor.\\nThis constructor initializes a Modbus Slave instance. Depending on the mode (RTU or TCP),\\nit sets up the necessary parameters for communication and defines the register structure. item description **type** func **param** **mode**: Specifies the communication mode: RTU or TCP.<br>**ip_or_device**: The UART device name if using RTU mode.<br>If TCP mode is selected, this parameter is ignored.<br>**coils_start**: The starting address of the coils register.<br>**coils_size**: The number of coils to manage.<br>**discrete_start**: The starting address of the discrete inputs register.<br>**discrete_size**: The number of discrete inputs to manage.<br>**holding_start**: The starting address of the holding registers.<br>**holding_size**: The number of holding registers to manage.<br>**input_start**: The starting address of the input registers.<br>**input_size**: The number of input registers to manage.<br>**rtu_baud**: The baud rate for RTU communication.<br>Supported rates include: 110, 300, 600, 1200, 2400, 4800,<br>9600, 19200, 38400, 57600, 115200, 230400, 460800,<br>500000, 576000, 921600, 1000000, 1152000, 1500000,<br>2500000, 3000000, 3500000, 4000000.<br>Default is 115200. Ensure that the selected baud rate<br>is supported by the underlying hardware and libmodbus.<br>**rtu_slave**: The RTU slave address. Ignored in TCP mode. Default is 1.<br>**tcp_port**: The port used for TCP communication. Ignored in RTU mode. Default is 502.<br>**debug**: A boolean flag to enable or disable debug mode. Default is false.<br> **see** modbus.Mode for valid modes. **static** False > C++ defination code: > ```cpp > Slave(maix::comm::modbus::Mode mode, const std::string& ip_or_device, > uint32_t coils_start 0, uint32_t coils_size 0, > uint32_t discrete_start 0, uint32_t discrete_size 0, > uint32_t holding_start 0, uint32_t holding_size 0, > uint32_t input_start 0, uint32_t input_size 0, > int rtu_baud 115200, uint8_t rtu_slave 1, > int tcp_port 502, bool debug false) > ``` #### receive {#receive} ```python def receive(self, timeout_ms: int 1) > maix.err.Err ``` Receives a Modbus request\\nThis function is used to receive a Modbus request from the client. The behavior of the function\\ndepends on the parameter `timeout_ms` provided, which dictates how long the function will wait\\nfor a request before returning. item description **type** func **note** This function gets and parses the request, it does not manipulate the registers. **param** **timeout_ms**: Timeout setting<br> 1 Block indefinitely until a request is received<br>0 Non blocking mode; function returns immediately, regardless of whether a request is received<br>>0 Blocking mode; function will wait for the specified number of milliseconds for a request<br> **return** maix::err::Err type, @see maix::err::Err **static** False > C++ defination code: > ```cpp > ::maix::err::Err receive(const int timeout_ms 1) > ``` #### request\\_type {#request\\_type} ```python def request_type(self) > RequestType ``` Gets the type of the Modbus request that was successfully received\\nThis function can be used to retrieve the type of the request received after a successful\\ncall to `receive()`. The return value indicates the type of the Modbus request, allowing\\nthe user to understand and process the received request appropriately. item description **type** func **return** RequestType The type of the Modbus request that has been received. **see** modbus.RequestType **static** False > C++ defination code: > ```cpp > ::maix::comm::modbus::RequestType request_type() > ``` #### reply {#reply} ```python def reply(self) > maix.err.Err ``` Processes the request and returns the corresponding data.\\nThis function handles the requests received from the client. It retrieves any data that the client\\nneeds to write to the registers and updates the registers accordingly. Additionally, it retrieves\\nthe requested data from the registers and sends it back to the client in the response.\\nThis function is essential for managing read and write operations in a Modbus Slave context. item description **type** func **note** The function will modify the Slave's internal state based on the data received in the<br>request, and ensure that the appropriate data is returned to the client. **return** maix::err::Err type, @see maix::err::Err **static** False > C++ defination code: > ```cpp > ::maix::err::Err reply() > ``` #### receive\\_and\\_reply {#receive\\_and\\_reply} ```python def receive_and_reply(self, timeout_ms: int 1) > RequestType ``` Receives a request from the client and sends a response.\\nThis function combines the operations of receiving a request and sending a corresponding\\nresponse in a single call. It waits for a specified duration (defined by the `timeout_ms`\\nparameter) to receive a request from the client. Upon successful receipt of the request,\\nit processes the request and prepares the necessary data to be sent back to the client. item description **type** func **param** **timeout_ms**: The timeout duration for waiting to receive a request.<br> A value of 1 makes the function block indefinitely until a request<br>is received.<br> A value of 0 makes it non blocking, returning immediately without<br>waiting for a request.<br> A positive value specifies the maximum time (in milliseconds) to wait<br>for a request before timing out.<br> **return** RequestType The type of the Modbus request that has been received. **see** modbus.RequestType **static** False > C++ defination code: > ```cpp > ::maix::comm::modbus::RequestType receive_and_reply(const int timeout_ms 1) > ``` #### coils {#coils} ```python def coils(self, data: list[int] [], index: int 0) > list[int] ``` Reads from or writes to coils.\\nThis function can be used to either read data from coils or write data to them.\\nIf the `data` parameter is empty, the function performs a read operation.\\nIf `data` is not empty, the function writes the contents of `data` to the coils\\nstarting at the specified index. item description **type** func **param** **data**: A vector of data to be written. If empty, a read operation is performed.<br>If not empty, the data will overwrite the coils from `index`.<br>**index**: The starting index for writing data. This parameter is ignored during read operations.<br> **return** std::vector<uint16_t> When the read operation is successful, return all data in the coils as a list.<br>When the write operation is successful, return a non empty list; when it fails, return an empty list. **static** False > C++ defination code: > ```cpp > std::vector<uint8_t> coils(const std::vector<uint8_t>& data std::vector<uint8_t>{}, const uint32_t index 0) > ``` #### discrete\\_input {#discrete\\_input} ```python def discrete_input(self, data: list[int] [], index: int 0) > list[int] ``` Reads from or writes to discrete input.\\nThis function can be used to either read data from discrete input or write data to them.\\nIf the `data` parameter is empty, the function performs a read operation.\\nIf `data` is not empty, the function writes the contents of `data` to the discrete input\\nstarting at the specified index. item description **type** func **param** **data**: A vector of data to be written. If empty, a read operation is performed.<br>If not empty, the data will overwrite the discrete input from `index`.<br>**index**: The starting index for writing data. This parameter is ignored during read operations.<br> **return** std::vector<uint16_t> When the read operation is successful, return all data in the discrete input as a list.<br>When the write operation is successful, return a non empty list; when it fails, return an empty list. **static** False > C++ defination code: > ```cpp > std::vector<uint8_t> discrete_input(const std::vector<uint8_t>& data std::vector<uint8_t>{}, const uint32_t index 0) > ``` #### input\\_registers {#input\\_registers} ```python def input_registers(self, data: list[int] [], index: int 0) > list[int] ``` Reads from or writes to input registers.\\nThis function can be used to either read data from input registers or write data to them.\\nIf the `data` parameter is empty, the function performs a read operation.\\nIf `data` is not empty, the function writes the contents of `data` to the input registers\\nstarting at the specified index. item description **type** func **param** **data**: A vector of data to be written. If empty, a read operation is performed.<br>If not empty, the data will overwrite the input registers from `index`.<br>**index**: The starting index for writing data. This parameter is ignored during read operations.<br> **return** std::vector<uint16_t> When the read operation is successful, return all data in the input registers as a list.<br>When the write operation is successful, return a non empty list; when it fails, return an empty list. **static** False > C++ defination code: > ```cpp > std::vector<uint16_t> input_registers(const std::vector<uint16_t>& data std::vector<uint16_t>{}, const uint32_t index 0) > ``` #### holding\\_registers {#holding\\_registers} ```python def holding_registers(self, data: list[int] [], index: int 0) > list[int] ``` Reads from or writes to holding registers.\\nThis function can be used to either read data from holding registers or write data to them.\\nIf the `data` parameter is empty, the function performs a read operation.\\nIf `data` is not empty, the function writes the contents of `data` to the holding registers\\nstarting at the specified index. item description **type** func **param** **data**: A vector of data to be written. If empty, a read operation is performed.<br>If not empty, the data will overwrite the holding registers from `index`.<br>**index**: The starting index for writing data. This parameter is ignored during read operations.<br> **return** std::vector<uint16_t> When the read operation is successful, return all data in the holding registers as a list.<br>When the write operation is successful, return a non empty list; when it fails, return an empty list. **static** False > C++ defination code: > ```cpp > std::vector<uint16_t> holding_registers(const std::vector<uint16_t>& data std::vector<uint16_t>{}, const uint32_t index 0) > ``` ### MasterRTU {#MasterRTU} Class for modbus MasterRTU > C++ defination code: > ```cpp > class MasterRTU final > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 2} ```python def __init__(self, device: str '', baudrate: int 115200) > None ``` Construct a new MasterRTU object item description **type** func **param** **device**: Default uart device.<br>**baudrate**: Default uart baudrate.<br> **static** False > C++ defination code: > ```cpp > MasterRTU(const std::string& device \"\", const int baudrate 115200) > ``` #### read\\_coils {#read\\_coils} ```python def read_coils(self, slave_id: int, addr: int, size: int, timeout_ms: int 1, device: str '', baudrate: int 1) > list[int] ``` Reads coils from the Modbus device.\\nThis function reads a specified number of coils starting from a given address.\\nIt includes timeout settings to define how long to wait for a response. item description **type** func **param** **slave_id**: The RTU slave address.<br>**addr**: The starting address for reading coils.<br>**size**: The number of coils to read.<br>**timeout_ms**: The timeout duration for waiting to receive a request.<br> A value of 1 makes the function block indefinitely until a request<br>is received.<br> A value of 0 makes it non blocking, returning immediately without<br>waiting for a request.<br> A positive value specifies the maximum time (in milliseconds) to wait<br>for a request before timing out.<br>**device**: The UART device to use. An empty string (\"\") indicates that the<br>default device from the constructor will be used.<br>**baudrate**: The UART baud rate. A value of 1 signifies that the default baud rate<br>from the constructor will be applied.<br> **return** std::vector<uint8_t>/list[int] A vector containing the read coil values. **static** False > C++ defination code: > ```cpp > std::vector<uint8_t> read_coils(const uint32_t slave_id, const uint32_t addr, > const uint32_t size, const int timeout_ms 1, > const std::string& device \"\", const int baudrate 1) > ``` #### write\\_coils {#write\\_coils} ```python def write_coils(self, slave_id: int, data: list[int], addr: int, timeout_ms: int 1, device: str '', baudrate: int 1) > int ``` Writes values to coils on the Modbus device.\\nThis function writes the specified data to the coils starting from a given address. item description **type** func **param** **slave_id**: The RTU slave address.<br>**data**: A vector containing the coil values to write.<br>**addr**: The starting address for writing coils.<br>**timeout_ms**: The timeout duration for the write operation.<br> A value of 1 makes the function block until the write is complete.<br> A value of 0 makes it non blocking.<br> A positive value specifies the maximum time (in milliseconds) to wait.<br>**device**: The UART device to use. An empty string (\"\") indicates that the<br>default device from the constructor will be used.<br>**baudrate**: The UART baud rate. A value of 1 signifies that the default baud rate<br>from the constructor will be applied.<br> **return** int Returns the number of bytes written on success, or a value less than 0 on failure. **static** False > C++ defination code: > ```cpp > int write_coils(const uint32_t slave_id, const std::vector<uint8_t>& data, > const uint32_t addr, const int timeout_ms 1, > const std::string& device \"\", const int baudrate 1) > ``` #### read\\_discrete\\_input {#read\\_discrete\\_input} ```python def read_discrete_input(self, slave_id: int, addr: int, size: int, timeout_ms: int 1, device: str '', baudrate: int 1) > list[int] ``` Reads discrete inputs from the Modbus device.\\nThis function reads a specified number of discrete inputs starting from a given address. item description **type** func **param** **slave_id**: The RTU slave address.<br>**addr**: The starting address for reading discrete inputs.<br>**size**: The number of discrete inputs to read.<br>**timeout_ms**: The timeout duration for the write operation.<br> A value of 1 makes the function block until the write is complete.<br> A value of 0 makes it non blocking.<br> A positive value specifies the maximum time (in milliseconds) to wait.<br>**device**: The UART device to use. An empty string (\"\") indicates that the<br>default device from the constructor will be used.<br>**baudrate**: The UART baud rate. A value of 1 signifies that the default baud rate<br>from the constructor will be applied.<br> **return** std::vector<uint8_t>/list[int] A vector containing the read discrete input values. **static** False > C++ defination code: > ```cpp > std::vector<uint8_t> read_discrete_input(const uint32_t slave_id, const uint32_t addr, > const uint32_t size, const int timeout_ms 1, > const std::string& device \"\", const int baudrate 1) > ``` #### read\\_input\\_registers {#read\\_input\\_registers} ```python def read_input_registers(self, slave_id: int, addr: int, size: int, timeout_ms: int 1, device: str '', baudrate: int 1) > list[int] ``` Reads input registers from the Modbus device.\\nThis function reads a specified number of input registers starting from a given address. item description **type** func **param** **slave_id**: The RTU slave address.<br>**addr**: The starting address for reading input registers.<br>**size**: The number of input registers to read.<br>**timeout_ms**: The timeout duration for the write operation.<br> A value of 1 makes the function block until the write is complete.<br> A value of 0 makes it non blocking.<br> A positive value specifies the maximum time (in milliseconds) to wait.<br>**device**: The UART device to use. An empty string (\"\") indicates that the<br>default device from the constructor will be used.<br>**baudrate**: The UART baud rate. A value of 1 signifies that the default baud rate<br>from the constructor will be applied.<br> **return** std::vector<uint16_t>/list[int] A vector containing the read input register values. **static** False > C++ defination code: > ```cpp > std::vector<uint16_t> read_input_registers(const uint32_t slave_id, const uint32_t addr, > const uint32_t size, const int timeout_ms 1, > const std::string& device \"\", const int baudrate 1) > ``` #### read\\_holding\\_registers {#read\\_holding\\_registers} ```python def read_holding_registers(self, slave_id: int, addr: int, size: int, timeout_ms: int 1, device: str '', baudrate: int 1) > list[int] ``` Reads holding registers from the Modbus device.\\nThis function reads a specified number of holding registers starting from a given address. item description **type** func **param** **slave_id**: The RTU slave address.<br>**addr**: The starting address for reading holding registers.<br>**size**: The number of holding registers to read.<br>**timeout_ms**: The timeout duration for the write operation.<br> A value of 1 makes the function block until the write is complete.<br> A value of 0 makes it non blocking.<br> A positive value specifies the maximum time (in milliseconds) to wait.<br>**device**: The UART device to use. An empty string (\"\") indicates that the<br>default device from the constructor will be used.<br>**baudrate**: The UART baud rate. A value of 1 signifies that the default baud rate<br>from the constructor will be applied.<br> **return** std::vector<uint16_t>/list[int] A vector containing the read holding register values. **static** False > C++ defination code: > ```cpp > std::vector<uint16_t> read_holding_registers(const uint32_t slave_id, const uint32_t addr, > const uint32_t size, const int timeout_ms 1, > const std::string& device \"\", const int baudrate 1) > ``` #### write\\_holding\\_registers {#write\\_holding\\_registers} ```python def write_holding_registers(self, slave_id: int, data: list[int], addr: int, timeout_ms: int 1, device: str '', baudrate: int 1) > int ``` Writes values to holding registers on the Modbus device.\\nThis function writes the specified data to the holding registers starting from a given address. item description **type** func **param** **slave_id**: The RTU slave address.<br>**data**: A vector containing the values to write to holding registers.<br>**addr**: The starting address for writing holding registers.<br>**timeout_ms**: The timeout duration for the write operation.<br> A value of 1 makes the function block until the write is complete.<br> A value of 0 makes it non blocking.<br> A positive value specifies the maximum time (in milliseconds) to wait.<br>**device**: The UART device to use. An empty string (\"\") indicates that the<br>default device from the constructor will be used.<br>**baudrate**: The UART baud rate. A value of 1 signifies that the default baud rate<br>from the constructor will be applied.<br> **return** int Returns the number of bytes written on success, or a value less than 0 on failure. **static** False > C++ defination code: > ```cpp > int write_holding_registers(const uint32_t slave_id, const std::vector<uint16_t>& data, > const uint32_t addr, const int timeout_ms 1, > const std::string& device \"\", const int baudrate 1) > ``` ### MasterTCP {#MasterTCP} Class for modbus Master > C++ defination code: > ```cpp > class MasterTCP final > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 3} ```python def __init__(self, port: int 502) > None ``` Construct a new MasterTCP object item description **type** func **param** **port**: Device tcp port.<br> **static** False > C++ defination code: > ```cpp > MasterTCP(const int port 502) > ``` #### read\\_coils {#read\\_coils 2} ```python def read_coils(self, ip: str, addr: int, size: int, timeout_ms: int 1, port: int 1) > list[int] ``` Reads coils from the Modbus device.\\nThis function reads a specified number of coils starting from a given address.\\nIt includes timeout settings to define how long to wait for a response. item description **type** func **param** **ip**: The TCP IP address.<br>**addr**: The starting address for reading coils.<br>**size**: The number of coils to read.<br>**timeout_ms**: The timeout duration for waiting to receive a request.<br> A value of 1 makes the function block indefinitely until a request<br>is received.<br> A value of 0 makes it non blocking, returning immediately without<br>waiting for a request.<br> A positive value specifies the maximum time (in milliseconds) to wait<br>for a request before timing out.<br>**port**: The TCP port. A value of 1 signifies that the default port<br>from the constructor will be applied.<br> **return** std::vector<uint8_t>/list[int] A vector containing the read coil values. **static** False > C++ defination code: > ```cpp > std::vector<uint8_t> read_coils(const std::string ip, const uint32_t addr, > const uint32_t size, const int timeout_ms 1, > const int port 1) > ``` #### write\\_coils {#write\\_coils 2} ```python def write_coils(self, ip: str, data: list[int], addr: int, timeout_ms: int 1, port: int 1) > int ``` Writes values to coils on the Modbus device.\\nThis function writes the specified data to the coils starting from a given address. item description **type** func **param** **ip**: The TCP IP address.<br>**data**: A vector containing the coil values to write.<br>**addr**: The starting address for writing coils.<br>**timeout_ms**: The timeout duration for the write operation.<br> A value of 1 makes the function block until the write is complete.<br> A value of 0 makes it non blocking.<br> A positive value specifies the maximum time (in milliseconds) to wait.<br>**port**: The TCP port. A value of 1 signifies that the default port<br>from the constructor will be applied.<br> **return** int Returns the number of bytes written on success, or a value less than 0 on failure. **static** False > C++ defination code: > ```cpp > int write_coils(const std::string ip, const std::vector<uint8_t>& data, > const uint32_t addr, const int timeout_ms 1, > const int port 1) > ``` #### read\\_discrete\\_input {#read\\_discrete\\_input 2} ```python def read_discrete_input(self, ip: str, addr: int, size: int, timeout_ms: int 1, port: int 1) > list[int] ``` Reads discrete inputs from the Modbus device.\\nThis function reads a specified number of discrete inputs starting from a given address. item description **type** func **param** **ip**: The TCP IP address.<br>**addr**: The starting address for reading discrete inputs.<br>**size**: The number of discrete inputs to read.<br>**timeout_ms**: The timeout duration for the write operation.<br> A value of 1 makes the function block until the write is complete.<br> A value of 0 makes it non blocking.<br> A positive value specifies the maximum time (in milliseconds) to wait.<br>**port**: The TCP port. A value of 1 signifies that the default port<br>from the constructor will be applied.<br> **return** std::vector<uint8_t>/list[int] A vector containing the read discrete input values. **static** False > C++ defination code: > ```cpp > std::vector<uint8_t> read_discrete_input(const std::string ip, const uint32_t addr, > const uint32_t size, const int timeout_ms 1, > const int port 1) > ``` #### read\\_input\\_registers {#read\\_input\\_registers 2} ```python def read_input_registers(self, ip: str, addr: int, size: int, timeout_ms: int 1, port: int 1) > list[int] ``` Reads input registers from the Modbus device.\\nThis function reads a specified number of input registers starting from a given address. item description **type** func **param** **ip**: The TCP IP address.<br>**addr**: The starting address for reading input registers.<br>**size**: The number of input registers to read.<br>**timeout_ms**: The timeout duration for the write operation.<br> A value of 1 makes the function block until the write is complete.<br> A value of 0 makes it non blocking.<br> A positive value specifies the maximum time (in milliseconds) to wait.<br>**port**: The TCP port. A value of 1 signifies that the default port<br>from the constructor will be applied.<br> **return** std::vector<uint16_t>/list[int] A vector containing the read input register values. **static** False > C++ defination code: > ```cpp > std::vector<uint16_t> read_input_registers(const std::string ip, const uint32_t addr, > const uint32_t size, const int timeout_ms 1, > const int port 1) > ``` #### read\\_holding\\_registers {#read\\_holding\\_registers 2} ```python def read_holding_registers(self, ip: str, addr: int, size: int, timeout_ms: int 1, port: int 1) > list[int] ``` Reads holding registers from the Modbus device.\\nThis function reads a specified number of holding registers starting from a given address. item description **type** func **param** **ip**: The TCP IP address.<br>**addr**: The starting address for reading holding registers.<br>**size**: The number of holding registers to read.<br>**timeout_ms**: The timeout duration for the write operation.<br> A value of 1 makes the function block until the write is complete.<br> A value of 0 makes it non blocking.<br> A positive value specifies the maximum time (in milliseconds) to wait.<br>**port**: The TCP port. A value of 1 signifies that the default port<br>from the constructor will be applied.<br> **return** std::vector<uint16_t>/list[int] A vector containing the read holding register values. **static** False > C++ defination code: > ```cpp > std::vector<uint16_t> read_holding_registers(const std::string ip, const uint32_t addr, > const uint32_t size, const int timeout_ms 1, > const int port 1) > ``` #### write\\_holding\\_registers {#write\\_holding\\_registers 2} ```python def write_holding_registers(self, ip: str, data: list[int], addr: int, timeout_ms: int 1, port: int 1) > int ``` Writes values to holding registers on the Modbus device.\\nThis function writes the specified data to the holding registers starting from a given address. item description **type** func **param** **ip**: The TCP IP address.<br>**data**: A vector containing the values to write to holding registers.<br>**addr**: The starting address for writing holding registers.<br>**timeout_ms**: The timeout duration for the write operation.<br> A value of 1 makes the function block until the write is complete.<br> A value of 0 makes it non blocking.<br> A positive value specifies the maximum time (in milliseconds) to wait.<br>**port**: The TCP port. A value of 1 signifies that the default port<br>from the constructor will be applied.<br> **return** int Returns the number of bytes written on success, or a value less than 0 on failure. **static** False > C++ defination code: > ```cpp > int write_holding_registers(const std::string ip, const std::vector<uint16_t>& data, > const uint32_t addr, const int timeout_ms 1, > const int port 1) > ```"},"/maixpy/api/maix/tensor.html":{"title":"maix.tensor","content":" title: maix.tensor maix.tensor module > You can use `maix.tensor` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### DType {#DType} Tensor data types item describe **values** **UINT8**: <br>**INT8**: <br>**UINT16**: <br>**INT16**: <br>**UINT32**: <br>**INT32**: <br>**FLOAT16**: <br>**FLOAT32**: <br>**FLOAT64**: <br>**BOOL**: <br>**DTYPE_MAX**: <br> > C++ defination code: > ```cpp > enum DType > { > UINT8 0, > INT8, > UINT16, > INT16, > UINT32, > INT32, > FLOAT16, > FLOAT32, > FLOAT64, > BOOL, > // STRING, > // OBJECT, > DTYPE_MAX > } > ``` ## Variable {#Variable} ### dtype\\_size {#dtype\\_size} Tensor data type size in bytes item description **attention** It's a copy of this variable in MaixPy,<br>so change it in C++ (e.g. update var in hello function) will not take effect the var inMaixPy.<br>So we add const for this var to avoid this mistake. **value** **{<br> 1, // UINT8<br> 1, // INT8<br> 2, // UINT16<br> 2, // INT16<br> 4, // UINT32<br> 4, // INT32<br> 2, // FLOAT16<br> 4, // FLOAT32<br> 8, // FLOAT64<br> 1, // BOOL<br> // 1, // STRING<br> // 1, // OBJECT<br> 0<br> }** **readonly** True > C++ defination code: > ```cpp > const std::vector<int> dtype_size { > 1, // UINT8 > 1, // INT8 > 2, // UINT16 > 2, // INT16 > 4, // UINT32 > 4, // INT32 > 2, // FLOAT16 > 4, // FLOAT32 > 8, // FLOAT64 > 1, // BOOL > // 1, // STRING > // 1, // OBJECT > 0 > } > ``` ### dtype\\_name {#dtype\\_name} Tensor data type name item description **value** **{<br> \"uint8\",<br> \"int8\",<br> \"uint16\",<br> \"int16\",<br> \"uint32\",<br> \"int32\",<br> \"float16\",<br> \"float32\",<br> \"float64\",<br> \"bool\",<br> // \"string\",<br> // \"object\",<br> \"invalid\"<br> }** **readonly** True > C++ defination code: > ```cpp > const std::vector<std::string> dtype_name { > \"uint8\", > \"int8\", > \"uint16\", > \"int16\", > \"uint32\", > \"int32\", > \"float16\", > \"float32\", > \"float64\", > \"bool\", > // \"string\", > // \"object\", > \"invalid\" > } > ``` ## Function {#Function} ### tensor\\_from\\_numpy\\_float32 {#tensor\\_from\\_numpy\\_float32} ```python def tensor_from_numpy_float32(array: numpy.ndarray[numpy.float32], copy: bool True) > Tensor ``` float32 type numpy ndarray object to tensor.Tensor object. item description **param** **array**: numpy array object.<br>**copy**: if true, will alloc new buffer and copy data, else will directly use array's data buffer, default true.<br>Use this arg carefully, when set to false, ther array MUST keep alive until we don't use the return tensor of this func, or will cause program crash.<br> **return** tensor.Tensor object. > C++ defination code: > ```cpp > tensor::Tensor *tensor_from_numpy_float32(py::array_t<float, py::array::c_style> array, bool copy true) > ``` ### tensor\\_from\\_numpy\\_uint8 {#tensor\\_from\\_numpy\\_uint8} ```python def tensor_from_numpy_uint8(array: numpy.ndarray[numpy.uint8], copy: bool True) > Tensor ``` uint8 type numpy ndarray object to tensor.Tensor object. item description **param** **array**: numpy array object.<br>**copy**: if true, will alloc new buffer and copy data, else will directly use array's data buffer, default true.<br>Use this arg carefully, when set to false, ther array MUST keep alive until we don't use the return tensor of this func, or will cause program crash.<br> **return** tensor.Tensor object. > C++ defination code: > ```cpp > tensor::Tensor *tensor_from_numpy_uint8(py::array_t<uint8_t, py::array::c_style> array, bool copy true) > ``` ### tensor\\_from\\_numpy\\_int8 {#tensor\\_from\\_numpy\\_int8} ```python def tensor_from_numpy_int8(array: numpy.ndarray[numpy.int8], copy: bool True) > Tensor ``` int8 type numpy ndarray object to tensor.Tensor object. item description **param** **array**: numpy array object.<br>**copy**: if true, will alloc new buffer and copy data, else will directly use array's data buffer, default true.<br>Use this arg carefully, when set to false, ther array MUST keep alive until we don't use the return tensor of this func, or will cause program crash.<br> **return** tensor.Tensor object. > C++ defination code: > ```cpp > tensor::Tensor *tensor_from_numpy_int8(py::array_t<int8_t, py::array::c_style> array, bool copy true) > ``` ### tensor\\_to\\_numpy\\_float32 {#tensor\\_to\\_numpy\\_float32} ```python def tensor_to_numpy_float32(t: Tensor, copy: bool True) > numpy.ndarray[numpy.float32] ``` tensor.Tensor object to float32 type numpy ndarray object. item description **param** **t**: tensor.Tensor object.<br>**copy**: Whether alloc new Tensor and copy data or not,<br>if not copy, array object will directly use arg's data buffer, will faster but change array will affect arg's data, default true.<br> **return** numpy array object > C++ defination code: > ```cpp > py::array_t<float, py::array::c_style> tensor_to_numpy_float32(tensor::Tensor *t, bool copy true) > ``` ### tensor\\_to\\_numpy\\_uint8 {#tensor\\_to\\_numpy\\_uint8} ```python def tensor_to_numpy_uint8(t: Tensor, copy: bool True) > numpy.ndarray[numpy.uint8] ``` tensor.Tensor object to int8 type numpy ndarray object. item description **param** **t**: tensor.Tensor object.<br>**copy**: Whether alloc new Tensor and copy data or not,<br>if not copy, array object will directly use arg's data buffer, will faster but change array will affect arg's data, default true.<br> **return** numpy array object > C++ defination code: > ```cpp > py::array_t<uint8_t, py::array::c_style> tensor_to_numpy_uint8(tensor::Tensor *t, bool copy true) > ``` ### tensor\\_to\\_numpy\\_int8 {#tensor\\_to\\_numpy\\_int8} ```python def tensor_to_numpy_int8(t: Tensor, copy: bool True) > numpy.ndarray[numpy.int8] ``` tensor.Tensor object to int8 type numpy ndarray object. item description **param** **t**: tensor.Tensor object.<br>**copy**: Whether alloc new Tensor and copy data or not,<br>if not copy, array object will directly use arg's data buffer, will faster but change array will affect arg's data, default true.<br> **return** numpy array object > C++ defination code: > ```cpp > py::array_t<int8_t, py::array::c_style> tensor_to_numpy_int8(tensor::Tensor *t, bool copy true) > ``` ## Class {#Class} ### Tensor {#Tensor} Tensor class > C++ defination code: > ```cpp > class Tensor > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, shape: list[int], dtype: DType) > None ``` Tensor constructor item description **type** func **param** **shape**: tensor shape, a int list<br>**dtype**: tensor element data type, see DType of this module<br> **static** False > C++ defination code: > ```cpp > Tensor(std::vector<int> shape, tensor::DType dtype) > ``` #### to\\_str {#to\\_str} ```python def to_str(self) > str ``` To string item description **type** func **static** False > C++ defination code: > ```cpp > std::string to_str() > ``` #### \\_\\_str\\_\\_ {#\\_\\_str\\_\\_} ```python def __str__(self) > str ``` To string item description **type** func **static** False > C++ defination code: > ```cpp > std::string __str__() > ``` #### shape {#shape} ```python def shape(self) > list[int] ``` get tensor shape item description **type** func **return** tensor shape, a int list **static** False > C++ defination code: > ```cpp > std::vector<int> shape() > ``` #### expand\\_dims {#expand\\_dims} ```python def expand_dims(self, axis: int) > None ``` expand tensor shape item description **type** func **param** **axis**: axis to expand<br> **static** False > C++ defination code: > ```cpp > void expand_dims(int axis) > ``` #### reshape {#reshape} ```python def reshape(self, shape: list[int]) > None ``` reshape tensor shape, if size not match, it will throw an err::Exception item description **type** func **param** **shape**: new shape<br> **static** False > C++ defination code: > ```cpp > void reshape(std::vector<int> shape) > ``` #### flatten {#flatten} ```python def flatten(self) > None ``` Flatten tensor shape to 1D item description **type** func **static** False > C++ defination code: > ```cpp > void flatten() > ``` #### dtype {#dtype 2} ```python def dtype(self) > DType ``` get tensor data type item description **type** func **return** tensor data type, see DType of this module **static** False > C++ defination code: > ```cpp > tensor::DType dtype() > ``` #### to\\_float\\_list {#to\\_float\\_list} ```python def to_float_list(self) > list[float] ``` get tensor data and return a list item description **type** func **return** list type data **static** False > C++ defination code: > ```cpp > std::valarray<float>* to_float_list() > ``` #### argmax {#argmax} ```python def argmax(self, axis: int 65535) > Tensor ``` argmax of tensor item description **type** func **param** **axis**: By default, the index is into the flattened array, otherwise along the specified axis., wrong axis will throw an err::Exception<br> **return** argmax result, you need to delete it after use in C++. **static** False > C++ defination code: > ```cpp > tensor::Tensor *argmax(int axis 0xffff) > ``` #### argmax1 {#argmax1} ```python def argmax1(self) > int ``` argmax1, flattened data max index item description **type** func **return** argmax result, int type **static** False > C++ defination code: > ```cpp > int argmax1() > ``` ### Tensors {#Tensors} Tensors > C++ defination code: > ```cpp > class Tensors > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 2} ```python def __init__(self) > None ``` Constructor of Tensors item description **type** func **static** False > C++ defination code: > ```cpp > Tensors() > ``` #### add\\_tensor {#add\\_tensor} ```python def add_tensor(self, key: str, tensor: Tensor, copy: bool, auto_delete: bool) > None ``` Add tensor item description **type** func **static** False > C++ defination code: > ```cpp > void add_tensor(const std::string &key, tensor::Tensor *tensor, bool copy, bool auto_delete) > ``` #### rm\\_tensor {#rm\\_tensor} ```python def rm_tensor(self, key: str) > None ``` Remove tensor item description **type** func **static** False > C++ defination code: > ```cpp > void rm_tensor(const std::string &key) > ``` #### clear {#clear} ```python def clear(self) > None ``` Clear tensors item description **type** func **static** False > C++ defination code: > ```cpp > void clear() > ``` #### get\\_tensor {#get\\_tensor} ```python def get_tensor(self, key: str) > Tensor ``` Get tensor by key item description **type** func **static** False > C++ defination code: > ```cpp > tensor::Tensor &get_tensor(const std::string &key) > ``` #### \\_\\_getitem\\_\\_ {#\\_\\_getitem\\_\\_} ```python def __getitem__(self, key: str) > Tensor ``` Operator [] item description **type** func **static** False > C++ defination code: > ```cpp > tensor::Tensor &operator[](const std::string &key) > ``` #### \\_\\_len\\_\\_ {#\\_\\_len\\_\\_} ```python def __len__(self) > int ``` Size item description **type** func **static** False > C++ defination code: > ```cpp > size_t size() > ``` #### keys {#keys} ```python def keys(self) > list[str] ``` Get names item description **type** func **static** False > C++ defination code: > ```cpp > std::vector<std::string> keys() > ``` #### tensors {#tensors 2} Tensors data, dict type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::map<std::string, tensor::Tensor*> tensors > ``` ### Vector3f {#Vector3f} Vector3 float type. > C++ defination code: > ```cpp > class Vector3f : public Vector3<float> // we use class for we want to generate maixpy API, and the tool not suppoort using yet. > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 3} ```python def __init__(self, x0: float, y0: float, z0: float) > None ``` Construct Vector3f with 3 variables. item description **type** func **static** False > C++ defination code: > ```cpp > Vector3f(float x0, float y0, float z0) > ``` #### x {#x} member x. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float x > ``` #### y {#y} member y. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float y > ``` #### z {#z} member z. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float z > ``` ### Vector3i32 {#Vector3i32} Vector3 int32_t type. > C++ defination code: > ```cpp > class Vector3i32 : public Vector3<int32_t> // we use class for we want to generate maixpy API, and the tool not suppoort using yet. > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 4} ```python def __init__(self, x0: int, y0: int, z0: int) > None ``` Construct Vector3i32 with 3 variables. item description **type** func **static** False > C++ defination code: > ```cpp > Vector3i32(int32_t x0, int32_t y0, int32_t z0) > ``` #### x {#x 2} member x. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int32_t x > ``` #### y {#y 2} member y. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int32_t y > ``` #### z {#z 2} member z. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int32_t z > ``` ### Vector3u32 {#Vector3u32} Vector3 uint32_t type. > C++ defination code: > ```cpp > class Vector3u32 : public Vector3<uint32_t> // we use class for we want to generate maixpy API, and the tool not suppoort using yet. > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 5} ```python def __init__(self, x0: int, y0: int, z0: int) > None ``` Construct Vector3u32 with 3 variables. item description **type** func **static** False > C++ defination code: > ```cpp > Vector3u32(uint32_t x0, uint32_t y0, uint32_t z0) > ``` #### x {#x 3} member x. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > uint32_t x > ``` #### y {#y 3} member y. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > uint32_t y > ``` #### z {#z 3} member z. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > uint32_t z > ``` ### Vector3i16 {#Vector3i16} Vector3 int16 type. > C++ defination code: > ```cpp > class Vector3i16 : public Vector3<int16_t> // we use class for we want to generate maixpy API, and the tool not suppoort using yet. > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 6} ```python def __init__(self, x0: int, y0: int, z0: int) > None ``` Construct Vector3i16 with 3 variables. item description **type** func **static** False > C++ defination code: > ```cpp > Vector3i16(int16_t x0, int16_t y0, int16_t z0) > ``` #### x {#x 4} member x. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int16_t x > ``` #### y {#y 4} member y. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int16_t y > ``` #### z {#z 4} member z. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int16_t z > ``` ### Vector3u16 {#Vector3u16} Vector3 uint16 type. > C++ defination code: > ```cpp > class Vector3u16 : public Vector3<uint16_t> // we use class for we want to generate maixpy API, and the tool not suppoort using yet. > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 7} ```python def __init__(self, x0: int, y0: int, z0: int) > None ``` Construct Vector3u16 with 3 variables. item description **type** func **static** False > C++ defination code: > ```cpp > Vector3u16(uint16_t x0, uint16_t y0, uint16_t z0) > ``` #### x {#x 5} member x. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > uint16_t x > ``` #### y {#y 5} member y. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > uint16_t y > ``` #### z {#z 5} member z. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > uint16_t z > ```"},"/maixpy/api/maix/i18n.html":{"title":"maix.i18n","content":" title: maix.i18n maix.i18n module > You can use `maix.i18n` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ## Variable {#Variable} ### locales {#locales} i18n locales list item description **value** **{<br> \"en\",<br> \"zh\",<br> \"zh tw\",<br> \"ja\"}** **readonly** False > C++ defination code: > ```cpp > static std::vector<std::string> locales { > \"en\", > \"zh\", > \"zh tw\", > \"ja\"} > ``` ### names {#names} i18n language names list item description **value** **{<br> \"English\",<br> \"简体中文\",<br> \"繁體中文\",<br> \"日本語\"}** **readonly** True > C++ defination code: > ```cpp > const static std::vector<std::string> names { > \"English\", > \"简体中文\", > \"繁體中文\", > \"日本語\"} > ``` ## Function {#Function} ### get\\_locale {#get\\_locale} ```python def get_locale() > str ``` Get system config of locale. item description **return** language locale, e.g. en, zh, zh_CN, zh_TW, etc. > C++ defination code: > ```cpp > string get_locale() > ``` ### get\\_language\\_name {#get\\_language\\_name} ```python def get_language_name() > str ``` Get system config of language name. item description **return** language name, e.g. English, 简体中文, 繁體中文, etc. > C++ defination code: > ```cpp > string get_language_name() > ``` ### load\\_trans\\_yaml {#load\\_trans\\_yaml} ```python def load_trans_yaml(locales_dir: str) > dict[str, dict[str, str]] ``` Load translations from yaml files. item description **param** **locales_dir**: translation yaml files directory.<br> **return** A dict contains all translations, e.g. {\"zh\":{\"hello\": \"你好\"}, \"en\":{\"hello\": \"hello\"}}, you should delete it after use in C++. > C++ defination code: > ```cpp > const std::map<string, std::map<string, string>> *load_trans_yaml(const std::string &locales_dir) > ``` ## Class {#Class} ### Trans {#Trans} Translate helper class. > C++ defination code: > ```cpp > class Trans > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, locales_dict: dict[str, dict[str, str]] {}) > None ``` Translate helper class constructor.\\nBy default locale is get by `i18n.get_locale()` function which set by system settings.\\nBut you can also manually set by `set_locale` function temporarily. item description **type** func **param** **locales_dict**: locales dict, e.g. {\"zh\": {\"Confirm\": \"确认\", \"OK\": \"好的\"}, \"en\": {\"Confirm\": \"Confirm\", \"OK\": \"OK\"}}<br> **static** False > C++ defination code: > ```cpp > Trans(const std::map<string, const std::map<string, string>> &locales_dict std::map<string, const std::map<string, string>>()) > ``` #### load {#load} ```python def load(self, locales_dir: str) > maix.err.Err ``` Load translation from yaml files generated by `maixtool i18n` command. item description **type** func **param** **locales_dir**: the translation files directory.<br> **return** err.Err type, no error will return err.Err.ERR_NONE. **static** False > C++ defination code: > ```cpp > err::Err load(const std::string &locales_dir) > ``` #### update\\_dict {#update\\_dict} ```python def update_dict(self, dict: dict[str, dict[str, str]]) > maix.err.Err ``` Update translation dict. item description **type** func **param** **dict**: the new translation dict.<br> **return** err.Err type, no error will return err.Err.ERR_NONE. **static** False > C++ defination code: > ```cpp > err::Err update_dict(const std::map<std::string, const std::map<std::string, std::string>> &dict) > ``` #### tr {#tr} ```python def tr(self, key: str, locale: str '') > str ``` Translate string by key. item description **type** func **param** **key**: string key, e.g. \"Confirm\"<br>**locale**: locale name, if not assign, use default locale set by system settings or set_locale function.<br> **return** translated string, if find translation, return it, or return key, e.g. \"确认\", \"Confirm\", etc. **static** False > C++ defination code: > ```cpp > string tr(const string &key, const string locale \"\") > ``` #### set\\_locale {#set\\_locale} ```python def set_locale(self, locale: str) > None ``` Set locale temporarily, will not affect system settings. item description **type** func **param** **locale**: locale name, e.g. \"zh\", \"en\", etc. @see maix.i18n.locales<br> **static** False > C++ defination code: > ```cpp > void set_locale(const string &locale) > ``` #### get\\_locale {#get\\_locale 2} ```python def get_locale(self) > str ``` Get current locale. item description **type** func **return** locale name, e.g. \"zh\", \"en\", etc. @see maix.i18n.locales **static** False > C++ defination code: > ```cpp > string get_locale() > ```"},"/maixpy/api/maix/ahrs.html":{"title":"maix.ahrs","content":" title: maix.ahrs maix.ahrs module > You can use `maix.ahrs` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ## Variable {#Variable} ### PI {#PI} Math PI item description **value** **3.14159265358979323846f** **readonly** True > C++ defination code: > ```cpp > const float PI 3.14159265358979323846f > ``` ### RAD2DEG {#RAD2DEG} angle unit radian to degree. item description **value** **180.0f / PI** **readonly** True > C++ defination code: > ```cpp > const float RAD2DEG 180.0f / PI > ``` ### DEG2RAD {#DEG2RAD} angle unit degree to radian. item description **value** **PI / 180.0f** **readonly** True > C++ defination code: > ```cpp > const float DEG2RAD PI / 180.0f > ``` ## Function {#Function} ## Class {#Class} ### MahonyAHRS {#MahonyAHRS} class MahonyAHRS for Attitude Estimation from IMU data, a Complementary Filter,\\nsupport accelerometer, gyroscope and magnetometer fusion. > C++ defination code: > ```cpp > class MahonyAHRS > ``` #### kp {#kp} P of PI controller, a larger P (proportional gain) leads to faster response,\\nbut it increases the risk of overshoot and oscillation. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float kp > ``` #### ki {#ki} I of PI controller, a larger I (integral gain) helps to eliminate steady state errors more quickly,\\nbut it can accumulate error over time, potentially causing instability or slow drift. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float ki > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, kp: float, ki: float) > None ``` class MahonyAHRS constructor. item description **type** func **param** **kp**: P of PI controller, a larger P (proportional gain) leads to faster response,<br>but it increases the risk of overshoot and oscillation.<br>**ki**: I of PI controller, a larger I (integral gain) helps to eliminate steady state errors more quickly,<br>but it can accumulate error over time, potentially causing instability or slow drift.<br> **static** False > C++ defination code: > ```cpp > MahonyAHRS(float kp,float ki) > ``` #### init {#init} ```python def init(self, ax: float, ay: float, az: float, mx: float 0, my: float 0, mz: float 0) > None ``` Initialize by accelerometer and magnetometer(optional).\\nIf you not call this method mannually, get_angle and update method will automatically call it. item description **type** func **param** **ax**: z axis of accelerometer, unit is g or raw data.<br>**ay**: y axis of accelerometer, unit is g or raw data.<br>**mx**: x axis of magnetometer, unit is uT or raw data, mx, my, mz all 0 means not use magnetometer.<br>**my**: y axis of magnetometer, unit is uT or raw data, mx, my, mz all 0 means not use magnetometer.<br>**mz**: z axis of magnetometer, unit is uT or raw data, mx, my, mz all 0 means not use magnetometer.<br> **static** False > C++ defination code: > ```cpp > void init(float ax, float ay, float az, float mx 0, float my 0, float mz 0) > ``` #### update {#update} ```python def update(self, ax: float, ay: float, az: float, gx: float, gy: float, gz: float, mx: float, my: float, mz: float, dt: float) > None ``` Update angles by accelerometer, gyroscope and magnetometer(optional).\\nget_angle method will automatically call it. item description **type** func **param** **ax**: z axis of gyroscope, unit is rad/s.<br>**ay**: y axis of gyroscope, unit is rad/s.<br>**mx**: x axis of magnetometer, unit is uT or raw data, mx, my, mz all 0 means not use magnetometer.<br>**my**: y axis of magnetometer, unit is uT or raw data, mx, my, mz all 0 means not use magnetometer.<br>**mz**: z axis of magnetometer, unit is uT or raw data, mx, my, mz all 0 means not use magnetometer.<br>**dt**: Delta time between two times call update method.<br> **static** False > C++ defination code: > ```cpp > void update(float ax, float ay, float az, float gx, float gy, float gz, float mx, float my, float mz, float dt) > ``` #### get\\_angle {#get\\_angle} ```python def get_angle(self, acc: maix.tensor.Vector3f, gyro: maix.tensor.Vector3f, mag: maix.tensor.Vector3f, dt: float, radian: bool False) > maix.tensor.Vector3f ``` Get angle by mahony complementary filter, will automatically call update method,\\nand automatically call init in first time. item description **type** func **param** **acc**: accelerometer data, unit is g or raw data. maix.vector.Vector3f type.<br>**gyro**: gyroscope data, unit can be rad/s or degree/s, if rad/s, arg radian should be true. maix.vector.Vector3f type.<br>**mag**: magnetometer data, optional, if no magnetometer, set all value to 0. maix.vector.Vector3f type.<br>**dt**: delta T of two time call get_anle, unit is second, float type.<br>**radian**: if gyro's unit is rad/s, set this arg to true, degree/s set to false.<br> **return** rotation angle data, maix.vector.Vector3f type. **static** False > C++ defination code: > ```cpp > tensor::Vector3f get_angle(tensor::Vector3f acc, tensor::Vector3f gyro, tensor::Vector3f mag, float dt, bool radian false) > ``` #### reset {#reset} ```python def reset(self) > None ``` reset to not initialized status. item description **type** func **static** False > C++ defination code: > ```cpp > void reset() > ```"},"/maixpy/api/maix/nn/F.html":{"title":"maix.nn.F","content":" title: maix.nn.F maix.nn.F module > You can use `maix.nn.F` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ## Variable {#Variable} ## Function {#Function} ### softmax {#softmax} ```python def softmax(tensor: maix.tensor.Tensor, replace: bool) > maix.tensor.Tensor ``` Softmax, only support 1D tensor, multi dimension tensor will be treated as 1D tensor item description **param** **tensor**: input tensor<br>**replace**: change input tensor data directly, if not, will create a new tensor<br> **throw** If arg error, will raise err.Exception error **return** output tensor, if arg replace is true, return the arg tensor's address.<br>If not replace, return a new object, so In C++, you should delete it manually in this case! > C++ defination code: > ```cpp > tensor::Tensor *softmax(tensor::Tensor *tensor, bool replace) > ``` ## Class {#Class}"},"/maixpy/api/maix/network.html":{"title":"maix.network","content":" title: maix.network maix.network module > You can use `maix.network` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} module brief [wifi](./network/wifi.html) maix.network.wifi module ## Enum {#Enum} ## Variable {#Variable} ## Function {#Function} ### have\\_network {#have\\_network} ```python def have_network() > bool ``` Return if device have network(WiFi/Eth etc.) item description **return** True if have network, else False. > C++ defination code: > ```cpp > bool have_network() > ``` ## Class {#Class}"},"/maixpy/api/maix/tracker.html":{"title":"maix.tracker","content":" title: maix.tracker maix.tracker module > You can use `maix.tracker` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ## Variable {#Variable} ## Function {#Function} ## Class {#Class} ### ByteTracker {#ByteTracker} tracker.ByteTracker class > C++ defination code: > ```cpp > class ByteTracker > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, max_lost_buff_num: int 60, track_thresh: float 0.5, high_thresh: float 0.6, match_thresh: float 0.8, max_history: int 20) > None ``` tracker.ByteTracker class constructor item description **type** func **param** **max_lost_buff_num**: the frames for keep lost tracks.<br>**track_thresh**: tracking confidence threshold.<br>**high_thresh**: threshold to add to new track.<br>**match_thresh**: matching threshold for tracking, e.g. one object in two frame iou < match_thresh we think they are the same obj.<br>**max_history**: max tack's position history length.<br> **static** False > C++ defination code: > ```cpp > ByteTracker(const int &max_lost_buff_num 60, > const float &track_thresh 0.5, > const float &high_thresh 0.6, > const float &match_thresh 0.8, > const int &max_history 20) > ``` #### update {#update} ```python def update(self, objs: list[...]) > list[...] ``` update tracks according to current detected objects. item description **type** func **static** False > C++ defination code: > ```cpp > std::vector<tracker::Track> update(const std::vector<tracker::Object> &objs) > ``` ### Object {#Object} tracker.Object class > C++ defination code: > ```cpp > class Object > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 2} ```python def __init__(self, x: int, y: int, w: int, h: int, class_id: int, score: float) > None ``` tracker.Object class constructor item description **type** func **static** False > C++ defination code: > ```cpp > Object(const int &x, const int &y, const int &w, const int &h, const int &class_id, const float &score) > ``` #### x {#x} position x attribute. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int x > ``` #### y {#y} position y attribute. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int y > ``` #### w {#w} position rectangle width. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int w > ``` #### h {#h} position rectangle height. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int h > ``` #### class\\_id {#class\\_id} object class id, int type. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int class_id > ``` #### score {#score} object score(prob). item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float score > ``` ### Track {#Track} tracker.Track class > C++ defination code: > ```cpp > class Track > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 3} ```python def __init__(self, id: int, score: float, lost: bool, start_frame_id: int, frame_id: int) > None ``` tracker.Track class constructor item description **type** func **static** False > C++ defination code: > ```cpp > Track(const size_t &id, const float &score, const bool &lost, const size_t &start_frame_id, const size_t &frame_id) > ``` #### id {#id} track id. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > size_t id > ``` #### score {#score 2} track score(prob). item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float score > ``` #### lost {#lost} whether this track lost. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > bool lost > ``` #### start\\_frame\\_id {#start\\_frame\\_id} track start frame id. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > size_t start_frame_id > ``` #### frame\\_id {#frame\\_id} track current frame id. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > size_t frame_id > ``` #### history {#history} track position history, the last one is latest position. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::deque<tracker::Object> history > ```"},"/maixpy/api/maix/peripheral.html":{"title":"maix.peripheral","content":" title: maix.peripheral Chip's peripheral driver > You can use `maix.peripheral` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} module brief [pwm](./peripheral/pwm.html) maix.peripheral.pwm module [timer](./peripheral/timer.html) maix.peripheral.timer module [pinmap](./peripheral/pinmap.html) maix.peripheral.pinmap module [gpio](./peripheral/gpio.html) maix.peripheral.gpio module [spi](./peripheral/spi.html) maix.peripheral.spi module [key](./peripheral/key.html) maix.peripheral.key module [i2c](./peripheral/i2c.html) maix.peripheral.i2c module [adc](./peripheral/adc.html) maix.peripheral.adc module [uart](./peripheral/uart.html) maix uart peripheral driver [hid](./peripheral/hid.html) maix.peripheral.hid module [wdt](./peripheral/wdt.html) maix.peripheral.wdt module ## Enum {#Enum} ## Variable {#Variable} ## Function {#Function} ## Class {#Class}"},"/maixpy/api/maix/thread.html":{"title":"maix.thread","content":" title: maix.thread maix.thread module > You can use `maix.thread` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ## Variable {#Variable} ## Function {#Function} ## Class {#Class} ### Thread {#Thread} thread class > C++ defination code: > ```cpp > class Thread > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, func: typing.Callable[[capsule], None], args: capsule None) > None ``` create thread item description **type** func **param** **func**: direction [in], thread function, one `args` parameter, void* type, no return value<br>**args**: direction [in], thread function parameter<br> **static** False > C++ defination code: > ```cpp > Thread(std::function<void(void *)> func, void *args nullptr) > ``` #### join {#join} ```python def join(self) > None ``` wait thread exit item description **type** func **static** False > C++ defination code: > ```cpp > void join() > ``` #### detach {#detach} ```python def detach(self) > None ``` detach thread, detach will auto start thread and you can't use join anymore. item description **type** func **static** False > C++ defination code: > ```cpp > void detach() > ``` #### joinable {#joinable} ```python def joinable(self) > bool ``` Check if thread is joinable item description **type** func **return** true if thread is joinable **static** False > C++ defination code: > ```cpp > bool joinable() > ```"},"/maixpy/api/maix/image.html":{"title":"maix.image","content":" title: maix.image maix.image module, image related definition and functions > You can use `maix.image` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### Format {#Format} Image formats item describe **attention** for MaixPy firmware developers, update this enum will also need to update the fmt_size and fmt_names too !!! **values** **FMT_RGB888**: RGBRGB...RGB, R at the lowest address<br>**FMT_BGR888**: BGRBGR...BGR, B at the lowest address<br>**FMT_RGBA8888**: RGBARGBA...RGBA, R at the lowest address<br>**FMT_BGRA8888**: BGRABGRA...BGRA, B at the lowest address<br>**FMT_RGB565**: <br>**FMT_BGR565**: <br>**FMT_YUV422SP**: YYY...UVUVUV...UVUV<br>**FMT_YUV422P**: YYY...UUU...VVV<br>**FMT_YVU420SP**: YYY...VUVUVU...VUVU, NV21<br>**FMT_YUV420SP**: YYY...UVUVUV...UVUV, NV12<br>**FMT_YVU420P**: YYY...VVV...UUU<br>**FMT_YUV420P**: YYY...UUU...VVV<br>**FMT_GRAYSCALE**: <br>**FMT_BGGR6**: 6 bit Bayer format with a BGGR pattern.<br>**FMT_GBRG6**: 6 bit Bayer format with a GBRG pattern.<br>**FMT_GRBG6**: 6 bit Bayer format with a GRBG pattern.<br>**FMT_RGGB6**: 6 bit Bayer format with a RGGB pattern.<br>**FMT_BGGR8**: 8 bit Bayer format with a BGGR pattern.<br>**FMT_GBRG8**: 8 bit Bayer format with a GBRG pattern.<br>**FMT_GRBG8**: 8 bit Bayer format with a GRBG pattern.<br>**FMT_RGGB8**: 8 bit Bayer format with a RGGB pattern.<br>**FMT_BGGR10**: 10 bit Bayer format with a BGGR pattern.<br>**FMT_GBRG10**: 10 bit Bayer format with a GBRG pattern.<br>**FMT_GRBG10**: 10 bit Bayer format with a GRBG pattern.<br>**FMT_RGGB10**: 10 bit Bayer format with a RGGB pattern.<br>**FMT_BGGR12**: 12 bit Bayer format with a BGGR pattern.<br>**FMT_GBRG12**: 12 bit Bayer format with a GBRG pattern.<br>**FMT_GRBG12**: 12 bit Bayer format with a GRBG pattern.<br>**FMT_RGGB12**: 12 bit Bayer format with a RGGB pattern.<br>**FMT_UNCOMPRESSED_MAX**: <br>**FMT_COMPRESSED_MIN**: <br>**FMT_JPEG**: <br>**FMT_PNG**: <br>**FMT_COMPRESSED_MAX**: <br>**FMT_INVALID**: format not valid<br> > C++ defination code: > ```cpp > enum Format > { > FMT_RGB888 0, // RGBRGB...RGB, R at the lowest address > FMT_BGR888, // BGRBGR...BGR, B at the lowest address > FMT_RGBA8888, // RGBARGBA...RGBA, R at the lowest address > FMT_BGRA8888, // BGRABGRA...BGRA, B at the lowest address > FMT_RGB565, > FMT_BGR565, > FMT_YUV422SP, // YYY...UVUVUV...UVUV > FMT_YUV422P, // YYY...UUU...VVV > FMT_YVU420SP, // YYY...VUVUVU...VUVU, NV21 > FMT_YUV420SP, // YYY...UVUVUV...UVUV, NV12 > FMT_YVU420P, // YYY...VVV...UUU > FMT_YUV420P, // YYY...UUU...VVV > FMT_GRAYSCALE, > FMT_BGGR6, // 6 bit Bayer format with a BGGR pattern. > FMT_GBRG6, // 6 bit Bayer format with a GBRG pattern. > FMT_GRBG6, // 6 bit Bayer format with a GRBG pattern. > FMT_RGGB6, // 6 bit Bayer format with a RGGB pattern. > FMT_BGGR8, // 8 bit Bayer format with a BGGR pattern. > FMT_GBRG8, // 8 bit Bayer format with a GBRG pattern. > FMT_GRBG8, // 8 bit Bayer format with a GRBG pattern. > FMT_RGGB8, // 8 bit Bayer format with a RGGB pattern. > FMT_BGGR10, // 10 bit Bayer format with a BGGR pattern. > FMT_GBRG10, // 10 bit Bayer format with a GBRG pattern. > FMT_GRBG10, // 10 bit Bayer format with a GRBG pattern. > FMT_RGGB10, // 10 bit Bayer format with a RGGB pattern. > FMT_BGGR12, // 12 bit Bayer format with a BGGR pattern. > FMT_GBRG12, // 12 bit Bayer format with a GBRG pattern. > FMT_GRBG12, // 12 bit Bayer format with a GRBG pattern. > FMT_RGGB12, // 12 bit Bayer format with a RGGB pattern. > FMT_UNCOMPRESSED_MAX, > > // compressed format below, not compressed should define upper > FMT_COMPRESSED_MIN, > FMT_JPEG, > FMT_PNG, > FMT_COMPRESSED_MAX, > > FMT_INVALID 0xFF // format not valid > } > ``` ### Fit {#Fit} Object fit method item describe **values** **FIT_NONE**: no object fit, keep original<br>**FIT_FILL**: width to new width, height to new height, may be stretch<br>**FIT_CONTAIN**: keep aspect ratio, fill blank area with black color<br>**FIT_COVER**: keep aspect ratio, crop image to fit new size<br>**FIT_MAX**: <br> > C++ defination code: > ```cpp > enum Fit > { > FIT_NONE 1, // no object fit, keep original > FIT_FILL 0, // width to new width, height to new height, may be stretch > FIT_CONTAIN, // keep aspect ratio, fill blank area with black color > FIT_COVER, // keep aspect ratio, crop image to fit new size > FIT_MAX > } > ``` ### ResizeMethod {#ResizeMethod} Resize method item describe **values** **NEAREST**: <br>**BILINEAR**: <br>**BICUBIC**: <br>**AREA**: <br>**LANCZOS**: <br>**HAMMING**: <br>**RESIZE_METHOD_MAX**: <br> > C++ defination code: > ```cpp > enum ResizeMethod > { > NEAREST 0, > BILINEAR, > BICUBIC, > AREA, > LANCZOS, > HAMMING, > RESIZE_METHOD_MAX > } > ``` ### ApriltagFamilies {#ApriltagFamilies} Family of apriltag item describe **values** **TAG16H5**: <br>**TAG25H7**: <br>**TAG25H9**: <br>**TAG36H10**: <br>**TAG36H11**: <br>**ARTOOLKIT**: <br> > C++ defination code: > ```cpp > enum ApriltagFamilies > { > TAG16H5 1, > TAG25H7 2, > TAG25H9 4, > TAG36H10 8, > TAG36H11 16, > ARTOOLKIT 32 > } > ``` ### TemplateMatch {#TemplateMatch} Template match method item describe **values** **SEARCH_EX**: Exhaustive search<br>**SEARCH_DS**: Diamond search<br> > C++ defination code: > ```cpp > enum TemplateMatch > { > SEARCH_EX, // Exhaustive search > SEARCH_DS, // Diamond search > } > ``` ### CornerDetector {#CornerDetector} CornerDetector class item describe **values** **CORNER_FAST**: <br>**CORNER_AGAST**: <br> > C++ defination code: > ```cpp > enum CornerDetector > { > CORNER_FAST, > CORNER_AGAST > } > ``` ### EdgeDetector {#EdgeDetector} EdgeDetector class item describe **values** **EDGE_CANNY**: <br>**EDGE_SIMPLE**: <br> > C++ defination code: > ```cpp > enum EdgeDetector > { > EDGE_CANNY, > EDGE_SIMPLE, > } > ``` ### FlipDir {#FlipDir} FlipDir item describe **values** **X**: <br>**Y**: <br>**XY**: <br> > C++ defination code: > ```cpp > enum class FlipDir > { > X, > Y, > XY > } > ``` ### QRCodeDecoderType {#QRCodeDecoderType} QRCode decode type class item describe **values** **QRCODE_DECODER_TYPE_ZBAR**: <br>**QRCODE_DECODER_TYPE_QUIRC**: <br>**QRCODE_DECODER_TYPE_ZXING**: <br> > C++ defination code: > ```cpp > enum class QRCodeDecoderType { > QRCODE_DECODER_TYPE_ZBAR, > QRCODE_DECODER_TYPE_QUIRC, > QRCODE_DECODER_TYPE_ZXING > } > ``` ### LineType {#LineType} Line type class item describe **values** **LINE_NORMAL**: <br>**LINE_CROSS**: <br>**LINE_T**: <br>**LINE_L**: <br> > C++ defination code: > ```cpp > enum class LineType { > LINE_NORMAL, > LINE_CROSS, > LINE_T, > LINE_L, > } > ``` ### CMap {#CMap} Image formats item describe **attention** for MaixPy firmware developers, update this enum will also need to update the fmt_size and fmt_names too !!! **values** **TURBO**: Google designed smooth, bright colormap; good Jet replacement for heatmaps<br>**VIRIDIS**: Default perceptually uniform colormap; colorblind friendly and widely recommended<br>**INFERNO**: High contrast, perceptually uniform; ideal for dark backgrounds and scientific data<br>**PLASMA**: Bright and visually appealing; perceptually uniform and colorblind friendly<br>**CIVIDIS**: Grayscale compatible and colorblind safe; designed for visual accessibility<br>**CUBEHELIX**: Perceptually uniform and printable in grayscale; spirals through color space<br>**MAGMA**: Dark background optimized; smooth gradient with good visibility in low light visuals<br>**TWILIGHT**: Cyclic gradient; useful for circular data such as angles or phase data<br>**TWILIGHT_SHIFTED**: Phase shifted version of Twilight; same use case but shifted zero point<br>**GREYS**: Monotonic black to white gradient; useful for basic grayscale visualization<br>**JET**: Classic but non uniform RGB colormap; visually vibrant but not perceptually linear<br>**COOLWARM**: Blue white red diverging map; ideal for visualizing deviation from a neutral center<br>**RDYBU**: Red white blue diverging map; suitable for highlighting opposing directions/values<br>**SET1**: High contrast colors; up to 9 distinct categories, ideal for class segmentation<br>**TAB10**: Matplotlib default for 10 category labeling; visually distinct and colorblind friendly<br>**TAB20**: Matplotlib default for 20 category labeling; visually distinct and colorblind friendly<br>**THERMAL_WHITE_HOT**: Hotter whiter; used thermal imaging mode due to its natural contrast.<br>**THERMAL_BLACK_HOT**: Hotter darker; Often used in security and tactical applications for better object detection.<br>**THERMAL_RED_HOT**: Hotter red，cooler areas dark； Emphasizes hotspots, useful for quick temperature anomaly detection.<br>**THERMAL_WHITE_HOT_SD**: White Hot SD (Smooth Detail): Enhanced White Hot with improved local contrast and smoother tone transitions.<br>Helps distinguish fine temperature differences in subtle thermal scenes.<br>**THERMAL_BLACK_HOT_SD**: Black Hot SD (Smooth Detail): Enhanced Black Hot with detail preserving smoothing and finer thermal gradients.<br>Improves readability of dark hot scenes with less visual noise.<br>**THERMAL_RED_HOT_SD**: Red Hot SD (Smooth Detail): Enhanced Red Hot with more gradual color changes and smoother heat spot highlighting.<br>Offers better heat trace visualization with reduced abrupt transitions.<br>**THERMAL_IRONBOW**: Ironbow: A classic thermal colormap that uses a smooth gradient from dark to bright (black → red → yellow → white).<br>Commonly used in industrial and medical thermography for better visualization.<br>**THERMAL_NIGHT**: Night: A low brightness thermal mode optimized for night operations or low light display environments.<br>Typically enhances visibility in high contrast night time scenarios.<br>**GITHUB_GREEN**: GitHub themed green based palette; custom usage such as contribution graphs<br>**MAX**: Total count of valid colormaps (not a colormap itself)<br> > C++ defination code: > ```cpp > enum class CMap > { > // Sequential (Perceptually uniform linear gradients) > TURBO 0, // Google designed smooth, bright colormap; good Jet replacement for heatmaps > VIRIDIS, // Default perceptually uniform colormap; colorblind friendly and widely recommended > INFERNO, // High contrast, perceptually uniform; ideal for dark backgrounds and scientific data > PLASMA, // Bright and visually appealing; perceptually uniform and colorblind friendly > CIVIDIS, // Grayscale compatible and colorblind safe; designed for visual accessibility > CUBEHELIX, // Perceptually uniform and printable in grayscale; spirals through color space > MAGMA, // Dark background optimized; smooth gradient with good visibility in low light visuals > TWILIGHT, // Cyclic gradient; useful for circular data such as angles or phase data > TWILIGHT_SHIFTED, // Phase shifted version of Twilight; same use case but shifted zero point > GREYS, // Monotonic black to white gradient; useful for basic grayscale visualization > > // Traditional (Legacy and visually distinct maps) > JET, // Classic but non uniform RGB colormap; visually vibrant but not perceptually linear > > // Diverging (Center out maps for relative differences) > COOLWARM, // Blue white red diverging map; ideal for visualizing deviation from a neutral center > RDYBU, // Red white blue diverging map; suitable for highlighting opposing directions/values > > // Qualitative (For categorical or class label data) > SET1, // High contrast colors; up to 9 distinct categories, ideal for class segmentation > TAB10, // Matplotlib default for 10 category labeling; visually distinct and colorblind friendly > TAB20, // Matplotlib default for 20 category labeling; visually distinct and colorblind friendly > > // thermal > THERMAL_WHITE_HOT, // Hotter whiter; used thermal imaging mode due to its natural contrast. > THERMAL_BLACK_HOT, // Hotter darker; Often used in security and tactical applications for better object detection. > THERMAL_RED_HOT, // Hotter red，cooler areas dark； Emphasizes hotspots, useful for quick temperature anomaly detection. > THERMAL_WHITE_HOT_SD, /* White Hot SD (Smooth Detail): Enhanced White Hot with improved local contrast and smoother tone transitions. > Helps distinguish fine temperature differences in subtle thermal scenes. > */ > THERMAL_BLACK_HOT_SD, /* Black Hot SD (Smooth Detail): Enhanced Black Hot with detail preserving smoothing and finer thermal gradients. > Improves readability of dark hot scenes with less visual noise. > */ > THERMAL_RED_HOT_SD, /* Red Hot SD (Smooth Detail): Enhanced Red Hot with more gradual color changes and smoother heat spot highlighting. > Offers better heat trace visualization with reduced abrupt transitions. > */ > THERMAL_IRONBOW, /* Ironbow: A classic thermal colormap that uses a smooth gradient from dark to bright (black → red → yellow → white). > Commonly used in industrial and medical thermography for better visualization. > */ > THERMAL_NIGHT, /* Night: A low brightness thermal mode optimized for night operations or low light display environments. > Typically enhances visibility in high contrast night time scenarios. > */ > > // Special / Custom > GITHUB_GREEN, // GitHub themed green based palette; custom usage such as contribution graphs > > MAX // Total count of valid colormaps (not a colormap itself) > } > ``` ## Variable {#Variable} ### fmt\\_size {#fmt\\_size} Image format size in bytes item description **attention** It's a copy of this variable in MaixPy,<br>so change it in C++ (e.g. update var in hello function) will not take effect the var inMaixPy.<br>So we add const for this var to avoid this mistake. **value** **{<br> 3,<br> 3,<br> 4,<br> 4,<br> 2,<br> 2,<br> 2,<br> 2,<br> 1.5,<br> 1.5,<br> 1.5,<br> 1.5,<br> 1, // grayscale<br> 0.75, // 6 bit Bayer format<br> 0.75, // 6 bit Bayer format<br> 0.75, // 6 bit Bayer format<br> 0.75, // 6 bit Bayer format<br> 1, // 8 bit Bayer format<br> 1, // 8 bit Bayer format<br> 1, // 8 bit Bayer format<br> 1, // 8 bit Bayer format<br> 1.25, // 10 bit Bayer format<br> 1.25, // 10 bit Bayer format<br> 1.25, // 10 bit Bayer format<br> 1.25, // 10 bit Bayer format<br> 1.5, // 12 bit Bayer format<br> 1.5, // 12 bit Bayer format<br> 1.5, // 12 bit Bayer format<br> 1.5, // 12 bit Bayer format<br> 0, // uncompereed_max<br> 0, // compressed_min<br> 1, // jpeg<br> 1, // png<br> 0, // compressed_max<br> 0 // invalid<br> }** **readonly** True > C++ defination code: > ```cpp > const std::vector<float> fmt_size { > 3, > 3, > 4, > 4, > 2, > 2, > 2, > 2, > 1.5, > 1.5, > 1.5, > 1.5, > 1, // grayscale > 0.75, // 6 bit Bayer format > 0.75, // 6 bit Bayer format > 0.75, // 6 bit Bayer format > 0.75, // 6 bit Bayer format > 1, // 8 bit Bayer format > 1, // 8 bit Bayer format > 1, // 8 bit Bayer format > 1, // 8 bit Bayer format > 1.25, // 10 bit Bayer format > 1.25, // 10 bit Bayer format > 1.25, // 10 bit Bayer format > 1.25, // 10 bit Bayer format > 1.5, // 12 bit Bayer format > 1.5, // 12 bit Bayer format > 1.5, // 12 bit Bayer format > 1.5, // 12 bit Bayer format > 0, // uncompereed_max > 0, // compressed_min > 1, // jpeg > 1, // png > 0, // compressed_max > 0 // invalid > } > ``` ### fmt\\_names {#fmt\\_names} Image format string.\\n!!Deprecated!! Please use format_name() function instead.\\nThis attribute will be removed in future. item description **value** **{<br> \"RGB888\",<br> \"BGR888\",<br> \"RGBA8888\",<br> \"BGRA8888\",<br> \"RGB565\",<br> \"BGR565\",<br> \"YUV422SP\",<br> \"YUV422P\",<br> \"YVU420SP\",<br> \"YUV420SP\",<br> \"YVU420P\",<br> \"YUV420P\",<br> \"GRAYSCALE\",<br> \"BGGR6\",<br> \"GBRG6\",<br> \"GRBG6\",<br> \"RG6B6\",<br> \"BGGR8\",<br> \"GBRG8\",<br> \"GRBG8\",<br> \"RG6B8\",<br> \"BGGR10\",<br> \"GBRG10\",<br> \"GRBG10\",<br> \"RG6B10\",<br> \"BGGR12\",<br> \"GBRG12\",<br> \"GRBG12\",<br> \"RG6B12\",<br> \"UNCOMPRESSED_MAX\",<br> \"COMPRESSED_MIN\",<br> \"JPEG\",<br> \"PNG\",<br> \"COMPRESSED_MAX\",<br> \"INVALID\"<br> }** **readonly** True > C++ defination code: > ```cpp > const std::vector<std::string> fmt_names { > \"RGB888\", > \"BGR888\", > \"RGBA8888\", > \"BGRA8888\", > \"RGB565\", > \"BGR565\", > \"YUV422SP\", > \"YUV422P\", > \"YVU420SP\", > \"YUV420SP\", > \"YVU420P\", > \"YUV420P\", > \"GRAYSCALE\", > \"BGGR6\", > \"GBRG6\", > \"GRBG6\", > \"RG6B6\", > \"BGGR8\", > \"GBRG8\", > \"GRBG8\", > \"RG6B8\", > \"BGGR10\", > \"GBRG10\", > \"GRBG10\", > \"RG6B10\", > \"BGGR12\", > \"GBRG12\", > \"GRBG12\", > \"RG6B12\", > \"UNCOMPRESSED_MAX\", > \"COMPRESSED_MIN\", > \"JPEG\", > \"PNG\", > \"COMPRESSED_MAX\", > \"INVALID\" > } > ``` ### COLOR\\_WHITE {#COLOR\\_WHITE} Predefined color white item description **value** **image::Color::from_rgb(255, 255, 255)** **readonly** True > C++ defination code: > ```cpp > const image::Color COLOR_WHITE image::Color::from_rgb(255, 255, 255) > ``` ### COLOR\\_BLACK {#COLOR\\_BLACK} Predefined color black item description **value** **image::Color::from_rgb(0, 0, 0)** **readonly** True > C++ defination code: > ```cpp > const image::Color COLOR_BLACK image::Color::from_rgb(0, 0, 0) > ``` ### COLOR\\_RED {#COLOR\\_RED} Predefined color red item description **value** **image::Color::from_rgb(255, 0, 0)** **readonly** True > C++ defination code: > ```cpp > const image::Color COLOR_RED image::Color::from_rgb(255, 0, 0) > ``` ### COLOR\\_GREEN {#COLOR\\_GREEN} Predefined color green item description **value** **image::Color::from_rgb(0, 255, 0)** **readonly** True > C++ defination code: > ```cpp > const image::Color COLOR_GREEN image::Color::from_rgb(0, 255, 0) > ``` ### COLOR\\_BLUE {#COLOR\\_BLUE} Predefined color blue item description **value** **image::Color::from_rgb(0, 0, 255)** **readonly** True > C++ defination code: > ```cpp > const image::Color COLOR_BLUE image::Color::from_rgb(0, 0, 255) > ``` ### COLOR\\_YELLOW {#COLOR\\_YELLOW} Predefined color yellow item description **value** **image::Color::from_rgb(255, 255, 0)** **readonly** True > C++ defination code: > ```cpp > const image::Color COLOR_YELLOW image::Color::from_rgb(255, 255, 0) > ``` ### COLOR\\_PURPLE {#COLOR\\_PURPLE} Predefined color purple item description **value** **image::Color::from_rgb(143, 0, 255)** **readonly** True > C++ defination code: > ```cpp > const image::Color COLOR_PURPLE image::Color::from_rgb(143, 0, 255) > ``` ### COLOR\\_ORANGE {#COLOR\\_ORANGE} Predefined color orange item description **value** **image::Color::from_rgb(255, 127, 0)** **readonly** True > C++ defination code: > ```cpp > const image::Color COLOR_ORANGE image::Color::from_rgb(255, 127, 0) > ``` ### COLOR\\_GRAY {#COLOR\\_GRAY} Predefined color gray item description **value** **image::Color::from_rgb(127, 127, 127)** **readonly** True > C++ defination code: > ```cpp > const image::Color COLOR_GRAY image::Color::from_rgb(127, 127, 127) > ``` ### COLOR\\_INVALID {#COLOR\\_INVALID} Predefined color invalid, for special usage. item description **value** **image::Color(0, 0, 0, 0, image::Format::FMT_INVALID)** **readonly** True > C++ defination code: > ```cpp > const image::Color COLOR_INVALID image::Color(0, 0, 0, 0, image::Format::FMT_INVALID) > ``` ## Function {#Function} ### format\\_name {#format\\_name} ```python def format_name(fmt: Format) > str ``` Get format name by format. item description **return** format name string > C++ defination code: > ```cpp > std::string format_name(maix::image::Format fmt) > ``` ### resize\\_map\\_pos {#resize\\_map\\_pos} ```python def resize_map_pos(w_in: int, h_in: int, w_out: int, h_out: int, fit: Fit, x: int, y: int, w: int 1, h: int 1) > list[int] ``` map point position or rectangle position from one image size to another image size(resize) item description **param** **int**: h_out target image height<br>**fit**: resize method, see maix.image.Fit<br>**x**: original point x, or rectagle left top point's x<br>**y**: original point y, or rectagle left top point's y<br>**w**: original rectagle width, can be 1 if not use this arg, default 1.<br>**h**: original rectagle height, can be 1 if not use this arg, default 1.<br> **return** list type, [x, y] if map point, [x, y, w, h] if resize rectangle. > C++ defination code: > ```cpp > std::vector<int> resize_map_pos(int w_in, int h_in, int w_out, int h_out, image::Fit fit, int x, int y, int w 1, int h 1) > ``` ### resize\\_map\\_pos\\_reverse {#resize\\_map\\_pos\\_reverse} ```python def resize_map_pos_reverse(w_in: int, h_in: int, w_out: int, h_out: int, fit: Fit, x: int, y: int, w: int 1, h: int 1) > list[int] ``` reverse resize_map_pos method, when we call image.resize method resiz image 'a' to image 'b', we want to known the original position on 'a' whith a knew point on 'b' item description **param** **int**: h_out image height after resized<br>**fit**: resize method, see maix.image.Fit<br>**x**: point on resized image x, or rectagle left top point's x<br>**y**: original point y, or rectagle left top point's y<br>**w**: original rectagle width, can be 1 if not use this arg, default 1.<br>**h**: original rectagle height, can be 1 if not use this arg, default 1.<br> **return** list type, [x, y] if map point, [x, y, w, h] if resize rectangle. > C++ defination code: > ```cpp > std::vector<int> resize_map_pos_reverse(int w_in, int h_in, int w_out, int h_out, image::Fit fit, int x, int y, int w 1, int h 1) > ``` ### load {#load} ```python def load(path: str, format: Format ...) > Image ``` Load image from file, and convert to Image object item description **param** **path**: image file path<br>**format**: read as this format, if not match, will convert to this format, by default is RGB888<br> **return** Image object, if load failed, will return None(nullptr in C++), so you should care about it. > C++ defination code: > ```cpp > image::Image *load(const std::string &path, image::Format format image::Format::FMT_RGB888) > ``` ### from\\_bytes {#from\\_bytes} ```python def from_bytes(width: int, height: int, format: Format, data: maix.Bytes(bytes), copy: bool True) > Image ``` Create image from bytes item description **param** **width**: image width<br>**height**: image height<br>**format**: image format<br>**data**: image data, if data is None, will malloc memory for image data<br>If the image is in jpeg format, data must be filled in.<br>**copy**: if true and data is not None, will copy data to new buffer, else will use data directly. default is true to avoid memory leak.<br>Use it carefully!!!<br> **return** Image object > C++ defination code: > ```cpp > image::Image *from_bytes(int width, int height, image::Format format, Bytes *data, bool copy true) > ``` ### load\\_font {#load\\_font} ```python def load_font(name: str, path: str, size: int 16) > maix.err.Err ``` Load font from file item description **param** **name**: font name, used to identify font<br>**path**: font file path, support ttf, ttc, otf<br>**size**: font size, font height, by default is 16<br> **return** error code, err::ERR_NONE is ok, other is error > C++ defination code: > ```cpp > err::Err load_font(const std::string &name, const char *path, int size 16) > ``` ### set\\_default\\_font {#set\\_default\\_font} Set default font, if not call this method, default is hershey_plain item description **param** **name**: font name, supported names can be get by fonts()<br> **return** error code, err::ERR_NONE is ok, other is error > C++ defination code: > ```cpp > err::Err set_default_font(const std::string &name) > ``` ### fonts {#fonts} ```python def fonts() > list[str] ``` Get all loaded fonts item description **return** all loaded fonts, string list type > C++ defination code: > ```cpp > std::vector<std::string> *fonts() > ``` ### string\\_size {#string\\_size} ```python def string_size(string: str, scale: float 1, thickness: int 1, font: str '') > Size ``` Get text rendered width and height item description **param** **string**: text content<br>**scale**: font scale, by default(value is 1)<br>**thickness**: text thickness(line width), by default(value is 1)<br> **return** text rendered width and height, [width, height] > C++ defination code: > ```cpp > image::Size string_size(std::string string, float scale 1, int thickness 1, const std::string &font \"\") > ``` ### cmap\\_to\\_str {#cmap\\_to\\_str} ```python def cmap_to_str(cmap: CMap) > str ``` Get the string representation of a colormap enum value. item description **param** **cmap**: Colormap enum value, @see image::CMap<br> **return** Corresponding colormap name as a string. > C++ defination code: > ```cpp > std::string cmap_to_str(image::CMap cmap) > ``` ### cmap\\_from\\_str {#cmap\\_from\\_str} ```python def cmap_from_str(name: str) > CMap ``` Get the colormap enum value from a string name. item description **param** **name**: Name of the colormap (case insensitive).<br> **return** Corresponding colormap enum value, or throws if name is invalid. > C++ defination code: > ```cpp > image::CMap cmap_from_str(const std::string& name) > ``` ### cmap\\_strs {#cmap\\_strs} ```python def cmap_strs(classify: bool False) > list[str] ``` Get a list of all available colormap name strings. item description **param** **claasify**: cmaps for classify, wihch cmap size not equal to 256.<br> **return** Vector of all supported colormap name strings. > C++ defination code: > ```cpp > std::vector<std::string> cmap_strs(bool classify false) > ``` ### cmap\\_color {#cmap\\_color} ```python def cmap_color(gray: int, cmap: CMap) > Color ``` Get the mapped color of a grayscale value under a specific colormap. item description **param** **gray**: Grayscale value in [0, 255].<br>**cmap**: Colormap enum value to map the grayscale to color.<br> **return** The mapped image::Color. > C++ defination code: > ```cpp > image::Color cmap_color(uint8_t gray, image::CMap cmap) > ``` ### cmap\\_colors {#cmap\\_colors} ```python def cmap_colors(cmap: CMap) > list[Color] ``` Get all 256 mapped colors of a colormap. item description **param** **cmap**: Colormap enum value.<br> **return** Vector of 256 image::Color values corresponding to grayscale values [0, 255].<br>Return value will alloc data, you need to delete it after use in C++. > C++ defination code: > ```cpp > std::vector<image::Color> cmap_colors(image::CMap cmap) > ``` ### cmap\\_colors\\_rgb {#cmap\\_colors\\_rgb} ```python def cmap_colors_rgb(cmap: CMap) > list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]] ``` Get all 256 mapped RGB colors of a colormap. item description **param** **cmap**: Colormap enum value.<br> **return** Vector of 256 RGB arrays (each array has 3 uint8_t: R, G, B).<br>Return value is a internal table refrence. > C++ defination code: > ```cpp > const std::vector<std::array<uint8_t, 3>> &cmap_colors_rgb(image::CMap cmap) > ``` ### cv2image {#cv2image} ```python def cv2image(array: numpy.ndarray[numpy.uint8], bgr: bool True, copy: bool True) > Image ``` OpenCV Mat(numpy array object) to Image object item description **param** **array**: numpy array object, must be a 3 dim or 2 dim continuous array with shape hwc or hw<br>**bgr**: if set bgr, the return image will be marked as BGR888 or BGRA8888 format(only mark, not ensure return image is real BGR format), grayscale will ignore this arg.<br>**copy**: if true, will alloc new buffer and copy data, else will directly use array's data buffer, default true.<br>Use this arg carefully, when set to false, ther array MUST keep alive until we don't use the return img of this func, or will cause program crash.<br> **return** Image object > C++ defination code: > ```cpp > image::Image *cv2image(py::array_t<uint8_t, py::array::c_style> array, bool bgr true, bool copy true) > ``` ### image2cv {#image2cv} ```python def image2cv(img: Image, ensure_bgr: bool True, copy: bool True) > numpy.ndarray[numpy.uint8] ``` Image object to OpenCV Mat(numpy array object) item description **param** **img**: Image object, maix.image.Image type.<br>**ensure_bgr**: auto convert to BGR888 or BGRA8888 if img format is not BGR or BGRA, if set to false, will not auto convert and directly use img's data, default true.<br>If copy is false, ensure_bgr always be false.<br>**copy**: Whether alloc new image and copy data or not, if ensure_bgr and img is not bgr or bgra format, always copy,<br>if not copy, array object will directly use img's data buffer, will faster but change array will affect img's data, default true.<br> **attention** take care of ensure_bgr and copy param. **return** numpy array object > C++ defination code: > ```cpp > py::array_t<uint8_t, py::array::c_style> image2cv(image::Image *img, bool ensure_bgr true, bool copy true) > ``` ## Class {#Class} ### Size {#Size} Image size type > C++ defination code: > ```cpp > class Size > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, width: int 0, height: int 0) > None ``` Construct a new Size object item description **type** func **param** **width**: image width<br>**height**: image height<br> **static** False > C++ defination code: > ```cpp > Size(int width 0, int height 0) > ``` #### width {#width} ```python def width(self, width: int 1) > int ``` width of size item description **type** func **param** **width**: set new width, if not set, only return current width<br> **static** False > C++ defination code: > ```cpp > int width(int width 1) > ``` #### height {#height} ```python def height(self, height: int 1) > int ``` height of size item description **type** func **param** **height**: set new height, if not set, only return current height<br> **static** False > C++ defination code: > ```cpp > int height(int height 1) > ``` #### \\_\\_getitem\\_\\_ {#\\_\\_getitem\\_\\_} ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **param** **index**: 0 for width, 1 for height<br> **return** int& width or height **static** False > C++ defination code: > ```cpp > int &operator[](int index) > ``` #### \\_\\_str\\_\\_ {#\\_\\_str\\_\\_} ```python def __str__(self) > str ``` to string item description **type** func **static** False > C++ defination code: > ```cpp > std::string __str__() > ``` ### Line {#Line} Line class > C++ defination code: > ```cpp > class Line > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 2} ```python def __init__(self, x1: int, y1: int, x2: int, y2: int, magnitude: int 0, theta: int 0, rho: int 0) > None ``` Line constructor item description **type** func **param** **x1**: coordinate x1 of the straight line<br>**y1**: coordinate y1 of the straight line<br>**x2**: coordinate x2 of the straight line<br>**y2**: coordinate y2 of the straight line<br>**magnitude**: magnitude of the straight line after Hough transformation<br>**theta**: angle of the straight line after Hough transformation<br>**rho**: p value of the straight line after Hough transformation<br> **static** False > C++ defination code: > ```cpp > Line(int x1, int y1, int x2, int y2, int magnitude 0, int theta 0, int rho 0) > ``` #### \\_\\_getitem\\_\\_ {#\\_\\_getitem\\_\\_ 2} ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **param** **index**: [0] get x1 of line<br>[1] get y1 of line<br>[2] get x2 of line<br>[3] get y2 of line<br>[4] get length of line<br>[5] get magnitude of the straight line after Hough transformation<br>[6] get angle of the straight line after Hough transformation (0 179 degrees)<br>[7] get p value of the straight line after Hough transformation<br> **return** int& **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### x1 {#x1} ```python def x1(self) > int ``` get x1 of line item description **type** func **return** return x1 of the line, type is int **static** False > C++ defination code: > ```cpp > int x1() > ``` #### y1 {#y1} ```python def y1(self) > int ``` get y1 of line item description **type** func **return** return y1 of the line, type is int **static** False > C++ defination code: > ```cpp > int y1() > ``` #### x2 {#x2} ```python def x2(self) > int ``` get x2 of line item description **type** func **return** return x2 of the line, type is int **static** False > C++ defination code: > ```cpp > int x2() > ``` #### y2 {#y2} ```python def y2(self) > int ``` get y2 of line item description **type** func **return** return y2 of the line, type is int **static** False > C++ defination code: > ```cpp > int y2() > ``` #### length {#length} ```python def length(self) > int ``` get length of line item description **type** func **return** return length of the line, type is int **static** False > C++ defination code: > ```cpp > int length() > ``` #### magnitude {#magnitude} ```python def magnitude(self) > int ``` get magnitude of the straight line after Hough transformation item description **type** func **return** return magnitude, type is int **static** False > C++ defination code: > ```cpp > int magnitude() > ``` #### theta {#theta} ```python def theta(self) > int ``` get angle of the straight line after Hough transformation (0 179 degrees) item description **type** func **return** return angle, type is int **static** False > C++ defination code: > ```cpp > int theta() > ``` #### rho {#rho} ```python def rho(self) > int ``` get p value of the straight line after Hough transformation item description **type** func **return** return p value, type is int **static** False > C++ defination code: > ```cpp > int rho() > ``` ### Rect {#Rect} Rect class > C++ defination code: > ```cpp > class Rect > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 3} ```python def __init__(self, corners: list[list[int]], x: int, y: int, w: int, h: int, magnitude: int 0) > None ``` Rect constructor item description **type** func **param** **corners**: corners of rect<br>**x**: coordinate x of the straight line<br>**y**: coordinate y of the straight line<br>**w**: coordinate w of the straight line<br>**h**: coordinate h of the straight line<br>**magnitude**: magnitude of the straight line after Hough transformation<br> **static** False > C++ defination code: > ```cpp > Rect(std::vector<std::vector<int>> &corners, int x, int y, int w, int h, int magnitude 0) > ``` #### \\_\\_getitem\\_\\_ {#\\_\\_getitem\\_\\_ 3} ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **param** **index**: [0] get x of rect<br>[1] get y of rect<br>[2] get w of rect<br>[3] get h of rect<br>[4] get magnitude of the straight line after Hough transformation<br> **return** int& **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### corners {#corners} ```python def corners(self) > list[list[int]] ``` get corners of rect item description **type** func **return** return the coordinate of the rect. **static** False > C++ defination code: > ```cpp > std::vector<std::vector<int>> corners() > ``` #### rect {#rect 2} ```python def rect(self) > list[int] ``` get rectangle of rect item description **type** func **return** return the rectangle of the rect. format is {x, y, w, h}, type is std::vector<int> **static** False > C++ defination code: > ```cpp > std::vector<int> rect() > ``` #### x {#x} ```python def x(self) > int ``` get x of rect item description **type** func **return** return x of the rect, type is int **static** False > C++ defination code: > ```cpp > int x() > ``` #### y {#y} ```python def y(self) > int ``` get y of rect item description **type** func **return** return y of the rect, type is int **static** False > C++ defination code: > ```cpp > int y() > ``` #### w {#w} ```python def w(self) > int ``` get w of rect item description **type** func **return** return w of the rect, type is int **static** False > C++ defination code: > ```cpp > int w() > ``` #### h {#h} ```python def h(self) > int ``` get h of rect item description **type** func **return** return h of the rect, type is int **static** False > C++ defination code: > ```cpp > int h() > ``` #### magnitude {#magnitude 2} ```python def magnitude(self) > int ``` get the rectangle’s magnitude. item description **type** func **return** return magnitude, type is int **static** False > C++ defination code: > ```cpp > int magnitude() > ``` ### Circle {#Circle} circle class > C++ defination code: > ```cpp > class Circle > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 4} ```python def __init__(self, x: int, y: int, r: int, magnitude: int) > None ``` Circle constructor item description **type** func **param** **x**: coordinate x of the circle<br>**y**: coordinate y of the circle<br>**r**: coordinate r of the circle<br>**magnitude**: coordinate y2 of the straight line<br> **static** False > C++ defination code: > ```cpp > Circle(int x, int y, int r, int magnitude) > ``` #### \\_\\_getitem\\_\\_ {#\\_\\_getitem\\_\\_ 4} ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **param** **index**: [0] get x of circle<br>[1] get y of circle<br>[2] get r of circle<br>[3] get magnitude of the circle after Hough transformation<br> **return** int& **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### x {#x 2} ```python def x(self) > int ``` get x of circle item description **type** func **return** return x of the circle, type is int **static** False > C++ defination code: > ```cpp > int x() > ``` #### y {#y 2} ```python def y(self) > int ``` get y of circle item description **type** func **return** return y of the circle, type is int **static** False > C++ defination code: > ```cpp > int y() > ``` #### r {#r} ```python def r(self) > int ``` get r of circle item description **type** func **return** return r of the circle, type is int **static** False > C++ defination code: > ```cpp > int r() > ``` #### magnitude {#magnitude 3} ```python def magnitude(self) > int ``` get magnitude of the circle after Hough transformation item description **type** func **return** return magnitude, type is int **static** False > C++ defination code: > ```cpp > int magnitude() > ``` ### Blob {#Blob} Blob class > C++ defination code: > ```cpp > class Blob > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 5} ```python def __init__(self, rect: list[int], corners: list[list[int]], mini_corners: list[list[int]], cx: float, cy: float, pixels: int, rotation: float, code: int, count: int, perimeter: int, roundness: float, x_hist_bins: list[int], y_hist_bins: list[int]) > None ``` Blob constructor item description **type** func **param** **rect**: blob rect, type is std::vector<int><br>**corners**: blob corners, type is std::vector<std::vector<int>><br>**mini_corners**: blob mini_corners, type is std::vector<std::vector<int>><br>**cx**: blob center x, type is float<br>**cy**: blob center y, type is float<br>**pixels**: blob pixels, type is int<br>**rotation**: blob rotation, type is float<br>**code**: blob code, type is int<br>**count**: blob count, type is int<br>**perimeter**: blob perimeter, type is int<br>**roundness**: blob roundness, type is float<br>**x_hist_bins**: blob x_hist_bins, type is std::vector<int><br>**y_hist_bins**: blob y_hist_bins, type is std::vector<int><br> **static** False > C++ defination code: > ```cpp > Blob(std::vector<int> &rect, std::vector<std::vector<int>> &corners, std::vector<std::vector<int>> &mini_corners,float cx, float cy, int pixels, float rotation, int code, int count, int perimeter, float roundness, std::vector<int> &x_hist_bins, std::vector<int> &y_hist_bins) > ``` #### \\_\\_getitem\\_\\_ {#\\_\\_getitem\\_\\_ 5} ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **param** **index**: [0] Returns the blob’s bounding box x coordinate<br>[1] Returns the blob’s bounding box y coordinate<br>[2] Returns the blob’s bounding box w coordinate<br>[3] Returns the blob’s bounding box h coordinate<br>[4] Returns the number of pixels that are part of this blob<br>[5] Returns the centroid x position of the blob<br>[6] Returns the centroid y position of the blob<br> **return** int& width or height **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### corners {#corners 2} ```python def corners(self) > list[list[int]] ``` get blob corners item description **type** func **return** Returns a list of 4 (x,y) tuples of the 4 corners of the object.<br>(x0, y0)___________(x1, y1)<br> <br> <br> <br>___________<br>(x3, y3) (x2, y2)<br>note: the order of corners may change **static** False > C++ defination code: > ```cpp > std::vector<std::vector<int>> corners() > ``` #### mini\\_corners {#mini\\_corners} ```python def mini_corners(self) > list[list[int]] ``` get blob mini corners item description **type** func **return** Returns a list of 4 (x,y) tuples of the 4 corners than bound the min area rectangle of the blob.<br>(x0, y0)___________(x1, y1)<br> <br> <br> <br>___________<br>(x3, y3) (x2, y2)<br>note: the order of corners may change **static** False > C++ defination code: > ```cpp > std::vector<std::vector<int>> mini_corners() > ``` #### rect {#rect 3} ```python def rect(self) > list[int] ``` get blob rect item description **type** func **return** Returns the center coordinates and width and height of the rectangle. format is (x, y, w, h)<br>w<br>(x, y) ___________<br> <br> h<br> <br>___________ **static** False > C++ defination code: > ```cpp > std::vector<int> rect() > ``` #### x {#x 3} ```python def x(self) > int ``` get blob x of the upper left coordinate item description **type** func **return** Returns the x coordinate of the upper left corner of the rectangle. **static** False > C++ defination code: > ```cpp > int x() > ``` #### y {#y 3} ```python def y(self) > int ``` get blob y of the upper left coordinate item description **type** func **return** Returns the y coordinate of the upper left corner of the rectangle. **static** False > C++ defination code: > ```cpp > int y() > ``` #### w {#w 2} ```python def w(self) > int ``` get blob width item description **type** func **return** Returns the blob’s bounding box w coordinate **static** False > C++ defination code: > ```cpp > int w() > ``` #### h {#h 2} ```python def h(self) > int ``` get blob height item description **type** func **return** Returns the blob’s bounding box h coordinate **static** False > C++ defination code: > ```cpp > int h() > ``` #### pixels {#pixels} ```python def pixels(self) > int ``` get blob pixels item description **type** func **return** Returns the number of pixels that are part of this blob. **static** False > C++ defination code: > ```cpp > int pixels() > ``` #### cx {#cx} ```python def cx(self) > int ``` get blob center x item description **type** func **return** Returns the centroid x position of the blob **static** False > C++ defination code: > ```cpp > int cx() > ``` #### cy {#cy} ```python def cy(self) > int ``` get blob center y item description **type** func **return** Returns the centroid y position of the blob **static** False > C++ defination code: > ```cpp > int cy() > ``` #### cxf {#cxf} ```python def cxf(self) > float ``` get blob center x item description **type** func **return** Returns the centroid x position of the blob **static** False > C++ defination code: > ```cpp > float cxf() > ``` #### cyf {#cyf} ```python def cyf(self) > float ``` get blob center y item description **type** func **return** Returns the centroid y position of the blob **static** False > C++ defination code: > ```cpp > float cyf() > ``` #### rotation {#rotation} ```python def rotation(self) > float ``` get blob rotation item description **type** func **return** Returns the rotation of the blob in radians (float). If the blob is like a pencil or pen this value will be unique for 0 180 degrees. **static** False > C++ defination code: > ```cpp > float rotation() > ``` #### rotation\\_rad {#rotation\\_rad} ```python def rotation_rad(self) > float ``` get blob rotation_rad item description **type** func **return** Returns the rotation of the blob in radians **static** False > C++ defination code: > ```cpp > float rotation_rad() > ``` #### rotation\\_deg {#rotation\\_deg} ```python def rotation_deg(self) > int ``` get blob rotation_deg item description **type** func **return** Returns the rotation of the blob in degrees. **static** False > C++ defination code: > ```cpp > int rotation_deg() > ``` #### code {#code} ```python def code(self) > int ``` get blob code item description **type** func **return** Returns a 32 bit binary number with a bit set in it for each color threshold that’s part of this blob **static** False > C++ defination code: > ```cpp > int code() > ``` #### count {#count} ```python def count(self) > int ``` get blob count item description **type** func **return** Returns the number of blobs merged into this blob. **static** False > C++ defination code: > ```cpp > int count() > ``` #### perimeter {#perimeter} ```python def perimeter(self) > int ``` get blob merge_cnt item description **type** func **return** Returns the number of pixels on this blob’s perimeter. **static** False > C++ defination code: > ```cpp > int perimeter() > ``` #### roundness {#roundness} ```python def roundness(self) > float ``` get blob roundness item description **type** func **return** Returns a value between 0 and 1 representing how round the object is **static** False > C++ defination code: > ```cpp > float roundness() > ``` #### elongation {#elongation} ```python def elongation(self) > float ``` get blob elongation item description **type** func **returnReturns** a value between 0 and 1 representing how long (not round) the object is **static** False > C++ defination code: > ```cpp > float elongation() > ``` #### area {#area} ```python def area(self) > int ``` get blob area item description **type** func **return** Returns the area of the bounding box around the blob **static** False > C++ defination code: > ```cpp > int area() > ``` #### density {#density} ```python def density(self) > float ``` get blob density item description **type** func **return** Returns the density ratio of the blob **static** False > C++ defination code: > ```cpp > float density() > ``` #### extent {#extent} ```python def extent(self) > float ``` Alias for blob.density() item description **type** func **return** Returns the density ratio of the blob **static** False > C++ defination code: > ```cpp > float extent() > ``` #### compactness {#compactness} ```python def compactness(self) > float ``` get blob compactness item description **type** func **return** Returns the compactness ratio of the blob **static** False > C++ defination code: > ```cpp > float compactness() > ``` #### solidity {#solidity} ```python def solidity(self) > float ``` get blob solidity item description **type** func **return** Returns the solidity ratio of the blob **static** False > C++ defination code: > ```cpp > float solidity() > ``` #### convexity {#convexity} ```python def convexity(self) > float ``` get blob convexity item description **type** func **return** Returns a value between 0 and 1 representing how convex the object is **static** False > C++ defination code: > ```cpp > float convexity() > ``` #### x\\_hist\\_bins {#x\\_hist\\_bins} ```python def x_hist_bins(self) > list[int] ``` get blob x_hist_bins item description **type** func **return** Returns the x_hist_bins of the blob **static** False > C++ defination code: > ```cpp > std::vector<int> x_hist_bins() > ``` #### y\\_hist\\_bins {#y\\_hist\\_bins} ```python def y_hist_bins(self) > list[int] ``` get blob y_hist_bins item description **type** func **return** Returns the y_hist_bins of the blob **static** False > C++ defination code: > ```cpp > std::vector<int> y_hist_bins() > ``` #### major\\_axis\\_line {#major\\_axis\\_line} ```python def major_axis_line(self) > list[int] ``` get blob major_axis_line item description **type** func **return** Returns a line tuple (x1, y1, x2, y2) of the minor axis of the blob. **static** False > C++ defination code: > ```cpp > std::vector<int> major_axis_line() > ``` #### minor\\_axis\\_line {#minor\\_axis\\_line} ```python def minor_axis_line(self) > list[int] ``` get blob minor_axis_line item description **type** func **return** Returns a line tuple (x1, y1, x2, y2) of the minor axis of the blob. **static** False > C++ defination code: > ```cpp > std::vector<int> minor_axis_line() > ``` #### enclosing\\_circle {#enclosing\\_circle} ```python def enclosing_circle(self) > list[int] ``` get blob enclosing_circle item description **type** func **return** Returns a circle tuple (x, y, r) of the circle that encloses the min area rectangle of a blob. **static** False > C++ defination code: > ```cpp > std::vector<int> enclosing_circle() > ``` #### enclosed\\_ellipse {#enclosed\\_ellipse} ```python def enclosed_ellipse(self) > list[int] ``` get blob enclosed_ellipse item description **type** func **return** Returns an ellipse tuple (x, y, rx, ry, rotation) of the ellipse that fits inside of the min area rectangle of a blob. **static** False > C++ defination code: > ```cpp > std::vector<int> enclosed_ellipse() > ``` ### QRCode {#QRCode} QRCode class > C++ defination code: > ```cpp > class QRCode > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 6} ```python def __init__(self, rect: list[int], corners: list[list[int]], payload: str, version: int, ecc_level: int, mask: int, data_type: int, eci: int) > None ``` QRCode constructor item description **type** func **param** **rect**: rect of corners, type is std::vector<int><br>**corners**: corners of QRCode<br>**payload**: payload of the QRCode<br>**version**: version of the QRCode<br>**ecc_level**: ecc_level of the QRCode<br>**mask**: mask of the QRCode<br>**data_type**: data_type of the QRCode<br>**eci**: eci of the QRCode<br> **static** False > C++ defination code: > ```cpp > QRCode(std::vector<int> &rect, std::vector<std::vector<int>> &corners, std::string &payload, int version, int ecc_level, int mask, int data_type, int eci) > ``` #### \\_\\_getitem\\_\\_ {#\\_\\_getitem\\_\\_ 6} ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **param** **index**: [0] Returns the qrcode’s bounding box x coordinate<br>[1] Returns the qrcode’s bounding box y coordinate<br>[2] Returns the qrcode’s bounding box w coordinate<br>[3] Returns the qrcode’s bounding box h coordinate<br>[4] Not support this index, try to use payload() method<br>[5] Returns the version of qrcode<br>[6] Returns the error correction level of qrcode<br>[7] Returns the mask of qrcode<br>[8] Returns the datatype of qrcode<br>[9] Returns the eci of qrcode<br> **return** int& **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### corners {#corners 3} ```python def corners(self) > list[list[int]] ``` get coordinate of QRCode item description **type** func **return** return the coordinate of the QRCode. **static** False > C++ defination code: > ```cpp > std::vector<std::vector<int>> corners() > ``` #### rect {#rect 4} ```python def rect(self) > list[int] ``` get rectangle of QRCode item description **type** func **return** return the rectangle of the QRCode. format is {x, y, w, h}, type is std::vector<int> **static** False > C++ defination code: > ```cpp > std::vector<int> rect() > ``` #### x {#x 4} ```python def x(self) > int ``` get x of QRCode item description **type** func **return** return x of the QRCode, type is int **static** False > C++ defination code: > ```cpp > int x() > ``` #### y {#y 4} ```python def y(self) > int ``` get y of QRCode item description **type** func **return** return y of the QRCode, type is int **static** False > C++ defination code: > ```cpp > int y() > ``` #### w {#w 3} ```python def w(self) > int ``` get w of QRCode item description **type** func **return** return w of the QRCode, type is int **static** False > C++ defination code: > ```cpp > int w() > ``` #### h {#h 3} ```python def h(self) > int ``` get h of QRCode item description **type** func **return** return h of the QRCode, type is int **static** False > C++ defination code: > ```cpp > int h() > ``` #### payload {#payload} ```python def payload(self) > str ``` get QRCode payload item description **type** func **return** return area of the QRCode **static** False > C++ defination code: > ```cpp > std::string payload() > ``` #### version {#version} ```python def version(self) > int ``` get QRCode version item description **type** func **return** return version of the QRCode **static** False > C++ defination code: > ```cpp > int version() > ``` #### ecc\\_level {#ecc\\_level} ```python def ecc_level(self) > int ``` get QRCode error correction level item description **type** func **return** return error correction level of the QRCode **static** False > C++ defination code: > ```cpp > int ecc_level() > ``` #### mask {#mask} ```python def mask(self) > int ``` get QRCode mask item description **type** func **return** return mask of the QRCode **static** False > C++ defination code: > ```cpp > int mask() > ``` #### data\\_type {#data\\_type} ```python def data_type(self) > int ``` get QRCode dataType item description **type** func **return** return mask of the QRCode **static** False > C++ defination code: > ```cpp > int data_type() > ``` #### eci {#eci} ```python def eci(self) > int ``` get QRCode eci item description **type** func **return** return data of the QRCode **static** False > C++ defination code: > ```cpp > int eci() > ``` #### is\\_numeric {#is\\_numeric} ```python def is_numeric(self) > bool ``` check QRCode is numeric item description **type** func **return** return true if the result type of the QRCode is numeric **static** False > C++ defination code: > ```cpp > bool is_numeric() > ``` #### is\\_alphanumeric {#is\\_alphanumeric} ```python def is_alphanumeric(self) > bool ``` check QRCode is alphanumeric item description **type** func **return** return true if the result type of the QRCode is alphanumeric **static** False > C++ defination code: > ```cpp > bool is_alphanumeric() > ``` #### is\\_binary {#is\\_binary} ```python def is_binary(self) > bool ``` check QRCode is binary item description **type** func **return** return true if the result type of the QRCode is binary **static** False > C++ defination code: > ```cpp > bool is_binary() > ``` #### is\\_kanji {#is\\_kanji} ```python def is_kanji(self) > bool ``` check QRCode is kanji item description **type** func **return** return true if the result type of the QRCode is kanji **static** False > C++ defination code: > ```cpp > bool is_kanji() > ``` ### AprilTag {#AprilTag} AprilTag class > C++ defination code: > ```cpp > class AprilTag > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 7} ```python def __init__(self, rect: list[int], corners: list[list[int]], id: int, famliy: int, centroid_x: float, centroid_y: float, rotation: float, decision_margin: float, hamming: int, goodness: float, x_translation: float, y_translation: float, z_translation: float, x_rotation: float, y_rotation: float, z_rotation: float) > None ``` AprilTag constructor item description **type** func **param** **rect**: Inlucdes the top left corner and the width and height of the rectangle. format is {x, y, w, h}, type is std::vector<int><br>**corners**: Includes the four corners of the rectangle. format is {{x0, y0}, {x1, y1}, {x2, y2}, {x3, y3}}, type is std::vector<std::vector<int>><br>**id**: The id of the AprilTag<br>**famliy**: The family of the AprilTag<br>**centroid_x**: The x coordinate of the center of the AprilTag<br>**centroid_y**: The y coordinate of the center of the AprilTag<br>**rotation**: The rotation of the AprilTag<br>**decision_margin**: The decision_margin of the AprilTag<br>**hamming**: The hamming of the AprilTag<br>**goodness**: The goodness of the AprilTag<br>**x_translation**: The x_translation of the AprilTag<br>**y_translation**: The y_translation of the AprilTag<br>**z_translation**: The z_translation of the AprilTag<br>**x_rotation**: The x_rotation of the AprilTag<br>**y_rotation**: The y_rotation of the AprilTag<br>**z_rotation**: The z_rotation of the AprilTag<br> **static** False > C++ defination code: > ```cpp > AprilTag(std::vector<int> &rect, std::vector<std::vector<int>> &corners, int id, int famliy, float centroid_x, float centroid_y, float rotation, float decision_margin, int hamming, float goodness, float x_translation, float y_translation, float z_translation, float x_rotation, float y_rotation, float z_rotation) > ``` #### \\_\\_getitem\\_\\_ {#\\_\\_getitem\\_\\_ 7} ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **param** **index**: [0] Returns the apriltag’s bounding box x coordinate<br>[1] Returns the apriltag’s bounding box y coordinate<br>[2] Returns the apriltag’s bounding box w coordinate<br>[3] Returns the apriltag’s bounding box h coordinate<br>[4] Returns the apriltag’s id<br>[5] Returns the apriltag’s family<br>[6] Not support<br>[7] Not support<br>[8] Not support<br>[9] Not support<br>[10] Returns the apriltag’s hamming<br>[11] Not support<br>[12] Not support<br>[13] Not support<br>[14] Not support<br>[15] Not support<br>[16] Not support<br>[17] Not support<br> **return** int& **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### corners {#corners 4} ```python def corners(self) > list[list[int]] ``` get coordinate of AprilTag item description **type** func **return** return the coordinate of the AprilTag. **static** False > C++ defination code: > ```cpp > std::vector<std::vector<int>> corners() > ``` #### rect {#rect 5} ```python def rect(self) > list[int] ``` get rectangle of AprilTag item description **type** func **return** return the rectangle of the AprilTag. format is {x, y, w, h}, type is std::vector<int> **static** False > C++ defination code: > ```cpp > std::vector<int> rect() > ``` #### x {#x 5} ```python def x(self) > int ``` get x of AprilTag item description **type** func **return** return x of the AprilTag, type is int **static** False > C++ defination code: > ```cpp > int x() > ``` #### y {#y 5} ```python def y(self) > int ``` get y of AprilTag item description **type** func **return** return y of the AprilTag, type is int **static** False > C++ defination code: > ```cpp > int y() > ``` #### w {#w 4} ```python def w(self) > int ``` get w of AprilTag item description **type** func **return** return w of the AprilTag, type is int **static** False > C++ defination code: > ```cpp > int w() > ``` #### h {#h 4} ```python def h(self) > int ``` get h of AprilTag item description **type** func **return** return h of the AprilTag, type is int **static** False > C++ defination code: > ```cpp > int h() > ``` #### id {#id} ```python def id(self) > int ``` get id of AprilTag item description **type** func **return** return id of the AprilTag, type is int **static** False > C++ defination code: > ```cpp > int id() > ``` #### family {#family} ```python def family(self) > int ``` get family of AprilTag item description **type** func **return** return family of the AprilTag, type is int **static** False > C++ defination code: > ```cpp > int family() > ``` #### cx {#cx 2} ```python def cx(self) > int ``` get cx of AprilTag item description **type** func **return** return cx of the AprilTag, type is int **static** False > C++ defination code: > ```cpp > int cx() > ``` #### cxf {#cxf 2} ```python def cxf(self) > float ``` get cxf of AprilTag item description **type** func **return** return cxf of the AprilTag, type is float **static** False > C++ defination code: > ```cpp > float cxf() > ``` #### cy {#cy 2} ```python def cy(self) > int ``` get cy of AprilTag item description **type** func **return** return cy of the AprilTag, type is int **static** False > C++ defination code: > ```cpp > int cy() > ``` #### cyf {#cyf 2} ```python def cyf(self) > float ``` get cyf of AprilTag item description **type** func **return** return cyf of the AprilTag, type is float **static** False > C++ defination code: > ```cpp > float cyf() > ``` #### rotation {#rotation 2} ```python def rotation(self) > float ``` get rotation of AprilTag item description **type** func **return** return rotation of the AprilTag, type is float **static** False > C++ defination code: > ```cpp > float rotation() > ``` #### decision\\_margin {#decision\\_margin} ```python def decision_margin(self) > float ``` Get decision_margin of AprilTag item description **type** func **return** Returns the quality of the apriltag match (0.0 1.0) where 1.0 is the best. **static** False > C++ defination code: > ```cpp > float decision_margin() > ``` #### hamming {#hamming} ```python def hamming(self) > int ``` get hamming of AprilTag item description **type** func **return** Returns the number of accepted bit errors for this tag.<br>return 0, means 0 bit errors will be accepted.<br>1 is TAG25H7, means up to 1 bit error may be accepted<br>2 is TAG25H9, means up to 3 bit errors may be accepted<br>3 is TAG36H10, means up to 3 bit errors may be accepted<br>4 is TAG36H11, means up to 4 bit errors may be accepted<br>5 is ARTOOLKIT, means 0 bit errors will be accepted **static** False > C++ defination code: > ```cpp > int hamming() > ``` #### goodness {#goodness} ```python def goodness(self) > float ``` get goodness of AprilTag item description **type** func **return** return goodness of the AprilTag, type is float<br>Note: This value is always 0.0 for now. **static** False > C++ defination code: > ```cpp > float goodness() > ``` #### x\\_translation {#x\\_translation} ```python def x_translation(self) > float ``` get x_translation of AprilTag item description **type** func **return** return x_translation of the AprilTag, type is float **static** False > C++ defination code: > ```cpp > float x_translation() > ``` #### y\\_translation {#y\\_translation} ```python def y_translation(self) > float ``` get y_translation of AprilTag item description **type** func **return** return y_translation of the AprilTag, type is float **static** False > C++ defination code: > ```cpp > float y_translation() > ``` #### z\\_translation {#z\\_translation} ```python def z_translation(self) > float ``` get z_translation of AprilTag item description **type** func **return** return z_translation of the AprilTag, type is float **static** False > C++ defination code: > ```cpp > float z_translation() > ``` #### x\\_rotation {#x\\_rotation} ```python def x_rotation(self) > float ``` get x_rotation of AprilTag item description **type** func **return** return x_rotation of the AprilTag, type is float **static** False > C++ defination code: > ```cpp > float x_rotation() > ``` #### y\\_rotation {#y\\_rotation} ```python def y_rotation(self) > float ``` get y_rotation of AprilTag item description **type** func **return** return y_rotation of the AprilTag, type is float **static** False > C++ defination code: > ```cpp > float y_rotation() > ``` #### z\\_rotation {#z\\_rotation} ```python def z_rotation(self) > float ``` get z_rotation of AprilTag item description **type** func **return** return z_rotation of the AprilTag, type is float **static** False > C++ defination code: > ```cpp > float z_rotation() > ``` ### DataMatrix {#DataMatrix} DataMatrix class > C++ defination code: > ```cpp > class DataMatrix > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 8} ```python def __init__(self, rect: list[int], corners: list[list[int]], payload: str, rotation: float, rows: int, columns: int, capacity: int, padding: int) > None ``` DataMatrix constructor item description **type** func **param** **rect**: Inlucdes the top left corner and the width and height of the rectangle. format is {x, y, w, h}, type is std::vector<int><br>**corners**: Includes the four corners of the rectangle. format is {{x0, y0}, {x1, y1}, {x2, y2}, {x3, y3}}, type is std::vector<std::vector<int>><br>**payload**: The payload of the DataMatrix<br>**rotation**: The rotation of the DataMatrix<br>**rows**: The rows of the DataMatrix<br>**columns**: The columns of the DataMatrix<br>**capacity**: The capacity of the DataMatrix<br>**padding**: The padding of the DataMatrix<br> **static** False > C++ defination code: > ```cpp > DataMatrix(std::vector<int> &rect, std::vector<std::vector<int>> &corners, std::string &payload, float rotation, int rows, int columns, int capacity, int padding) > ``` #### \\_\\_getitem\\_\\_ {#\\_\\_getitem\\_\\_ 8} ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **param** **index**: [0] get x of DataMatrix<br>[1] get y of DataMatrix<br>[2] get w of DataMatrix<br>[3] get h of DataMatrix<br>[4] Not support this index, try to use payload() method<br>[5] Not support this index, try to use rotation() method<br>[6] get rows of DataMatrix<br>[7] get columns of DataMatrix<br>[8] get capacity of DataMatrix<br>[9] get padding of DataMatrix<br> **return** int& **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### corners {#corners 5} ```python def corners(self) > list[list[int]] ``` get coordinate of DataMatrix item description **type** func **return** return the coordinate of the DataMatrix. **static** False > C++ defination code: > ```cpp > std::vector<std::vector<int>> corners() > ``` #### rect {#rect 6} ```python def rect(self) > list[int] ``` get rectangle of DataMatrix item description **type** func **return** return the rectangle of the DataMatrix. format is {x, y, w, h}, type is std::vector<int> **static** False > C++ defination code: > ```cpp > std::vector<int> rect() > ``` #### x {#x 6} ```python def x(self) > int ``` get x of DataMatrix item description **type** func **return** return x of the DataMatrix, type is int **static** False > C++ defination code: > ```cpp > int x() > ``` #### y {#y 6} ```python def y(self) > int ``` get y of DataMatrix item description **type** func **return** return y of the DataMatrix, type is int **static** False > C++ defination code: > ```cpp > int y() > ``` #### w {#w 5} ```python def w(self) > int ``` get w of DataMatrix item description **type** func **return** return w of the DataMatrix, type is int **static** False > C++ defination code: > ```cpp > int w() > ``` #### h {#h 5} ```python def h(self) > int ``` get h of DataMatrix item description **type** func **return** return h of the DataMatrix, type is int **static** False > C++ defination code: > ```cpp > int h() > ``` #### payload {#payload 2} ```python def payload(self) > str ``` get payload of DataMatrix item description **type** func **return** return payload of the DataMatrix, type is std::string **static** False > C++ defination code: > ```cpp > std::string payload() > ``` #### rotation {#rotation 3} ```python def rotation(self) > float ``` get rotation of DataMatrix item description **type** func **return** return rotation of the DataMatrix, type is float **static** False > C++ defination code: > ```cpp > float rotation() > ``` #### rows {#rows} ```python def rows(self) > int ``` get rows of DataMatrix item description **type** func **return** return rows of the DataMatrix, type is int **static** False > C++ defination code: > ```cpp > int rows() > ``` #### columns {#columns} ```python def columns(self) > int ``` get columns of DataMatrix item description **type** func **return** return columns of the DataMatrix, type is int **static** False > C++ defination code: > ```cpp > int columns() > ``` #### capacity {#capacity} ```python def capacity(self) > int ``` get capacity of DataMatrix item description **type** func **return** returns how many characters could fit in this data matrix, type is int **static** False > C++ defination code: > ```cpp > int capacity() > ``` #### padding {#padding} ```python def padding(self) > int ``` get padding of DataMatrix item description **type** func **return** returns how many unused characters are in this data matrix, type is int **static** False > C++ defination code: > ```cpp > int padding() > ``` ### BarCode {#BarCode} BarCode class > C++ defination code: > ```cpp > class BarCode > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 9} ```python def __init__(self, rect: list[int], corners: list[list[int]], payload: str, type: int, rotation: float, quality: int) > None ``` BarCode constructor item description **type** func **param** **rect**: Inlucdes the top left corner and the width and height of the rectangle. format is {x, y, w, h}, type is std::vector<int><br>**corners**: Includes the four corners of the rectangle. format is {{x0, y0}, {x1, y1}, {x2, y2}, {x3, y3}}, type is std::vector<std::vector<int>><br>**payload**: The payload of the BarCode<br>**type**: The type of the BarCode<br>**rotation**: The rotation of the BarCode<br>**quality**: The quality of the BarCode<br> **static** False > C++ defination code: > ```cpp > BarCode(std::vector<int> &rect, std::vector<std::vector<int>> &corners, std::string &payload, int type, float rotation, int quality) > ``` #### \\_\\_getitem\\_\\_ {#\\_\\_getitem\\_\\_ 9} ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **param** **index**: [0] get x of BarCode<br>[1] get y of BarCode<br>[2] get w of BarCode<br>[3] get h of BarCode<br>[4] Not support this index, try to use payload() method<br>[5] get type of BarCode<br>[6] Not support this index, try to use rotation() method<br>[7] get quality of BarCode<br> **return** int& **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### corners {#corners 6} ```python def corners(self) > list[list[int]] ``` get coordinate of BarCode item description **type** func **return** return the coordinate of the BarCode. **static** False > C++ defination code: > ```cpp > std::vector<std::vector<int>> corners() > ``` #### rect {#rect 7} ```python def rect(self) > list[int] ``` get rectangle of BarCode item description **type** func **return** return the rectangle of the BarCode. format is {x, y, w, h}, type is std::vector<int> **static** False > C++ defination code: > ```cpp > std::vector<int> rect() > ``` #### x {#x 7} ```python def x(self) > int ``` get x of BarCode item description **type** func **return** return x of the BarCode, type is int **static** False > C++ defination code: > ```cpp > int x() > ``` #### y {#y 7} ```python def y(self) > int ``` get y of BarCode item description **type** func **return** return y of the BarCode, type is int **static** False > C++ defination code: > ```cpp > int y() > ``` #### w {#w 6} ```python def w(self) > int ``` get w of BarCode item description **type** func **return** return w of the BarCode, type is int **static** False > C++ defination code: > ```cpp > int w() > ``` #### h {#h 6} ```python def h(self) > int ``` get h of BarCode item description **type** func **return** return h of the BarCode, type is int **static** False > C++ defination code: > ```cpp > int h() > ``` #### payload {#payload 3} ```python def payload(self) > str ``` get payload of BarCode item description **type** func **return** return payload of the BarCode, type is std::string **static** False > C++ defination code: > ```cpp > std::string payload() > ``` #### type {#type} ```python def type(self) > int ``` get type of BarCode item description **type** func **return** return type of the BarCode, type is int **static** False > C++ defination code: > ```cpp > int type() > ``` #### rotation {#rotation 4} ```python def rotation(self) > float ``` get rotation of BarCode item description **type** func **return** return rotation of the BarCode, type is float. FIXME: always return 0.0 **static** False > C++ defination code: > ```cpp > float rotation() > ``` #### quality {#quality} ```python def quality(self) > int ``` get quality of BarCode item description **type** func **return** return quality of the BarCode, type is int **static** False > C++ defination code: > ```cpp > int quality() > ``` ### Statistics {#Statistics} Statistics class > C++ defination code: > ```cpp > class Statistics > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 10} ```python def __init__(self, format: Format, l_statistics: list[int], a_statistics: list[int], b_statistics: list[int]) > None ``` Statistics constructor item description **type** func **param** **format**: The statistics source image format<br>**l_statistics**: The statistics of the L channel. format is {mean, median, mode, std_dev, min, max, lq, uq}, type is std::vector<int><br>**a_statistics**: The statistics of the A channel. format is {mean, median, mode, std_dev, min, max, lq, uq}, type is std::vector<int><br>**b_statistics**: The statistics of the B channel. format is {mean, median, mode, std_dev, min, max, lq, uq}, type is std::vector<int><br> **static** False > C++ defination code: > ```cpp > Statistics(image::Format format, std::vector<int> &l_statistics, std::vector<int> &a_statistics, std::vector<int> &b_statistics) > ``` #### \\_\\_getitem\\_\\_ {#\\_\\_getitem\\_\\_ 10} ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **param** **index**: array index<br> **return** int& **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### format {#format 2} ```python def format(self) > Format ``` get format of Statistics source image item description **type** func **return** return format of the Statistics source image, type is image::Format **static** False > C++ defination code: > ```cpp > image::Format format() > ``` #### l\\_mean {#l\\_mean} ```python def l_mean(self) > int ``` get L channel mean item description **type** func **return** return L channel mean, type is int **static** False > C++ defination code: > ```cpp > int l_mean() > ``` #### l\\_median {#l\\_median} ```python def l_median(self) > int ``` get L channel median item description **type** func **return** return L channel median, type is int **static** False > C++ defination code: > ```cpp > int l_median() > ``` #### l\\_mode {#l\\_mode} ```python def l_mode(self) > int ``` get L channel mode item description **type** func **return** return L channel mode, type is int **static** False > C++ defination code: > ```cpp > int l_mode() > ``` #### l\\_std\\_dev {#l\\_std\\_dev} ```python def l_std_dev(self) > int ``` get L channel std_dev item description **type** func **return** return L channel std_dev, type is int **static** False > C++ defination code: > ```cpp > int l_std_dev() > ``` #### l\\_min {#l\\_min} ```python def l_min(self) > int ``` get L channel min item description **type** func **return** return L channel min, type is int **static** False > C++ defination code: > ```cpp > int l_min() > ``` #### l\\_max {#l\\_max} ```python def l_max(self) > int ``` get L channel max item description **type** func **return** return L channel max, type is int **static** False > C++ defination code: > ```cpp > int l_max() > ``` #### l\\_lq {#l\\_lq} ```python def l_lq(self) > int ``` get L channel lq item description **type** func **return** return L channel lq, type is int **static** False > C++ defination code: > ```cpp > int l_lq() > ``` #### l\\_uq {#l\\_uq} ```python def l_uq(self) > int ``` get L channel uq item description **type** func **return** return L channel uq, type is int **static** False > C++ defination code: > ```cpp > int l_uq() > ``` #### a\\_mean {#a\\_mean} ```python def a_mean(self) > int ``` get A channel mean item description **type** func **return** return A channel mean, type is int **static** False > C++ defination code: > ```cpp > int a_mean() > ``` #### a\\_median {#a\\_median} ```python def a_median(self) > int ``` get A channea median item description **type** func **return** return A channel median, type is int **static** False > C++ defination code: > ```cpp > int a_median() > ``` #### a\\_mode {#a\\_mode} ```python def a_mode(self) > int ``` get A channel mode item description **type** func **return** return A channel mode, type is int **static** False > C++ defination code: > ```cpp > int a_mode() > ``` #### a\\_std\\_dev {#a\\_std\\_dev} ```python def a_std_dev(self) > int ``` get A channel std_dev item description **type** func **return** return A channel std_dev, type is int **static** False > C++ defination code: > ```cpp > int a_std_dev() > ``` #### a\\_min {#a\\_min} ```python def a_min(self) > int ``` get A channel min item description **type** func **return** return A channel min, type is int **static** False > C++ defination code: > ```cpp > int a_min() > ``` #### a\\_max {#a\\_max} ```python def a_max(self) > int ``` get A channel max item description **type** func **return** return A channel max, type is int **static** False > C++ defination code: > ```cpp > int a_max() > ``` #### a\\_lq {#a\\_lq} ```python def a_lq(self) > int ``` get A channel lq item description **type** func **return** return A channel lq, type is int **static** False > C++ defination code: > ```cpp > int a_lq() > ``` #### a\\_uq {#a\\_uq} ```python def a_uq(self) > int ``` get A channel uq item description **type** func **return** return A channel uq, type is int **static** False > C++ defination code: > ```cpp > int a_uq() > ``` #### b\\_mean {#b\\_mean} ```python def b_mean(self) > int ``` get B channel mean item description **type** func **return** return B channel mean, type is int **static** False > C++ defination code: > ```cpp > int b_mean() > ``` #### b\\_median {#b\\_median} ```python def b_median(self) > int ``` get B channea median item description **type** func **return** return B channel median, type is int **static** False > C++ defination code: > ```cpp > int b_median() > ``` #### b\\_mode {#b\\_mode} ```python def b_mode(self) > int ``` get B channel mode item description **type** func **return** return B channel mode, type is int **static** False > C++ defination code: > ```cpp > int b_mode() > ``` #### b\\_std\\_dev {#b\\_std\\_dev} ```python def b_std_dev(self) > int ``` get B channel std_dev item description **type** func **return** return B channel std_dev, type is int **static** False > C++ defination code: > ```cpp > int b_std_dev() > ``` #### b\\_min {#b\\_min} ```python def b_min(self) > int ``` get B channel min item description **type** func **return** return B channel min, type is int **static** False > C++ defination code: > ```cpp > int b_min() > ``` #### b\\_max {#b\\_max} ```python def b_max(self) > int ``` get B channel max item description **type** func **return** return B channel max, type is int **static** False > C++ defination code: > ```cpp > int b_max() > ``` #### b\\_lq {#b\\_lq} ```python def b_lq(self) > int ``` get B channel lq item description **type** func **return** return B channel lq, type is int **static** False > C++ defination code: > ```cpp > int b_lq() > ``` #### b\\_uq {#b\\_uq} ```python def b_uq(self) > int ``` get B channel uq item description **type** func **return** return B channel uq, type is int **static** False > C++ defination code: > ```cpp > int b_uq() > ``` ### Displacement {#Displacement} Displacement class > C++ defination code: > ```cpp > class Displacement > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 11} ```python def __init__(self, x_translation: float, y_translation: float, rotation: float, scale: float, response: float) > None ``` Displacement constructor item description **type** func **param** **x_translation**: The x_translation of the Displacement<br>**y_translation**: The y_translation of the Displacement<br>**rotation**: The rotation of the Displacement<br>**scale**: The scale of the Displacement<br>**response**: The response of the Displacement<br> **static** False > C++ defination code: > ```cpp > Displacement(float x_translation, float y_translation, float rotation, float scale, float response) > ``` #### \\_\\_getitem\\_\\_ {#\\_\\_getitem\\_\\_ 11} ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **param** **index**: array index<br> **return** int& **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### x\\_translation {#x\\_translation 2} ```python def x_translation(self) > float ``` get x_translation of Displacement item description **type** func **return** return x_translation of the Displacement, type is float **static** False > C++ defination code: > ```cpp > float x_translation() > ``` #### y\\_translation {#y\\_translation 2} ```python def y_translation(self) > float ``` get y_translation of Displacement item description **type** func **return** return y_translation of the Displacement, type is float **static** False > C++ defination code: > ```cpp > float y_translation() > ``` #### rotation {#rotation 5} ```python def rotation(self) > float ``` get rotation of Displacement item description **type** func **return** return rotation of the Displacement, type is float **static** False > C++ defination code: > ```cpp > float rotation() > ``` #### scale {#scale} ```python def scale(self) > float ``` get scale of Displacement item description **type** func **return** return scale of the Displacement, type is float **static** False > C++ defination code: > ```cpp > float scale() > ``` #### response {#response} ```python def response(self) > float ``` get response of Displacement item description **type** func **return** return response of the Displacement, type is float **static** False > C++ defination code: > ```cpp > float response() > ``` ### Percentile {#Percentile} Percentile class > C++ defination code: > ```cpp > class Percentile > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 12} ```python def __init__(self, l_value: int, a_value: int 0, b_value: int 0) > None ``` Percentile constructor item description **type** func **param** **l_value**: for grayscale image, it is grayscale percentile value (between 0 and 255).<br>for rgb888 image, it is l channel percentile value of lab (between 0 and 100).<br>**a_value**: for rgb888 image, it is a channel percentile value of lab format(between 128 and 127).<br>**b_value**: for rgb888 image, it is b channel percentile value of lab format(between 128 and 127).<br> **static** False > C++ defination code: > ```cpp > Percentile(int l_value, int a_value 0, int b_value 0) > ``` #### \\_\\_getitem\\_\\_ {#\\_\\_getitem\\_\\_ 12} ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### value {#value} ```python def value(self) > int ``` Return the grayscale percentile value (between 0 and 255). item description **type** func **return** returns grayscale percentile value **static** False > C++ defination code: > ```cpp > int value() > ``` #### l\\_value {#l\\_value} ```python def l_value(self) > int ``` Return the l channel percentile value of lab format (between 0 and 100). item description **type** func **return** returns l channel percentile value **static** False > C++ defination code: > ```cpp > int l_value() > ``` #### a\\_value {#a\\_value} ```python def a_value(self) > int ``` Return the a channel percentile value of lab format (between 128 and 127). item description **type** func **return** returns a channel percentile value **static** False > C++ defination code: > ```cpp > int a_value() > ``` #### b\\_value {#b\\_value} ```python def b_value(self) > int ``` Return the b channel percentile value of lab format (between 128 and 127). item description **type** func **return** returns b channel percentile value **static** False > C++ defination code: > ```cpp > int b_value() > ``` ### Threshold {#Threshold} Threshold class > C++ defination code: > ```cpp > class Threshold > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 13} ```python def __init__(self, l_value: int, a_value: int 0, b_value: int 0) > None ``` Threshold constructor item description **type** func **param** **l_value**: for grayscale image, it is grayscale threshold value (between 0 and 255).<br>for rgb888 image, it is l channel threshold value of lab (between 0 and 100).<br>**a_value**: for rgb888 image, it is a channel threshold value of lab format(between 128 and 127).<br>**b_value**: for rgb888 image, it is b channel threshold value of lab format(between 128 and 127).<br> **static** False > C++ defination code: > ```cpp > Threshold(int l_value, int a_value 0, int b_value 0) > ``` #### \\_\\_getitem\\_\\_ {#\\_\\_getitem\\_\\_ 13} ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### value {#value 2} ```python def value(self) > int ``` Return the grayscale threshold value (between 0 and 255). item description **type** func **return** returns grayscale threshold value **static** False > C++ defination code: > ```cpp > int value() > ``` #### l\\_value {#l\\_value 2} ```python def l_value(self) > int ``` Return the l channel threshold value of lab format (between 0 and 100). item description **type** func **return** returns l channel percentile value **static** False > C++ defination code: > ```cpp > int l_value() > ``` #### a\\_value {#a\\_value 2} ```python def a_value(self) > int ``` Return the a channel threshold value of lab format (between 128 and 127). item description **type** func **return** returns a channel percentile value **static** False > C++ defination code: > ```cpp > int a_value() > ``` #### b\\_value {#b\\_value 2} ```python def b_value(self) > int ``` Return the b channel threshold value of lab format (between 128 and 127). item description **type** func **return** returns b channel percentile value **static** False > C++ defination code: > ```cpp > int b_value() > ``` ### Histogram {#Histogram} Histogram class > C++ defination code: > ```cpp > class Histogram > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 14} ```python def __init__(self, l_bin: list[float], a_bin: list[float], b_bin: list[float], format: Format ...) > None ``` Histogram constructor item description **type** func **param** **l_value**: for grayscale image, it is grayscale threshold value list (the range of element values in the list is 0 and 255).<br>for rgb888 image, it is l channel threshold value list of lab (the range of element values in the list is 0 and 100).<br>**a_value**: for rgb888 image, it is a channel threshold value list of lab format(the range of element values in the list is 128 and 127).<br>**b_value**: for rgb888 image, it is b channel threshold value list of lab format(the range of element values in the list is 128 and 127).<br>**format**: format of the source image<br> **static** False > C++ defination code: > ```cpp > Histogram(std::vector<float> l_bin, std::vector<float> a_bin, std::vector<float> b_bin, image::Format format image::Format::FMT_RGB888) > ``` #### \\_\\_getitem\\_\\_ {#\\_\\_getitem\\_\\_ 14} ```python def __getitem__(self, index: int) > int ``` Subscript operator item description **type** func **static** False > C++ defination code: > ```cpp > int &__getitem__(int index) > ``` #### bins {#bins} ```python def bins(self) > list[float] ``` Returns a list of floats for the grayscale histogram. item description **type** func **static** False > C++ defination code: > ```cpp > std::vector<float> bins() > ``` #### l\\_bins {#l\\_bins} ```python def l_bins(self) > list[float] ``` Returns a list of floats for the RGB565 histogram LAB L channel. item description **type** func **static** False > C++ defination code: > ```cpp > std::vector<float> l_bins() > ``` #### a\\_bins {#a\\_bins} ```python def a_bins(self) > list[float] ``` Returns a list of floats for the RGB565 histogram LAB A channel. item description **type** func **static** False > C++ defination code: > ```cpp > std::vector<float> a_bins() > ``` #### b\\_bins {#b\\_bins} ```python def b_bins(self) > list[float] ``` Returns a list of floats for the RGB565 histogram LAB B channel. item description **type** func **static** False > C++ defination code: > ```cpp > std::vector<float> b_bins() > ``` #### get\\_percentile {#get\\_percentile} ```python def get_percentile(self, percentile: float) > Percentile ``` Computes the CDF of the histogram channels and returns a image::Percentile object item description **type** func **param** **percentile**: the values of the histogram at the passed in percentile (0.0 1.0) (float).<br>So, if you pass in 0.1 this method will tell you (going from left to right in the histogram)<br>what bin when summed into an accumulator caused the accumulator to cross 0.1. This is useful<br>to determine min (with 0.1) and max (with 0.9) of a color distribution without outlier effects<br>ruining your results for adaptive color tracking.<br> **return** image::Percentile object **static** False > C++ defination code: > ```cpp > image::Percentile get_percentile(float percentile) > ``` #### get\\_threshold {#get\\_threshold} ```python def get_threshold(self) > Threshold ``` Uses Otsu’s Method to compute the optimal threshold values that split the histogram into two halves for each channel of the histogram and returns a image::Threshold object. item description **type** func **return** image::Threshold object **static** False > C++ defination code: > ```cpp > image::Threshold get_threshold() > ``` #### get\\_statistics {#get\\_statistics} ```python def get_statistics(self) > Statistics ``` Computes the mean, median, mode, standard deviation, min, max, lower quartile, and upper quartile of each color channel in the histogram and returns a image::Statistics object. item description **type** func **return** image::Statistics object **static** False > C++ defination code: > ```cpp > image::Statistics get_statistics() > ``` ### LBPKeyPoint {#LBPKeyPoint} LBPKeyPoint class > C++ defination code: > ```cpp > class LBPKeyPoint > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 15} ```python def __init__(self, data: list[int]) > None ``` LBPKeyPoint constructor item description **type** func **param** **data**: The data of the LBPKeyPoint<br> **static** False > C++ defination code: > ```cpp > LBPKeyPoint(std::valarray<uint8_t> &data) > ``` ### KeyPoint {#KeyPoint} KeyPoint class > C++ defination code: > ```cpp > class KeyPoint > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 16} ```python def __init__(self, x: int, y: int, score: int, octave: int, angle: int, matched: int, desc: list[int]) > None ``` KeyPoint constructor item description **type** func **param** **x**: The x of the KeyPoint<br>**y**: The y of the KeyPoint<br>**score**: The score of the KeyPoint<br>**octave**: The octave of the KeyPoint<br>**angle**: The angle of the KeyPoint<br>**matched**: The matched of the KeyPoint<br>**desc**: The desc of the KeyPoint<br> **static** False > C++ defination code: > ```cpp > KeyPoint(uint16_t x, uint16_t y, uint16_t score, uint16_t octave, uint16_t angle, uint16_t matched, std::vector<uint8_t> &desc) > ``` ### KPTMatch {#KPTMatch} KPTMatch class > C++ defination code: > ```cpp > class KPTMatch > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 17} ```python def __init__(self, cx: int, cy: int, x: int, y: int, w: int, h: int, score: int, theta: int, match: int) > None ``` KPTMatch constructor item description **type** func **param** **cx**: The cx of the KPTMatch<br>**cy**: The cy of the KPTMatch<br>**x**: The x of the KPTMatch<br>**y**: The y of the KPTMatch<br>**w**: The w of the KPTMatch<br>**h**: The h of the KPTMatch<br>**score**: The score of the KPTMatch<br>**theta**: The theta of the KPTMatch<br>**match**: The match of the KPTMatch<br> **static** False > C++ defination code: > ```cpp > KPTMatch(int cx, int cy, int x, int y, int w, int h, int score, int theta, int match) > ``` ### ORBKeyPoint {#ORBKeyPoint} ORBKeyPoint class > C++ defination code: > ```cpp > class ORBKeyPoint > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 18} ```python def __init__(self, data: list[KeyPoint], threshold: int, normalized: bool) > None ``` ORBKeyPoint constructor item description **type** func **param** **data**: The data of the ORBKeyPoint<br>**threshold**: The threshold of the ORBKeyPoint<br>**normalized**: The normalized of the ORBKeyPoint<br> **static** False > C++ defination code: > ```cpp > ORBKeyPoint(std::vector<image::KeyPoint> &data, int threshold, bool normalized) > ``` #### get\\_data {#get\\_data} ```python def get_data(self) > list[KeyPoint] ``` get data of ORBKeyPoint item description **type** func **return** return data of the ORBKeyPoint, type is std::vector<KeyPoint> **static** False > C++ defination code: > ```cpp > std::vector<image::KeyPoint> get_data() > ``` ### HaarCascade {#HaarCascade} HaarCascade class > C++ defination code: > ```cpp > class HaarCascade > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 19} ```python def __init__(self) > None ``` HaarCascade constructor item description **type** func **param** **data**: The data of the HaarCascade<br>**threshold**: The threshold of the HaarCascade<br>**normalized**: The normalized of the HaarCascade<br> **static** False > C++ defination code: > ```cpp > HaarCascade() > ``` ### LineGroup {#LineGroup} LineGroup class > C++ defination code: > ```cpp > class LineGroup > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 20} ```python def __init__(self, id: int, type: LineType, lines: list[Line]) > None ``` LineGroup constructor item description **type** func **param** **id**: The id of line<br>**type**: The line list type, @see image::LineType<br>**lines**: The line list<br> **static** False > C++ defination code: > ```cpp > LineGroup(int id, image::LineType type, std::vector<image::Line> lines) > ``` #### id {#id 2} ```python def id(self) > int ``` Get the line id of group, first id is 0. item description **type** func **return** return id **static** False > C++ defination code: > ```cpp > int id() > ``` #### type {#type 2} ```python def type(self) > LineType ``` Get the line type of group item description **type** func **return** returns line type. @see LineType **static** False > C++ defination code: > ```cpp > image::LineType type() > ``` #### lines {#lines} ```python def lines(self) > list[Line] ``` Get a list of line item description **type** func **return** returns a list composed of Line objects **static** False > C++ defination code: > ```cpp > std::vector<image::Line> lines() > ``` ### Color {#Color} Color class > C++ defination code: > ```cpp > class Color > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 21} ```python def __init__(self, ch1: int, ch2: int 0, ch3: int 0, alpha: float 0, format: Format ...) > None ``` Color constructor item description **type** func **param** **alpha**: alpha channel, value range: 0 ~ 1, 0 means transparent.<br> **static** False > C++ defination code: > ```cpp > Color(uint8_t ch1, uint8_t ch2 0, uint8_t ch3 0, float alpha 0, image::Format format image::FMT_GRAYSCALE) > ``` #### r {#r 2} Color red channel item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > uint8_t r > ``` #### g {#g} Color green channel item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > uint8_t g > ``` #### b {#b} Color blue channel item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > uint8_t b > ``` #### alpha {#alpha} Color alpha channel, value from 0.0 to 1.0, float value, 0 means transparent. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float alpha > ``` #### gray {#gray} Color gray channel item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > uint8_t gray > ``` #### format {#format 3} Color format item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > image::Format format > ``` #### hex {#hex} ```python def hex(self) > int ``` Get color's hex value item description **type** func **static** False > C++ defination code: > ```cpp > uint32_t hex() > ``` #### from\\_rgb {#from\\_rgb} ```python def from_rgb(r: int, g: int, b: int) > Color ``` Create Color object from RGB channels item description **type** func **static** True > C++ defination code: > ```cpp > static image::Color from_rgb(uint8_t r, uint8_t g, uint8_t b) > ``` #### from\\_bgr {#from\\_bgr} ```python def from_bgr(b: int, g: int, r: int) > Color ``` Create Color object from BGR channels item description **type** func **static** True > C++ defination code: > ```cpp > static image::Color from_bgr(uint8_t b, uint8_t g, uint8_t r) > ``` #### from\\_gray {#from\\_gray} ```python def from_gray(gray: int) > Color ``` Create Color object from gray channel item description **type** func **static** True > C++ defination code: > ```cpp > static image::Color from_gray(uint8_t gray) > ``` #### from\\_rgba {#from\\_rgba} ```python def from_rgba(r: int, g: int, b: int, alpha: float) > Color ``` Create Color object from RGBA channels item description **type** func **param** **alpha**: alpha channel, float value, value range: 0 ~ 1<br> **static** True > C++ defination code: > ```cpp > static image::Color from_rgba(uint8_t r, uint8_t g, uint8_t b, float alpha) > ``` #### from\\_bgra {#from\\_bgra} ```python def from_bgra(b: int, g: int, r: int, alpha: float) > Color ``` Create Color object from BGRA channels item description **type** func **param** **alpha**: alpha channel, float value, value range: 0 ~ 1<br> **static** True > C++ defination code: > ```cpp > static image::Color from_bgra(uint8_t b, uint8_t g, uint8_t r, float alpha) > ``` #### from\\_hex {#from\\_hex} ```python def from_hex(hex: int, format: Format) > Color ``` Create Color object from hex value item description **type** func **param** **hex**: hex value, e.g. 0x0000FF00, lower address if first channel<br>**format**: color format, @see image::Format<br> **static** True > C++ defination code: > ```cpp > static image::Color from_hex(uint32_t hex, image::Format &format) > ``` #### to\\_format {#to\\_format} ```python def to_format(self, format: Format) > None ``` Convert Color format item description **type** func **param** **format**: format want to convert to, @see image::Format, only support RGB888, BGR888, RGBA8888, BGRA8888, GRAYSCALE.<br> **static** False > C++ defination code: > ```cpp > void to_format(const image::Format &format) > ``` #### to\\_format2 {#to\\_format2} ```python def to_format2(self, format: Format) > Color ``` Convert color format and return a new Color object item description **type** func **param** **format**: format want to convert to, @see image::Format, only support RGB888, BGR888, RGBA8888, BGRA8888, GRAYSCALE.<br> **return** new Color object, you need to delete it manually in C++. **static** False > C++ defination code: > ```cpp > image::Color *to_format2(const image::Format &format) > ``` ### Image {#Image} Image class > C++ defination code: > ```cpp > class Image > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 22} ```python def __init__(self, width: int, height: int, format: Format ..., bg: Color ...) > None ``` Image constructor item description **type** func **param** **width**: image width, should > 0<br>**height**: image height, should > 0<br>**format**: image format @see image::Format<br>**bg**: background color, default is black, grayscale color will be faster,<br>if bg is image.COLOR_INVALID, will not fill background color, so background may be garbage(random content).<br>So you can set to image.COLOR_INVALID to save time in some case.<br> **static** False > C++ defination code: > ```cpp > Image(int width, int height, image::Format format image::Format::FMT_RGB888, const image::Color &bg image::COLOR_INVALID) > ``` #### format {#format 4} ```python def format(self) > Format ``` Get image's format item description **type** func **see** image.Format **static** False > C++ defination code: > ```cpp > image::Format format() > ``` #### size {#size 2} ```python def size(self) > Size ``` Get image's size, [width, height] item description **type** func **static** False > C++ defination code: > ```cpp > image::Size size() > ``` #### data\\_size {#data\\_size} ```python def data_size(self) > int ``` Get image's data size item description **type** func **static** False > C++ defination code: > ```cpp > int data_size() > ``` #### width {#width 2} ```python def width(self) > int ``` Get image's width item description **type** func **static** False > C++ defination code: > ```cpp > int width() > ``` #### height {#height 2} ```python def height(self) > int ``` Get image's height item description **type** func **static** False > C++ defination code: > ```cpp > int height() > ``` #### \\_\\_str\\_\\_ {#\\_\\_str\\_\\_ 2} ```python def __str__(self) > str ``` To string method item description **type** func **static** False > C++ defination code: > ```cpp > std::string __str__() > ``` #### to\\_str {#to\\_str} ```python def to_str(self) > str ``` To string method item description **type** func **static** False > C++ defination code: > ```cpp > std::string to_str() > ``` #### get\\_pixel {#get\\_pixel} ```python def get_pixel(self, x: int, y: int, rgbtuple: bool False) > list[int] ``` Get pixel of image item description **type** func **param** **x**: pixel's coordinate x. x must less than image's width<br>**y**: pixel's coordinate y. y must less than image's height<br>**rgbtuple**: switch return value method. rgbtuple decides whether to split the return or not. default is false.<br> **return** pixel value,<br>According to image format and rgbtuple, return different value:<br>format is FMT_RGB888, rgbtuple is true, return [R, G, B]; rgbtuple is false, return [RGB]<br>foramt is FMT_BGR888, rgbtuple is true, return [B, G, R]; rgbtuple is false, return [BGR]<br>format is FMT_GRAYSCALE, return [GRAY]; **static** False > C++ defination code: > ```cpp > std::vector<uint32_t> get_pixel(int x, int y, bool rgbtuple false) > ``` #### set\\_pixel {#set\\_pixel} ```python def set_pixel(self, x: int, y: int, pixel: list[int]) > maix.err.Err ``` Set pixel of image item description **type** func **param** **x**: pixel's coordinate x. x must less than image's width<br>**y**: pixel's coordinate y. y must less than image's height<br>**pixel**: pixel value, according to image format and size of pixel, has different operation:<br>format is FMT_RGB888, pixel size must be 1 or 3, if size is 1, will split pixel[0] to [R, G, B]; if size is 3, will use pixel directly<br>format is FMT_BGR888, pixel size must be 1 or 3, if size is 1, will split pixel[0] to [B, G, R]; if size is 3, will use pixel directly<br>format is FMT_GRAYSCALE, pixel size must be 1, will use pixel directly<br> **return** error code, Err::ERR_NONE is ok, other is error **static** False > C++ defination code: > ```cpp > err::Err set_pixel(int x, int y, std::vector<uint32_t> pixel) > ``` #### to\\_tensor {#to\\_tensor} ```python def to_tensor(self, chw: bool False, copy: bool True) > maix.tensor.Tensor ``` Convert Image object to tensor::Tensor object item description **type** func **param** **chw**: convert to tensor with CHW or HWC layout result, image is HWC,<br>so default chw is false, if set true, will convert to CHW layout.<br>Attention, if set chw to true, copy must be true, or will raise err.Exception.<br>**copy**: if true, will alloc memory for tensor data, else will use the memory of Image object.<br>Attention, if set chw to true, copy must be true, or will raise err.Exception.<br> **return** tensor::Tensor object pointer, an allocated tensor object **static** False > C++ defination code: > ```cpp > tensor::Tensor *to_tensor(bool chw false, bool copy true) > ``` #### to\\_tensor\\_float32 {#to\\_tensor\\_float32} ```python def to_tensor_float32(self, chw: bool False, mean: list[float] [], scale: list[float] []) > maix.tensor.Tensor ``` Convert image to float32 tensor, and support normlize with mean and scale(1/std).\\nIf mean and scale not empty, Will execute (data mean) * scale, and return float32 tensor.Tensor. item description **type** func **attention** only support grayscale, RGB, BGR, RGBA, BGRA image. **param** **chw**: convert to chw layout or not, default false.<br>**mean**: mean value, list type, can be on or three elements according to image's format. Default empty means not normalize.<br>**scale**: scale value, list type, can be on or three elements according to image's format. Default empty means not normalize.<br> **return** float32 tensor.Tensor object with new alloc memory, so you need to delete it manually in C++. **static** False > C++ defination code: > ```cpp > tensor::Tensor * to_tensor_float32(bool chw false, std::vector<float> mean std::vector<float>(), std::vector<float> scale std::vector<float>()) > ``` #### to\\_bytes {#to\\_bytes} ```python def to_bytes(*args, **kwargs) ``` Get image's data and convert to array bytes item description **type** func **param** **copy**: if true, will alloc memory and copy data to new buffer,<br>else will use the memory of Image object, delete bytes object will not affect Image object，<br>but delete Image object will make bytes object invalid, it may cause program crash !!!!<br>So use this param carefully.<br> **return** image's data bytes, need be delete by caller in C++. **static** False > C++ defination code: > ```cpp > Bytes *to_bytes(bool copy true) > ``` #### to\\_format {#to\\_format 2} ```python def to_format(self, format: Format) > Image ``` Convert image to specific format item description **type** func **param** **format**: format want to convert to, @see image::Format, only support RGB888, BGR888, RGBA8888, BGRA8888, GRAYSCALE, JPEG.<br> **return** new image object. Need be delete by caller in C++. **throw** err.Exception, if two images' format not support, **or already the format**, will raise exception **static** False > C++ defination code: > ```cpp > image::Image *to_format(const image::Format &format) > ``` #### to\\_jpeg {#to\\_jpeg} ```python def to_jpeg(self, quality: int 95, buff: capsule None, buff_size: int 0) > Image ``` Convert image to jpeg item description **type** func **param** **quality**: the quality of jpg, default is 95. For MaixCAM supported range is (50, 100], if < 50 will be fixed to 51.<br>**buff**: user's buffer, if buff is nullptr, will malloc memory for new image data, else will use buff directly<br>**buff_size**: the size of buff, if buff is nullptr, buff_size is ignored.<br> **return** new image object. Need be delete by caller in C++. **throw** err.Exception, if two images' format not support, **or already the format**, will raise exception **static** False > C++ defination code: > ```cpp > image::Image *to_jpeg(int quality 95, void *buff nullptr, size_t buff_size 0) > ``` #### draw\\_image {#draw\\_image} ```python def draw_image(self, x: int, y: int, img: Image) > Image ``` Draw image on this image item description **type** func **param** **x**: left top corner of image point's coordinate x<br>**y**: left top corner of image point's coordinate y<br>**img**: image object to draw, the caller's channel must < the args' channel,<br>e.g. caller is RGB888, args is RGBA8888, will throw exception, but caller is RGBA8888, args is RGB888 or RGBA8888 is ok<br> **return** this image object self **static** False > C++ defination code: > ```cpp > image::Image *draw_image(int x, int y, image::Image &img) > ``` #### draw\\_rect {#draw\\_rect} ```python def draw_rect(self, x: int, y: int, w: int, h: int, color: Color, thickness: int 1) > Image ``` Fill rectangle color to image item description **type** func **param** **x**: left top corner of rectangle point's coordinate x<br>**y**: left top corner of rectangle point's coordinate y<br>**w**: rectangle width<br>**h**: rectangle height<br>**color**: rectangle color<br>**thickness**: rectangle thickness(line width), by default(value is 1), 1 means fill rectangle<br> **return** this image object self **static** False > C++ defination code: > ```cpp > image::Image *draw_rect(int x, int y, int w, int h, const image::Color &color, int thickness 1) > ``` #### draw\\_line {#draw\\_line} ```python def draw_line(self, x1: int, y1: int, x2: int, y2: int, color: Color, thickness: int 1) > Image ``` Draw line on image item description **type** func **param** **x1**: start point's coordinate x<br>**y1**: start point's coordinate y<br>**x2**: end point's coordinate x<br>**y2**: end point's coordinate y<br>**color**: line color @see image::Color<br>**thickness**: line thickness(line width), by default(value is 1)<br> **return** this image object self **static** False > C++ defination code: > ```cpp > image::Image *draw_line(int x1, int y1, int x2, int y2, const image::Color &color, int thickness 1) > ``` #### draw\\_circle {#draw\\_circle} ```python def draw_circle(self, x: int, y: int, radius: int, color: Color, thickness: int 1) > Image ``` Draw circle on image item description **type** func **param** **x**: circle center point's coordinate x<br>**y**: circle center point's coordinate y<br>**radius**: circle radius<br>**color**: circle color @see image::Color<br>**thickness**: circle thickness(line width), default 1 means fill circle<br> **return** this image object self **static** False > C++ defination code: > ```cpp > image::Image *draw_circle(int x, int y, int radius, const image::Color &color, int thickness 1) > ``` #### draw\\_ellipse {#draw\\_ellipse} ```python def draw_ellipse(self, x: int, y: int, a: int, b: int, angle: float, start_angle: float, end_angle: float, color: Color, thickness: int 1) > Image ``` Draw ellipse on image item description **type** func **param** **x**: ellipse center point's coordinate x<br>**y**: ellipse center point's coordinate y<br>**a**: ellipse major axis length<br>**b**: ellipse minor axis length<br>**angle**: ellipse rotation angle<br>**start_angle**: ellipse start angle<br>**end_angle**: ellipse end angle<br>**color**: ellipse color @see image::Color<br>**thickness**: ellipse thickness(line width), by default(value is 1), 1 means fill ellipse<br> **return** this image object self **static** False > C++ defination code: > ```cpp > image::Image *draw_ellipse(int x, int y, int a, int b, float angle, float start_angle, float end_angle, const image::Color &color, int thickness 1) > ``` #### draw\\_string {#draw\\_string} ```python def draw_string(self, x: int, y: int, textstring: str, color: Color ..., scale: float 1, thickness: int 1, wrap: bool True, wrap_space: int 4, font: str '') > Image ``` Draw text on image item description **type** func **param** **x**: text left top point's coordinate x<br>**y**: text left top point's coordinate y<br>**string**: text content<br>**color**: text color @see image::Color, default is white<br>**scale**: font scale, by default(value is 1)<br>**thickness**: text thickness(line width), if negative, the glyph is filled, by default(value is 1)<br>**wrap**: if true, will auto wrap text to next line if text width > image width, by default(value is true)<br> **return** this image object self **static** False > C++ defination code: > ```cpp > image::Image *draw_string(int x, int y, const std::string &textstring, const image::Color &color image::COLOR_WHITE, float scale 1, int thickness 1, > bool wrap true, int wrap_space 4, const std::string &font \"\") > ``` #### draw\\_cross {#draw\\_cross} ```python def draw_cross(self, x: int, y: int, color: Color, size: int 5, thickness: int 1) > Image ``` Draw cross on image item description **type** func **param** **x**: cross center point's coordinate x<br>**y**: cross center point's coordinate y<br>**color**: cross color @see image::Color<br>**size**: how long the lines of the cross extend, by default(value is 5). So the line length is `2 * size + thickness`<br>**thickness**: cross thickness(line width), by default(value is 1)<br> **static** False > C++ defination code: > ```cpp > image::Image *draw_cross(int x, int y, const image::Color &color, int size 5, int thickness 1) > ``` #### draw\\_arrow {#draw\\_arrow} ```python def draw_arrow(self, x0: int, y0: int, x1: int, y1: int, color: Color, thickness: int 1) > Image ``` Draw arrow on image item description **type** func **param** **x0**: start coordinate of the arrow x0<br>**y0**: start coordinate of the arrow y0<br>**x1**: end coordinate of the arrow x1<br>**y1**: end coordinate of the arrow y1<br>**color**: cross color @see image::Color<br>**thickness**: cross thickness(line width), by default(value is 1)<br> **return** this image object self **static** False > C++ defination code: > ```cpp > image::Image *draw_arrow(int x0, int y0, int x1, int y1, const image::Color &color, int thickness 1) > ``` #### draw\\_edges {#draw\\_edges} ```python def draw_edges(self, corners: list[list[int]], color: Color, size: int 0, thickness: int 1, fill: bool False) > Image ``` Draw edges on image item description **type** func **param** **corners**: edges, [[x0, y0], [x1, y1], [x2, y2], [x3, y3]]<br>**color**: edges color @see image::Color<br>**size**: the circle of radius size. TODO: support in the future<br>**thickness**: edges thickness(line width), by default(value is 1)<br>**fill**: if true, will fill edges, by default(value is false)<br> **return** this image object self **static** False > C++ defination code: > ```cpp > image::Image *draw_edges(std::vector<std::vector<int>> corners, const image::Color &color, int size 0, int thickness 1, bool fill false) > ``` #### draw\\_keypoints {#draw\\_keypoints} ```python def draw_keypoints(self, keypoints: list[int], color: Color, size: int 4, thickness: int 1, line_thickness: int 0) > Image ``` Draw keypoints on image item description **type** func **param** **keypoints**: keypoints, [x1, y1, x2, y2...] or [x, y, rotation_andle_in_degrees, x2, y2, rotation_andle_in_degrees2](TODO: rotation_andle_in_degrees support in the future)<br>**color**: keypoints color @see image::Color<br>**size**: size of keypoints(radius)<br>**thickness**: keypoints thickness(line width), by default(value is 1 means fill circle)<br>**line_thickness**: line thickness, default 0 means not draw lines, > 0 will draw lines connect points.<br> **return** this image object self **static** False > C++ defination code: > ```cpp > image::Image *draw_keypoints(const std::vector<int> &keypoints, const image::Color &color, int size 4, int thickness 1, int line_thickness 0) > ``` #### resize {#resize} ```python def resize(self, width: int, height: int, fit: Fit ..., method: ResizeMethod ...) > Image ``` Resize image, will create a new resized image object item description **type** func **param** **width**: new width, if value is 1, will use height to calculate aspect ratio<br>**height**: new height, if value is 1, will use width to calculate aspect ratio<br>**fit**: fill, contain, cover, by default is fill<br>**method**: resize method, by default is NEAREST<br> **return** Always return a new resized image object even size not change, So in C++ you should take care of the return value to avoid memory leak.<br>And it's better to judge whether the size has changed before calling this function to make the program more efficient.<br>e.g.<br>if img >width() ! width img >height() ! height:<br>img img >resize(width, height); **static** False > C++ defination code: > ```cpp > image::Image *resize(int width, int height, image::Fit fit image::Fit::FIT_FILL, image::ResizeMethod method image::ResizeMethod::NEAREST) > ``` #### affine {#affine} ```python def affine(self, src_points: list[int], dst_points: list[int], width: int 1, height: int 1, method: ResizeMethod ...) > Image ``` Affine transform image, will create a new transformed image object, need 3 points. item description **type** func **param** **src_points**: three source points, [x1, y1, x2, y2, x3, y3]<br>**dst_points**: three destination points, [x1, y1, x2, y2, x3, y3]<br>**width**: new width, if value is 1, will use height to calculate aspect ratio<br>**height**: new height, if value is 1, will use width to calculate aspect ratio<br>**method**: resize method, by default is bilinear<br> **return** new transformed image object **static** False > C++ defination code: > ```cpp > image::Image *affine(std::vector<int> src_points, std::vector<int> dst_points, int width 1, int height 1, image::ResizeMethod method image::ResizeMethod::BILINEAR) > ``` #### perspective {#perspective} ```python def perspective(self, src_points: list[int], dst_points: list[int], width: int 1, height: int 1, method: ResizeMethod ...) > Image ``` Perspective transform image, will create a new transformed image object, need 4 points. item description **type** func **param** **src_points**: three source points, [x1, y1, x2, y2, x3, y3, x4, y4]<br>**dst_points**: three destination points, [x1, y1, x2, y2, x3, y3, x4, y4]<br>**width**: new width, if value is 1, will use height to calculate aspect ratio<br>**height**: new height, if value is 1, will use width to calculate aspect ratio<br>**method**: resize method, by default is bilinear<br> **return** new transformed image object **static** False > C++ defination code: > ```cpp > image::Image* perspective(std::vector<int> src_points, std::vector<int> dst_points, int width 1, int height 1, image::ResizeMethod method image::ResizeMethod::BILINEAR) > ``` #### copy {#copy} ```python def copy(self) > Image ``` Copy image, will create a new copied image object item description **type** func **return** new copied image object **static** False > C++ defination code: > ```cpp > image::Image *copy() > ``` #### crop {#crop} ```python def crop(self, x: int, y: int, w: int, h: int) > Image ``` Crop image, will create a new cropped image object item description **type** func **param** **x**: left top corner of crop rectangle point's coordinate x<br>**y**: left top corner of crop rectangle point's coordinate y<br>**w**: crop rectangle width<br>**h**: crop rectangle height<br> **return** new cropped image object **static** False > C++ defination code: > ```cpp > image::Image *crop(int x, int y, int w, int h) > ``` #### rotate {#rotate} ```python def rotate(self, angle: float, width: int 1, height: int 1, method: ResizeMethod ...) > Image ``` Rotate image, will create a new rotated image object item description **type** func **param** **angle**: anti clock wise rotate angle, if angle is 90 or 270, and width or height is 1, will swap width and height, or will throw exception<br>**width**: new width, if value is 1, will use height to calculate aspect ratio<br>**height**: new height, if value is 1, will use width to calculate aspect ratio<br>**method**: resize method, by default is bilinear<br> **return** new rotated image object **static** False > C++ defination code: > ```cpp > image::Image *rotate(float angle, int width 1, int height 1, image::ResizeMethod method image::ResizeMethod::BILINEAR) > ``` #### flip {#flip} ```python def flip(self, dir: FlipDir) > Image ``` Vertical flip image, and return a new image. item description **type** func **param** **dir**: flip dir, see image.FlipDir, e.g. image.FlipDir.X is vertical flip.<br> **return** new flipped image. **throw** When arg error, will throw out err.Err exception. **static** False > C++ defination code: > ```cpp > image::Image *flip(const image::FlipDir dir) > ``` #### mean\\_pool {#mean\\_pool} ```python def mean_pool(self, x_div: int, y_div: int, copy: bool False) > Image ``` Finds the mean of x_div * y_div squares in the image and returns the modified image composed of the mean of each square. item description **type** func **param** **x_div**: The width of the squares.<br>**y_div**: The height of the squares.<br>**copy**: Select whether to return a new image or modify the original image. default is false.<br>If true, returns a new image composed of the mean of each square; If false, returns the modified image composed of the mean of each square.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *mean_pool(int x_div, int y_div, bool copy false) > ``` #### midpoint\\_pool {#midpoint\\_pool} ```python def midpoint_pool(self, x_div: int, y_div: int, bias: float 0.5, copy: bool False) > Image ``` Finds the midpoint of x_div * y_div squares in the image and returns the modified image composed of the mean of each square. item description **type** func **param** **x_div**: The width of the squares.<br>**y_div**: The height of the squares.<br>**bias**: The bias of the midpoint. default is 0.5.<br>midpoint value is equal to (max * bias + min * (1 bias))<br>**copy**: Select whether to return a new image or modify the original image. default is false.<br>If true, returns a new image composed of the midpoint of each square; If false, returns the modified image composed of the midpoint of each square.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *midpoint_pool(int x_div, int y_div, double bias 0.5, bool copy false) > ``` #### compress {#compress} ```python def compress(self, quality: int 95) > Image ``` JPEG compresses the image in place, the same as to_jpeg functioin, it's recommend to use to_jpeg instead. item description **type** func **param** **quality**: The quality of the compressed image. default is 95.<br> **return** Returns the compressed JPEG image **static** False > C++ defination code: > ```cpp > image::Image *compress(int quality 95) > ``` #### clear {#clear} ```python def clear(self, mask: Image None) > Image ``` Sets all pixels in the image to zero item description **type** func **param** **mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *clear(image::Image *mask nullptr) > ``` #### mask\\_rectange {#mask\\_rectange} ```python def mask_rectange(self, x: int 1, y: int 1, w: int 1, h: int 1) > Image ``` Zeros a rectangular part of the image. If no arguments are supplied this method zeros the center of the image. item description **type** func **param** **x**: The x coordinate of the top left corner of the rectangle.<br>**y**: The y coordinate of the top left corner of the rectangle.<br>**w**: The width of the rectangle.<br>**h**: The height of the rectangle.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *mask_rectange(int x 1, int y 1, int w 1, int h 1) > ``` #### mask\\_circle {#mask\\_circle} ```python def mask_circle(self, x: int 1, y: int 1, radius: int 1) > Image ``` Zeros a circular part of the image. If no arguments are supplied this method zeros the center of the image. item description **type** func **param** **x**: The x coordinate of the center of the circle.<br>**y**: The y coordinate of the center of the circle.<br>**radius**: The radius of the circle.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *mask_circle(int x 1, int y 1, int radius 1) > ``` #### mask\\_ellipse {#mask\\_ellipse} ```python def mask_ellipse(self, x: int 1, y: int 1, radius_x: int 1, radius_y: int 1, rotation_angle_in_degrees: float 0) > Image ``` Zeros a ellipse part of the image. If no arguments are supplied this method zeros the center of the image. item description **type** func **param** **x**: The x coordinate of the center of the ellipse.<br>**y**: The y coordinate of the center of the ellipse.<br>**radius_x**: The radius of the ellipse in the x direction.<br>**radius_y**: The radius of the ellipse in the y direction.<br>**rotation_angle_in_degrees**: The rotation angle of the ellipse in degrees.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *mask_ellipse(int x 1, int y 1, int radius_x 1, int radius_y 1, float rotation_angle_in_degrees 0) > ``` #### binary {#binary} ```python def binary(self, thresholds: list[list[int]] [], invert: bool False, zero: bool False, mask: Image None, to_bitmap: bool False, copy: bool False) > Image ``` Sets all pixels in the image to black or white depending on if the pixel is inside of a threshold in the threshold list thresholds or not. item description **type** func **note** For GRAYSCALE format, Lmin and Lmax range is [0, 255]. For RGB888 format, Lmin and Lmax range is [0, 100]. **param** **thresholds**: You can define multiple thresholds.<br>For GRAYSCALE format, you can use {{Lmin, Lmax}, ...} to define one or more thresholds.<br>For RGB888 format, you can use {{Lmin, Lmax, Amin, Amax, Bmin, Bmax}, ...} to define one or more thresholds.<br>Where the upper case L,A,B represent the L,A,B channels of the LAB image format, and min, max represent the minimum and maximum values of the corresponding channels.<br>**invert**: If true, the thresholds will be inverted before the operation. default is false.<br>**zero**: If zero is true, the image will be set the pixels within the threshold to 0, other pixels remain unchanged. If zero is false, the image will be set to black or white. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br>**to_bitmap**: If true, the image will be converted to a bitmap image before thresholding. default is false. TODO: support in the future<br>**copy**: Select whether to return a new image or modify the original image. default is false.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *binary(std::vector<std::vector<int>> thresholds std::vector<std::vector<int>>(), bool invert false, bool zero false, image::Image *mask nullptr, bool to_bitmap false, bool copy false) > ``` #### invert {#invert} ```python def invert(self) > Image ``` Inverts the image in place. item description **type** func **return** Returns the image after the operation is completed **static** False > C++ defination code: > ```cpp > image::Image *invert() > ``` #### b\\_and {#b\\_and} ```python def b_and(self, other: Image, mask: Image None) > Image ``` Performs a bitwise and operation between the image and the other image. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *b_and(image::Image *other, image::Image *mask nullptr) > ``` #### b\\_nand {#b\\_nand} ```python def b_nand(self, other: Image, mask: Image None) > Image ``` Performs a bitwise nand operation between the image and the other image. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *b_nand(image::Image *other, image::Image *mask nullptr) > ``` #### b\\_or {#b\\_or} ```python def b_or(self, other: Image, mask: Image None) > Image ``` Performs a bitwise or operation between the image and the other image. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *b_or(image::Image *other, image::Image *mask nullptr) > ``` #### b\\_nor {#b\\_nor} ```python def b_nor(self, other: Image, mask: Image None) > Image ``` Performs a bitwise nor operation between the image and the other image. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *b_nor(image::Image *other, image::Image *mask nullptr) > ``` #### b\\_xor {#b\\_xor} ```python def b_xor(self, other: Image, mask: Image None) > Image ``` Performs a bitwise xor operation between the image and the other image. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *b_xor(image::Image *other, image::Image *mask nullptr) > ``` #### b\\_xnor {#b\\_xnor} ```python def b_xnor(self, other: Image, mask: Image None) > Image ``` Performs a bitwise xnor operation between the image and the other image. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *b_xnor(image::Image *other, image::Image *mask nullptr) > ``` #### awb {#awb} ```python def awb(self, max: bool False) > Image ``` Performs an auto white balance operation on the image. TODO: support in the future item description **type** func **param** **max**: if True uses the white patch algorithm instead. default is false.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *awb(bool max false) > ``` #### ccm {#ccm} ```python def ccm(self, matrix: list[float]) > Image ``` Multiples the passed (3x3) or (4x3) floating point color correction matrix with the image.\\nnote: Grayscale format is not support. item description **type** func **param** **matrix**: The color correction matrix to use. 3x3 or 4x3 matrix.<br>Weights may either be positive or negative, and the sum of each column in the 3x3 matrix should generally be 1.<br>example:<br>{<br>1, 0, 0,<br>0, 1, 0,<br>0, 0, 1,<br>}<br>Where the last row of the 4x3 matrix is an offset per color channel. If you add an offset you may wish to make the<br>weights sum to less than 1 to account for the offset.<br>example:<br>{<br>1, 0, 0,<br>0, 1, 0,<br>0, 0, 1,<br>0, 0, 0,<br>}<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *ccm(std::vector<float> &matrix) > ``` #### gamma {#gamma} ```python def gamma(self, gamma: float 1.0, contrast: float 1.0, brightness: float 0.0) > Image ``` Quickly changes the image gamma, contrast, and brightness. Create a array whose size is usually 255,\\nand use the parameters gamma, contrast, and brightness to calculate the value of the array, and then map the\\nimage pixel value through the value of the array.\\nThe calculation method for array is: array[array_idx] (powf((array_idx / 255.0), (1 / gamma)) * contrast + brightness) * scale,\\n`powf` is a function used to calculate floating point power.\\n`array` is the array used for mapping.\\n`array_idx` is the index of the array, the maximum value is determined according to the image format, usually 255.\\n`scale` is a constant, the value is determined by the image format, usually 255.\\nMapping method:\\nAssume that a pixel value in the image is 128, then map the pixel value to the value of array[128]\\nUsers can adjust the value of the array through the gamma, contrast, and brightness parameters. item description **type** func **param** **gamma**: The contrast gamma greater than 1.0 makes the image darker in a non linear manner while less than 1.0 makes the image brighter. default is 1.0.<br>**contrast**: The contrast value greater than 1.0 makes the image brighter in a linear manner while less than 1.0 makes the image darker. default is 1.0.<br>**brightness**: The brightness value greater than 0.0 makes the image brighter in a constant manner while less than 0.0 makes the image darker. default is 0.0.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *gamma(double gamma 1.0, double contrast 1.0, double brightness 0.0) > ``` #### gamma\\_corr {#gamma\\_corr} ```python def gamma_corr(self, gamma: float, contrast: float 1.0, brightness: float 0.0) > Image ``` Alias for Image.gamma. item description **type** func **param** **gamma**: The contrast gamma greater than 1.0 makes the image darker in a non linear manner while less than 1.0 makes the image brighter. default is 1.0.<br>**contrast**: The contrast value greater than 1.0 makes the image brighter in a linear manner while less than 1.0 makes the image darker. default is 1.0.<br>**brightness**: The brightness value greater than 0.0 makes the image brighter in a constant manner while less than 0.0 makes the image darker. default is 0.0.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *gamma_corr(double gamma, double contrast 1.0, double brightness 0.0) > ``` #### negate {#negate} ```python def negate(self) > Image ``` Flips (numerically inverts) all pixels values in an image item description **type** func **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *negate() > ``` #### replace {#replace} ```python def replace(self, other: Image None, hmirror: bool False, vflip: bool False, transpose: bool False, mask: Image None) > Image ``` Replaces all pixels in the image with the corresponding pixels in the other image. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on.<br>**hmirror**: If true, the image will be horizontally mirrored before the operation. default is false.<br>**vflip**: If true, the image will be vertically flipped before the operation. default is false.<br>**transpose**: If true, the image can be used to rotate 90 degrees or 270 degrees.<br>hmirror false, vflip false, transpose false, the image will not be rotated.<br>hmirror false, vflip true, transpose true, the image will be rotated 90 degrees.<br>hmirror true, vflip true, transpose false, the image will be rotated 180 degrees.<br>hmirror true, vflip false, transpose true, the image will be rotated 270 degrees.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *replace(image::Image *other nullptr, bool hmirror false, bool vflip false, bool transpose false, image::Image *mask nullptr) > ``` #### set {#set} ```python def set(self, other: Image, hmirror: bool False, vflip: bool False, transpose: bool False, mask: Image None) > Image ``` Alias for Image::replace. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on.<br>**hmirror**: If true, the image will be horizontally mirrored before the operation. default is false.<br>**vflip**: If true, the image will be vertically flipped before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *set(image::Image *other, bool hmirror false, bool vflip false, bool transpose false, image::Image *mask nullptr) > ``` #### add {#add} ```python def add(self, other: Image, mask: Image None) > Image ``` Adds the other image to the image. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *add(image::Image *other, image::Image *mask nullptr) > ``` #### sub {#sub} ```python def sub(self, other: Image, reverse: bool False, mask: Image None) > Image ``` Subtracts the other image from the image. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**reverse**: If true, the image will be reversed before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *sub(image::Image *other, bool reverse false, image::Image *mask nullptr) > ``` #### mul {#mul} ```python def mul(self, other: Image, invert: bool False, mask: Image None) > Image ``` Multiplies the image by the other image.\\nNote: This method is meant for image blending and cannot multiply the pixels in the image by a scalar like 2. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**invert**: If true, the image will be change the multiplication operation from a*b to 1/((1/a)*(1/b)).<br>In particular, this lightens the image instead of darkening it (e.g. multiply versus burn operations). default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *mul(image::Image *other, bool invert false, image::Image *mask nullptr) > ``` #### div {#div} ```python def div(self, other: Image, invert: bool False, mod: bool False, mask: Image None) > Image ``` Divides the image by the other image.\\nThis method is meant for image blending and cannot divide the pixels in the image by a scalar like 2. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on. TODO: support path?<br>**invert**: If true, the image will be change the division direction from a/b to b/a. default is false.<br>**mod**: If true, the image will be change the division operation to the modulus operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *div(image::Image *other, bool invert false, bool mod false, image::Image *mask nullptr) > ``` #### min {#min} ```python def min(self, other: Image, mask: Image None) > Image ``` Caculate the minimum of each pixel in the image and the other image. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *min(image::Image *other, image::Image *mask nullptr) > ``` #### max {#max} ```python def max(self, other: Image, mask: Image None) > Image ``` Caculate the maximum of each pixel in the image and the other image. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *max(image::Image *other, image::Image *mask nullptr) > ``` #### difference {#difference} ```python def difference(self, other: Image, mask: Image None) > Image ``` Caculate the absolute value of the difference between each pixel in the image and the other image. item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *difference(image::Image *other, image::Image *mask nullptr) > ``` #### blend {#blend} ```python def blend(self, other: Image, alpha: int 128, mask: Image None) > Image ``` Blends the image with the other image.\\nres alpha * this_img / 256 + (256 alpha) * other_img / 256 item description **type** func **param** **other**: The other image should be an image and should be the same size as the image being operated on.<br>**alpha**: The alpha value of the blend, the value range is [0, 256],default is 128.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *blend(image::Image *other, int alpha 128, image::Image *mask nullptr) > ``` #### histeq {#histeq} ```python def histeq(self, adaptive: bool False, clip_limit: int 1, mask: Image None) > Image ``` Runs the histogram equalization algorithm on the image. item description **type** func **param** **adaptive**: If true, an adaptive histogram equalization method will be run on the image instead which as generally better results than non adaptive histogram qualization but a longer run time. default is false.<br>**clip_limit**: Provides a way to limit the contrast of the adaptive histogram qualization. Use a small value for this, like 10, to produce good histogram equalized contrast limited images. default is 1.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *histeq(bool adaptive false, int clip_limit 1, image::Image *mask nullptr) > ``` #### mean {#mean} ```python def mean(self, size: int, threshold: bool False, offset: int 0, invert: bool False, mask: Image None) > Image ``` Standard mean blurring filter using a box filter.\\nThe parameters offset and invert are valid when threshold is True. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**threshold**: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br>**offset**: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *mean(int size, bool threshold false, int offset 0, bool invert false, image::Image *mask nullptr) > ``` #### median {#median} ```python def median(self, size: int, percentile: float 0.5, threshold: bool False, offset: int 0, invert: bool False, mask: Image None) > Image ``` Runs the median filter on the image. The median filter is the best filter for smoothing surfaces while preserving edges but it is very slow. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**percentile**: This parameter controls the percentile of the value used in the kernel. You can set this to 0 for a min filter, 0.25 for a lower quartile filter, 0.75 for an upper quartile filter, and 1.0 for a max filter. default is 0.5.<br>**threshold**: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br>**offset**: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *median(int size, double percentile 0.5, bool threshold false, int offset 0, bool invert false, image::Image *mask nullptr) > ``` #### mode {#mode} ```python def mode(self, size: int, threshold: bool False, offset: int 0, invert: bool False, mask: Image None) > Image ``` Runs the mode filter on the image by replacing each pixel with the mode of their neighbors. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**threshold**: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br>**offset**: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *mode(int size, bool threshold false, int offset 0, bool invert false, image::Image *mask nullptr) > ``` #### midpoint {#midpoint} ```python def midpoint(self, size: int, bias: float 0.5, threshold: bool False, offset: int 0, invert: bool False, mask: Image None) > Image ``` Runs the midpoint filter on the image.This filter finds the midpoint (max * bias + min * (1 bias)) of each pixel neighborhood in the image. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**bias**: The bias of the midpoint. default is 0.5.<br>**threshold**: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br>**offset**: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *midpoint(int size, double bias 0.5, bool threshold false, int offset 0, bool invert false, image::Image *mask nullptr) > ``` #### morph {#morph} ```python def morph(self, size: int, kernel: list[int], mul: float 1, add: float 0.0, threshold: bool False, offset: int 0, invert: bool False, mask: Image None) > Image ``` Convolves the image by a filter kernel. This allows you to do general purpose convolutions on an image. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**kernel**: The kernel used for convolution. The kernel should be a list of lists of numbers. The kernel should be the same size as the actual kernel size.<br>**mul**: This parameter is used to multiply the convolved pixel results. default is auto.<br>**add**: This parameter is the value to be added to each convolution pixel result. default is 0.0.<br>**threshold**: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br>**offset**: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *morph(int size, std::vector<int> kernel, float mul 1, float add 0.0, bool threshold false, int offset 0, bool invert false, image::Image *mask nullptr) > ``` #### gaussian {#gaussian} ```python def gaussian(self, size: int, unsharp: bool False, mul: float 1, add: float 0.0, threshold: bool False, offset: int 0, invert: bool False, mask: Image None) > Image ``` Convolves the image by a smoothing guassian kernel. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**unsharp**: If true, this method will perform an unsharp mask operation instead of gaussian filtering operation, this improves the clarity of image edges. default is false.<br>**mul**: This parameter is used to multiply the convolved pixel results. default is auto.<br>**add**: This parameter is the value to be added to each convolution pixel result. default is 0.0.<br>**threshold**: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br>**offset**: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *gaussian(int size, bool unsharp false, float mul 1, float add 0.0, bool threshold false, int offset 0, bool invert false, image::Image *mask nullptr) > ``` #### laplacian {#laplacian} ```python def laplacian(self, size: int, sharpen: bool False, mul: float 1, add: float 0.0, threshold: bool False, offset: int 0, invert: bool False, mask: Image None) > Image ``` Convolves the image by a edge detecting laplacian kernel. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**sharpen**: If True, this method will sharpen the image instead of an unthresholded edge detection image. Then increase the kernel size to improve image clarity. default is false.<br>**mul**: This parameter is used to multiply the convolved pixel results. default is auto.<br>**add**: This parameter is the value to be added to each convolution pixel result. default is 0.0.<br>**threshold**: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br>**offset**: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *laplacian(int size, bool sharpen false, float mul 1, float add 0.0, bool threshold false, int offset 0, bool invert false, image::Image *mask nullptr) > ``` #### bilateral {#bilateral} ```python def bilateral(self, size: int, color_sigma: float 0.1, space_sigma: float 1, threshold: bool False, offset: int 0, invert: bool False, mask: Image None) > Image ``` Convolves the image by a bilateral filter. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**color_sigma**: Controls how closely colors are matched using the bilateral filter. default is 0.1.<br>**space_sigma**: Controls how closely pixels space wise are blurred with each other. default is 1.<br>**threshold**: If true, which will enable adaptive thresholding of the image which sets pixels to white or black based on a pixel’s brightness in relation to the brightness of the kernel of pixels around them.<br>default is false.<br>**offset**: The larger the offset value, the lower brightness pixels on the original image will be set to white. default is 0.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *bilateral(int size, double color_sigma 0.1, double space_sigma 1, bool threshold false, int offset 0, bool invert false, image::Image *mask nullptr) > ``` #### linpolar {#linpolar} ```python def linpolar(self, reverse: bool False) > Image ``` Re project’s and image from cartessian coordinates to linear polar coordinates. item description **type** func **param** **reverse**: If true, the image will be reverse polar transformed. default is false.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *linpolar(bool reverse false) > ``` #### logpolar {#logpolar} ```python def logpolar(self, reverse: bool False) > Image ``` Re project’s and image from cartessian coordinates to log polar coordinates. item description **type** func **param** **reverse**: If true, the image will be reverse polar transformed. default is false.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *logpolar(bool reverse false) > ``` #### lens\\_corr {#lens\\_corr} ```python def lens_corr(self, strength: float 1.8, zoom: float 1.0, x_corr: float 0.0, y_corr: float 0.0) > Image ``` Performs a lens correction operation on the image. TODO: support in the future item description **type** func **param** **strength**: The strength of the lens correction. default is 1.8.<br>**zoom**: The zoom of the lens correction. default is 1.0.<br>**x_corr**: The x correction of the lens correction. default is 0.0.<br>**y_corr**: The y correction of the lens correction. default is 0.0.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *lens_corr(double strength 1.8, double zoom 1.0, double x_corr 0.0, double y_corr 0.0) > ``` #### rotation\\_corr {#rotation\\_corr} ```python def rotation_corr(self, x_rotation: float 0.0, y_rotation: float 0.0, z_rotation: float 0.0, x_translation: float 0.0, y_translation: float 0.0, zoom: float 1.0, fov: float 60.0, corners: list[float] []) > Image ``` Performs a rotation correction operation on the image. TODO: support in the future item description **type** func **param** **x_rotation**: The x rotation of the rotation correction. default is 0.0.<br>**y_rotation**: The y rotation of the rotation correction. default is 0.0.<br>**z_rotation**: The z rotation of the rotation correction. default is 0.0.<br>**x_translation**: The x translation of the rotation correction. default is 0.0.<br>**y_translation**: The y translation of the rotation correction. default is 0.0.<br>**zoom**: The zoom of the rotation correction. default is 1.0.<br>**fov**: The fov of the rotation correction. default is 60.0.<br>**corners**: The corners of the rotation correction. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *rotation_corr(double x_rotation 0.0, double y_rotation 0.0, double z_rotation 0.0, double x_translation 0.0, double y_translation 0.0, double zoom 1.0, double fov 60.0, std::vector<float> corners std::vector<float>()) > ``` #### get\\_histogram {#get\\_histogram} ```python def get_histogram(self, thresholds: list[list[int]] [], invert: bool False, roi: list[int] [], bins: int 1, l_bins: int 100, a_bins: int 256, b_bins: int 256, difference: Image None) > Histogram ``` Computes the normalized histogram on all color channels and returns a image::Histogram object. item description **type** func **note** For GRAYSCALE format, Lmin and Lmax range is [0, 255]. For RGB888 format, Lmin and Lmax range is [0, 100]. **param** **thresholds**: You can define multiple thresholds.<br>For GRAYSCALE format, you can use {{Lmin, Lmax}, ...} to define one or more thresholds.<br>For RGB888 format, you can use {{Lmin, Lmax, Amin, Amax, Bmin, Bmax}, ...} to define one or more thresholds.<br>Where the upper case L,A,B represent the L,A,B channels of the LAB image format, and min, max represent the minimum and maximum values of the corresponding channels.<br>**invert**: If true, the thresholds will be inverted before the operation. default is false.<br>**roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**bins**: The number of bins to use for the histogram.<br>In GRAYSCALE format, setting range is [2, 256], default is 100.<br>In RGB888 format, setting range is [2, 100], default is 100.<br>**l_bins**: The number of bins to use for the l channel of the histogram. Only valid in RGB888 format.<br>If an invalid value is set, bins will be used instead. The setting range is [2, 100], default is 100.<br>**a_bins**: The number of bins to use for the a channel of the histogram.<br>Only valid in RGB888 format.The setting range is [2, 256], default is 256.<br>**b_bins**: The number of bins to use for the b channel of the histogram.<br>Only valid in RGB888 format. The setting range is [2, 256], default is 256.<br>**difference**: difference may be set to an image object to cause this method to operate on the difference image between the current image and the difference image object.<br>default is None.<br> **return** Returns image::Histogram object **static** False > C++ defination code: > ```cpp > image::Histogram get_histogram(std::vector<std::vector<int>> thresholds std::vector<std::vector<int>>(), bool invert false, std::vector<int> roi std::vector<int>(), int bins 1, int l_bins 100, int a_bins 256, int b_bins 256, image::Image *difference nullptr) > ``` #### get\\_statistics {#get\\_statistics 2} ```python def get_statistics(self, thresholds: list[list[int]] [], invert: bool False, roi: list[int] [], bins: int 1, l_bins: int 1, a_bins: int 1, b_bins: int 1, difference: Image None) > Statistics ``` Gets the statistics of the image. TODO: support in the future item description **type** func **note** For GRAYSCALE format, Lmin and Lmax range is [0, 255]. For RGB888 format, Lmin and Lmax range is [0, 100]. **param** **thresholds**: You can define multiple thresholds.<br>For GRAYSCALE format, you can use {{Lmin, Lmax}, ...} to define one or more thresholds.<br>For RGB888 format, you can use {{Lmin, Lmax, Amin, Amax, Bmin, Bmax}, ...} to define one or more thresholds.<br>Where the upper case L,A,B represent the L,A,B channels of the LAB image format, and min, max represent the minimum and maximum values of the corresponding channels.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**bins**: The number of bins to use for the statistics. default is 1.<br>**l_bins**: The number of bins to use for the l channel of the statistics. default is 1.<br>**a_bins**: The number of bins to use for the a channel of the statistics. default is 1.<br>**b_bins**: The number of bins to use for the b channel of the statistics. default is 1.<br>**difference**: The difference image to use for the statistics. default is None.<br> **return** Returns the statistics of the image **static** False > C++ defination code: > ```cpp > image::Statistics get_statistics(std::vector<std::vector<int>> thresholds std::vector<std::vector<int>>(), bool invert false, std::vector<int> roi std::vector<int>(), int bins 1, int l_bins 1, int a_bins 1, int b_bins 1, image::Image *difference nullptr) > ``` #### get\\_regression {#get\\_regression} ```python def get_regression(self, thresholds: list[list[int]] [], invert: bool False, roi: list[int] [], x_stride: int 2, y_stride: int 1, area_threshold: int 10, pixels_threshold: int 10, robust: bool False) > list[Line] ``` Gets the regression of the image. item description **type** func **note** For GRAYSCALE format, Lmin and Lmax range is [0, 255]. For RGB888 format, Lmin and Lmax range is [0, 100]. **param** **thresholds**: You can define multiple thresholds.<br>For GRAYSCALE format, you can use {{Lmin, Lmax}, ...} to define one or more thresholds.<br>For RGB888 format, you can use {{Lmin, Lmax, Amin, Amax, Bmin, Bmax}, ...} to define one or more thresholds.<br>Where the upper case L,A,B represent the L,A,B channels of the LAB image format, and min, max represent the minimum and maximum values of the corresponding channels.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**x_stride**: The x stride to use for the regression. default is 2.<br>**y_stride**: The y stride to use for the regression. default is 1.<br>**area_threshold**: The area threshold to use for the regression. default is 10.<br>**pixels_threshold**: The pixels threshold to use for the regression. default is 10.<br>**robust**: If true, the regression will be robust. default is false.<br> **return** Returns the regression of the image **static** False > C++ defination code: > ```cpp > std::vector<image::Line> get_regression(std::vector<std::vector<int>> thresholds std::vector<std::vector<int>>(), bool invert false, std::vector<int> roi std::vector<int>(), int x_stride 2, int y_stride 1, int area_threshold 10, int pixels_threshold 10, bool robust false) > ``` #### save {#save} ```python def save(self, path: str, quality: int 95) > maix.err.Err ``` Save image to file item description **type** func **param** **path**: file path<br>**quality**: image quality, by default(value is 95), support jpeg and png format<br> **return** error code, err::ERR_NONE is ok, other is error **static** False > C++ defination code: > ```cpp > err::Err save(const char *path, int quality 95) > ``` #### flood\\_fill {#flood\\_fill} ```python def flood_fill(self, x: int, y: int, seed_threshold: float 0.05, floating_threshold: float 0.05, color: Color ..., invert: bool False, clear_background: bool False, mask: Image None) > Image ``` Flood fills a region of the image starting from location x, y. item description **type** func **param** **x**: The x coordinate of the seed point.<br>**y**: The y coordinate of the seed point.<br>**seed_threshold**: The seed_threshold value controls how different any pixel in the fill area may be from the original starting pixel. default is 0.05.<br>**floating_threshold**: The floating_threshold value controls how different any pixel in the fill area may be from any neighbor pixels. default is 0.05.<br>**color**: The color to fill the region with. default is white.<br>**invert**: If true, the image will be inverted before the operation. default is false.<br>**clear_background**: If true, the background will be cleared before the operation. default is false.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None. FIXME: the mask image works abnormally<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *flood_fill(int x, int y, float seed_threshold 0.05, float floating_threshold 0.05, image::Color color image::COLOR_WHITE, bool invert false, bool clear_background false, image::Image *mask nullptr) > ``` #### erode {#erode} ```python def erode(self, size: int, threshold: int 1, mask: Image None) > Image ``` Erodes the image in place. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**threshold**: The number of pixels in the kernel that are not 0. If it is less than or equal to the threshold, set the center pixel to black. default is (kernel_size 1).<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *erode(int size, int threshold 1, image::Image *mask nullptr) > ``` #### dilate {#dilate} ```python def dilate(self, size: int, threshold: int 0, mask: Image None) > Image ``` Dilates the image in place. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**threshold**: The number of pixels in the kernel that are not 0. If it is greater than or equal to the threshold, set the center pixel to white. default is 0.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *dilate(int size, int threshold 0, image::Image *mask nullptr) > ``` #### open {#open} ```python def open(self, size: int, threshold: int 0, mask: Image None) > Image ``` Performs erosion and dilation on an image in order. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**threshold**: As the threshold for erosion and dilation, the actual threshold for erosion is (kernel_size 1 threshold), the actual threshold for dialation is threshold. default is 0.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *open(int size, int threshold 0, image::Image *mask nullptr) > ``` #### close {#close} ```python def close(self, size: int, threshold: int 0, mask: Image None) > Image ``` Performs dilation and erosion on an image in order. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**threshold**: As the threshold for erosion and dilation, the actual threshold for erosion is (kernel_size 1 threshold), the actual threshold for dialation is threshold. default is 0.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *close(int size, int threshold 0, image::Image *mask nullptr) > ``` #### top\\_hat {#top\\_hat} ```python def top_hat(self, size: int, threshold: int 0, mask: Image None) > Image ``` Returns the image difference of the image and Image.open()’ed image. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**threshold**: As the threshold for open method. default is 0.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *top_hat(int size, int threshold 0, image::Image *mask nullptr) > ``` #### black\\_hat {#black\\_hat} ```python def black_hat(self, size: int, threshold: int 0, mask: Image None) > Image ``` Returns the image difference of the image and Image.close()’ed image. item description **type** func **param** **size**: Kernel size. The actual kernel size is ((size * 2) + 1) * ((size * 2) + 1). Use 1(3x3 kernel), 2(5x5 kernel).<br>**threshold**: As the threshold for close method. default is 0.<br>**mask**: Mask is another image to use as a pixel level mask for the operation. The mask should be an image with just black or white pixels and should be the same size as the image being operated on.<br>Only pixels set in the mask are modified. default is None.<br> **return** Returns the image after the operation is completed. **static** False > C++ defination code: > ```cpp > image::Image *black_hat(int size, int threshold 0, image::Image *mask nullptr) > ``` #### find\\_blobs {#find\\_blobs} ```python def find_blobs(self, thresholds: list[list[int]] [], invert: bool False, roi: list[int] [], x_stride: int 2, y_stride: int 1, area_threshold: int 10, pixels_threshold: int 10, merge: bool False, margin: int 0, x_hist_bins_max: int 0, y_hist_bins_max: int 0) > list[Blob] ``` Finds all blobs in the image and returns a list of image.Blob class which describe each Blob.\\nPlease see the image.Blob object more more information. item description **type** func **note** For GRAYSCALE format, Lmin and Lmax range is [0, 255]. For RGB888 format, Lmin and Lmax range is [0, 100]. **param** **thresholds**: You can define multiple thresholds.<br>For GRAYSCALE format, you can use {{Lmin, Lmax}, ...} to define one or more thresholds.<br>For RGB888 format, you can use {{Lmin, Lmax, Amin, Amax, Bmin, Bmax}, ...} to define one or more thresholds.<br>Where the upper case L,A,B represent the L,A,B channels of the LAB image format, and min, max represent the minimum and maximum values of the corresponding channels.<br>**invert**: if true, will invert thresholds before find blobs, default is false<br>**roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**x_stride**: x stride is the number of x pixels to skip when doing the hough transform. default is 2<br>**y_stride**: y_stride is the number of y pixels to skip when doing the hough transform. default is 1<br>**area_threshold**: area threshold, if the blob area is smaller than area_threshold, the blob is not returned, default is 10<br>**pixels_threshold**: pixels threshold, if the blob pixels is smaller than area_threshold, the blob is not returned,, default is 10.<br>when x_stride and y_stride is equal to 1, pixels_threshold is equivalent to area_threshold<br>**merge**: if True merges all not filtered out blobs whos bounding rectangles intersect each other. default is false<br>**margin**: margin can be used to increase or decrease the size of the bounding rectangles for blobs during the intersection test.<br>For example, with a margin of 1 blobs whos bounding rectangles are 1 pixel away from each other will be merged. default is 0<br>**x_hist_bins_max**: if set to non zero populates a histogram buffer in each blob object with an x_histogram projection of all columns in the object. This value then sets the number of bins for that projection.<br>**y_hist_bins_max**: if set to non zero populates a histogram buffer in each blob object with an y_histogram projection of all rows in the object. This value then sets the number of bins for that projection.<br> **return** Return the blob when found blobs, format is (blob1, blob2, ...), you can use blob class methods to do more operations. **static** False > C++ defination code: > ```cpp > std::vector<image::Blob> find_blobs(std::vector<std::vector<int>> thresholds std::vector<std::vector<int>>(), bool invert false, std::vector<int> roi std::vector<int>(), int x_stride 2, int y_stride 1, int area_threshold 10, int pixels_threshold 10, bool merge false, int margin 0, int x_hist_bins_max 0, int y_hist_bins_max 0) > ``` #### find\\_lines {#find\\_lines} ```python def find_lines(self, roi: list[int] [], x_stride: int 2, y_stride: int 1, threshold: float 1000, theta_margin: float 25, rho_margin: float 25) > list[Line] ``` Find lines in image item description **type** func **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**x_stride**: x stride is the number of x pixels to skip when doing the hough transform. default is 2<br>**y_stride**: y_stride is the number of y pixels to skip when doing the hough transform. default is 1<br>**threshold**: threshold threshold controls what lines are detected from the hough transform. Only lines with a magnitude greater than or equal to threshold are returned.<br>The right value of threshold for your application is image dependent. default is 1000.<br>**theta_margin**: theta_margin controls the merging of detected lines. default is 25.<br>**rho_margin**: rho_margin controls the merging of detected lines. default is 25.<br> **return** Return the line when found lines, format is (line1, line2, ...), you can use line class methods to do more operations **static** False > C++ defination code: > ```cpp > std::vector<image::Line> find_lines(std::vector<int> roi std::vector<int>(), int x_stride 2, int y_stride 1, double threshold 1000, double theta_margin 25, double rho_margin 25) > ``` #### find\\_line\\_segments {#find\\_line\\_segments} ```python def find_line_segments(self, roi: list[int] [], merge_distance: int 0, max_theta_difference: int 15) > list[Line] ``` Finds all line segments in the image. item description **type** func **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**merge_distance**: The maximum distance between two lines to merge them. default is 0.<br>**max_theta_difference**: The maximum difference between two lines to merge them. default is 15.<br> **return** Return the line when found lines, format is (line1, line2, ...), you can use line class methods to do more operations **static** False > C++ defination code: > ```cpp > std::vector<image::Line> find_line_segments(std::vector<int> roi std::vector<int>(), int merge_distance 0, int max_theta_difference 15) > ``` #### search\\_line\\_path {#search\\_line\\_path} ```python def search_line_path(self, threshold: int 30, merge_degree: int 10, min_len_of_new_path: int 10) > list[LineGroup] ``` Search the path of line item description **type** func **param** **threshold**: Threshold for finding a line, the larger the value the more accurate the line is found<br>**merge_degree**: Minimum angle difference required when merging multiple lines<br>**min_len_of_new_path**: The minimum length of a new path, if the crossing length exceeds this value, it is considered a new path.<br> **return** Return the line when found lines, format is (groupline1, groupline2, ...), you can use LineGroup class methods to do more operations **static** False > C++ defination code: > ```cpp > std::vector<image::LineGroup> search_line_path(int threshold 30, int merge_degree 10, int min_len_of_new_path 10) > ``` #### find\\_circles {#find\\_circles} ```python def find_circles(self, roi: list[int] [], x_stride: int 2, y_stride: int 1, threshold: int 2000, x_margin: int 10, y_margin: int 10, r_margin: int 10, r_min: int 2, r_max: int 1, r_step: int 2) > list[Circle] ``` Find circles in image item description **type** func **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**x_stride**: x stride is the number of x pixels to skip when doing the hough transform. default is 2<br>**y_stride**: y_stride is the number of y pixels to skip when doing the hough transform. default is 1<br>**threshold**: threshold controls what circles are detected from the hough transform. Only circles with a magnitude greater than or equal to threshold are returned.<br>The right value of threshold for your application is image dependent.<br>**x_margin**: x_margin controls the merging of detected circles. Circles which are x_margin, y_margin, and r_margin pixels apart are merged. default is 10<br>**y_margin**: y_margin controls the merging of detected circles. Circles which are x_margin, y_margin, and r_margin pixels apart are merged. default is 10<br>**r_margin**: r_margin controls the merging of detected circles. Circles which are x_margin, y_margin, and r_margin pixels apart are merged. default is 10<br>**r_min**: r_min controls the minimum circle radius detected. Increase this to speed up the algorithm. default is 2<br>**r_max**: r_max controls the maximum circle radius detected. Decrease this to speed up the algorithm. default is min(roi.w / 2, roi.h / 2)<br>**r_step**: r_step controls how to step the radius detection by. default is 2.<br> **return** Return the circle when found circles, format is (circle1, circle2, ...), you can use circle class methods to do more operations **static** False > C++ defination code: > ```cpp > std::vector<image::Circle> find_circles(std::vector<int> roi std::vector<int>(), int x_stride 2, int y_stride 1, int threshold 2000, int x_margin 10, int y_margin 10, int r_margin 10, int r_min 2, int r_max 1, int r_step 2) > ``` #### find\\_rects {#find\\_rects} ```python def find_rects(self, roi: list[int] [], threshold: int 10000) > list[Rect] ``` Finds all rects in the image. item description **type** func **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**threshold**: The threshold to use for the rects. default is 10000.<br> **return** Returns the rects of the image **static** False > C++ defination code: > ```cpp > std::vector<image::Rect> find_rects(std::vector<int> roi std::vector<int>(), int threshold 10000) > ``` #### find\\_qrcodes {#find\\_qrcodes} ```python def find_qrcodes(self, roi: list[int] [], decoder_type: QRCodeDecoderType ...) > list[QRCode] ``` Finds all qrcodes in the image. item description **type** func **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**decoder_type**: Select the QR code decoding method. Choosing QRCODE_DECODER_TYPE_QUIRC allows for retrieving QR code version, ECC level, mask, data type, and other details,<br>though it may decode slower at lower resolutions. Opting for QRCODE_DECODER_TYPE_ZBAR enables faster decoding at lower resolutions but may slow down at higher resolutions,<br>providing only the QR code content and position information. default is QRCODE_DECODER_TYPE_ZBAR.<br>Choosing the QRCODE_DECODER_TYPE_ZXING option will use the ZXing library for decoding. Supports both QRCode and Datamatrix.<br>Can be used as an alternative to function find_datamatrices to decode Datamatrix codes.<br>If you find that find_datamatrices is not working well for your Datamatrix codes, you can try using this option instead.<br>Provides only the QR code/ datamatrix content and position information. default is QRCODE_DECODER_TYPE_ZXING.<br> **return** Returns the qrcodes / (and/or datamatrix for option ZXing) of the image **static** False > C++ defination code: > ```cpp > std::vector<image::QRCode> find_qrcodes(std::vector<int> roi std::vector<int>(), image::QRCodeDecoderType decoder_type image::QRCodeDecoderType::QRCODE_DECODER_TYPE_ZBAR) > ``` #### find\\_apriltags {#find\\_apriltags} ```python def find_apriltags(self, roi: list[int] [], families: ApriltagFamilies ..., fx: float 1, fy: float 1, cx: int 1, cy: int 1) > list[AprilTag] ``` Finds all apriltags in the image. item description **type** func **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**families**: The families to use for the apriltags. default is TAG36H11.<br>**fx**: The camera X focal length in pixels, default is 1.<br>**fy**: The camera Y focal length in pixels, default is 1.<br>**cx**: The camera X center in pixels, default is image.width / 2.<br>**cy**: The camera Y center in pixels, default is image.height / 2.<br> **return** Returns the apriltags of the image **static** False > C++ defination code: > ```cpp > std::vector<image::AprilTag> find_apriltags(std::vector<int> roi std::vector<int>(), image::ApriltagFamilies families image::ApriltagFamilies::TAG36H11, float fx 1, float fy 1, int cx 1, int cy 1) > ``` #### find\\_datamatrices {#find\\_datamatrices} ```python def find_datamatrices(self, roi: list[int] [], effort: int 200) > list[DataMatrix] ``` Finds all datamatrices in the image. item description **type** func **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**effort**: Controls how much time to spend trying to find data matrix matches. default is 200.<br> **return** Returns the datamatrices of the image **static** False > C++ defination code: > ```cpp > std::vector<image::DataMatrix> find_datamatrices(std::vector<int> roi std::vector<int>(), int effort 200) > ``` #### find\\_barcodes {#find\\_barcodes} ```python def find_barcodes(self, roi: list[int] []) > list[BarCode] ``` Finds all barcodes in the image. item description **type** func **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br> **return** Returns the barcodes of the image **static** False > C++ defination code: > ```cpp > std::vector<image::BarCode> find_barcodes(std::vector<int> roi std::vector<int>()) > ``` #### find\\_displacement {#find\\_displacement} ```python def find_displacement(self, template_image: Image, roi: list[int] [], template_roi: list[int] [], logpolar: bool False) > Displacement ``` Finds the displacement between the image and the template. TODO: support in the future\\nnote: this method must be used on power of 2 image sizes item description **type** func **param** **template_image**: The template image.<br>**roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**template_roi**: The region of interest rectangle (x, y, w, h) to work in. If not specified, it is equal to the image rectangle.<br>**logpolar**: If true, it will instead find rotation and scale changes between the two images. default is false.<br> **return** Returns the displacement of the image **static** False > C++ defination code: > ```cpp > image::Displacement find_displacement(image::Image &template_image, std::vector<int> roi std::vector<int>(), std::vector<int> template_roi std::vector<int>(), bool logpolar false) > ``` #### find\\_template {#find\\_template} ```python def find_template(self, template_image: Image, threshold: float, roi: list[int] [], step: int 2, search: TemplateMatch ...) > list[int] ``` Finds the template in the image. item description **type** func **param** **template_image**: The template image.<br>**threshold**: Threshold is floating point number (0.0 1.0) where a higher threshold prevents false positives while lowering the detection rate while a lower threshold does the opposite.<br>**roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image. Only valid in SEARCH_EX mode.<br>**step**: The step size to use for the template. default is 2. Only valid in SEARCH_EX mode<br>**search**: The search method to use for the template. default is SEARCH_EX.<br> **return** Returns a bounding box tuple (x, y, w, h) for the matching location otherwise None. **static** False > C++ defination code: > ```cpp > std::vector<int> find_template(image::Image &template_image, float threshold, std::vector<int> roi std::vector<int>(), int step 2, image::TemplateMatch search image::TemplateMatch::SEARCH_EX) > ``` #### find\\_features {#find\\_features} ```python def find_features(self, cascade: int, threshold: float 0.5, scale: float 1.5, roi: list[int] []) > list[int] ``` Finds the features in the image. TODO: support in the future item description **type** func **param** **cascade**: The cascade to use for the features. default is CASCADE_FRONTALFACE_ALT.<br>**threshold**: The threshold to use for the features. default is 0.5.<br>**scale**: The scale to use for the features. default is 1.5.<br>**roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br> **return** Returns the features of the image **static** False > C++ defination code: > ```cpp > std::vector<int> find_features(int cascade, float threshold 0.5, float scale 1.5, std::vector<int> roi std::vector<int>()) > ``` #### find\\_lbp {#find\\_lbp} ```python def find_lbp(self, roi: list[int] []) > LBPKeyPoint ``` Finds the lbp in the image. TODO: support in the future. item description **type** func **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br> **return** Returns the lbp of the image **static** False > C++ defination code: > ```cpp > image::LBPKeyPoint find_lbp(std::vector<int> roi std::vector<int>()) > ``` #### find\\_keypoints {#find\\_keypoints} ```python def find_keypoints(self, roi: list[int] [], threshold: int 20, normalized: bool False, scale_factor: float 1.5, max_keypoints: int 100, corner_detector: CornerDetector ...) > ORBKeyPoint ``` Finds the keypoints in the image. TODO: support in the future. item description **type** func **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**threshold**: The threshold to use for the keypoints. default is 20.<br>**normalized**: If true, the image will be normalized before the operation. default is false.<br>**scale_factor**: The scale factor to use for the keypoints. default is 1.5.<br>**max_keypoints**: The maximum number of keypoints to use for the keypoints. default is 100.<br>**corner_detector**: The corner detector to use for the keypoints. default is CORNER_AGAST.<br> **return** Returns the keypoints of the image **static** False > C++ defination code: > ```cpp > image::ORBKeyPoint find_keypoints(std::vector<int> roi std::vector<int>(), int threshold 20, bool normalized false, float scale_factor 1.5, int max_keypoints 100, image::CornerDetector corner_detector image::CornerDetector::CORNER_AGAST) > ``` #### find\\_edges {#find\\_edges} ```python def find_edges(self, edge_type: EdgeDetector, roi: list[int] [], threshold: list[int] [100, 200]) > Image ``` Finds the edges in the image. item description **type** func **param** **edge_type**: The edge type to use for the edges. default is EDGE_CANNY.<br>**roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**threshold**: The threshold to use for the edges. default is 20.<br> **return** Returns the edges of the image **static** False > C++ defination code: > ```cpp > image::Image* find_edges(image::EdgeDetector edge_type, std::vector<int> roi std::vector<int>(), std::vector<int> threshold std::vector<int>({100, 200})) > ``` #### find\\_hog {#find\\_hog} ```python def find_hog(self, roi: list[int] [], size: int 8) > Image ``` Finds the hog in the image. TODO: support in the future item description **type** func **param** **roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**size**: The size to use for the hog. default is 8.<br> **return** Returns the hog of the image **static** False > C++ defination code: > ```cpp > image::Image* find_hog(std::vector<int> roi std::vector<int>(), int size 8) > ``` #### match\\_lbp\\_descriptor {#match\\_lbp\\_descriptor} ```python def match_lbp_descriptor(self, desc1: LBPKeyPoint, desc2: LBPKeyPoint) > int ``` Matches the lbp descriptor of the image. TODO: support in the future item description **type** func **param** **desc1**: The descriptor to use for the match.<br>**desc2**: The descriptor to use for the match.<br> **return** Returns the match of the image **static** False > C++ defination code: > ```cpp > int match_lbp_descriptor(image::LBPKeyPoint &desc1, image::LBPKeyPoint &desc2) > ``` #### match\\_orb\\_descriptor {#match\\_orb\\_descriptor} ```python def match_orb_descriptor(self, desc1: ORBKeyPoint, desc2: ORBKeyPoint, threshold: int 95, filter_outliers: bool False) > KPTMatch ``` Matches the orb descriptor of the image. TODO: support in the future item description **type** func **param** **desc1**: The descriptor to use for the match.<br>**desc2**: The descriptor to use for the match.<br>**threshold**: The threshold to use for the match. default is 95.<br>**filter_outliers**: If true, the image will be filter_outliers before the operation. default is false.<br> **return** Returns the match of the image **static** False > C++ defination code: > ```cpp > image::KPTMatch match_orb_descriptor(image::ORBKeyPoint &desc1, image::ORBKeyPoint &desc2, int threshold 95, bool filter_outliers false) > ``` #### resize\\_map\\_pos {#resize\\_map\\_pos 2} ```python def resize_map_pos(self, w_out: int, h_out: int, fit: Fit, x: int, y: int, w: int 1, h: int 1) > list[int] ``` map point position or rectangle position from this image size to another image size(resize) item description **type** func **param** **int**: h_out target image height<br>**fit**: resize method, see maix.image.Fit<br>**x**: original point x, or rectagle left top point's x<br>**y**: original point y, or rectagle left top point's y<br>**w**: original rectagle width, can be 1 if not use this arg, default 1.<br>**h**: original rectagle height, can be 1 if not use this arg, default 1.<br> **return** list type, [x, y] if map point, [x, y, w, h] if resize rectangle. **static** False > C++ defination code: > ```cpp > std::vector<int> resize_map_pos(int w_out, int h_out, image::Fit fit, int x, int y, int w 1, int h 1) > ``` ### QRCodeDetector {#QRCodeDetector} QRCodeDetector class > C++ defination code: > ```cpp > class QRCodeDetector > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 23} ```python def __init__(self) > None ``` QRCodeDetector constructor.\\nUse npu to accelerate the speed of QR code scanning, note that this object will occupy npu resources item description **type** func **static** False > C++ defination code: > ```cpp > QRCodeDetector() > ``` #### detect {#detect} ```python def detect(self, img: Image, roi: list[int] [], decoder_type: QRCodeDecoderType ...) > list[QRCode] ``` Finds all qrcodes in the image. item description **type** func **param** **img**: The image to find qrcodes.<br>**roi**: The region of interest, input in the format of (x, y, w, h), x and y are the coordinates of the upper left corner, w and h are the width and height of roi.<br>default is None, means whole image.<br>**decoder_type**: Select the QR code decoding method. Choosing QRCODE_DECODER_TYPE_QUIRC allows for retrieving QR code version, ECC level, mask, data type, and other details,<br>though it may decode slower at lower resolutions. Opting for QRCODE_DECODER_TYPE_ZBAR enables faster decoding at lower resolutions but may slow down at higher resolutions,<br>providing only the QR code content and position information. default is QRCODE_DECODER_TYPE_ZBAR.<br> **return** Returns the qrcodes of the image **static** False > C++ defination code: > ```cpp > std::vector<image::QRCode> detect(image::Image *img, std::vector<int> roi std::vector<int>(), image::QRCodeDecoderType decoder_type image::QRCodeDecoderType::QRCODE_DECODER_TYPE_ZBAR) > ```"},"/maixpy/api/maix/comm.html":{"title":"maix.comm","content":" title: maix.comm maix.comm module > You can use `maix.comm` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} module brief [modbus](./comm/modbus.html) maix.comm.modbus module ## Enum {#Enum} ## Variable {#Variable} ## Function {#Function} ### add\\_default\\_comm\\_listener {#add\\_default\\_comm\\_listener} Add default CommProtocol listener.\\nWhen the application uses this port, the listening thread will immediately\\nrelease the port resources and exit. If you need to start the default listening thread again,\\nplease release the default port resources and then call this function. > C++ defination code: > ```cpp > void add_default_comm_listener() > ``` ### rm\\_default\\_comm\\_listener {#rm\\_default\\_comm\\_listener} Remove default CommProtocol listener. item description **return** bool type. > C++ defination code: > ```cpp > bool rm_default_comm_listener() > ``` ## Class {#Class} ### CommProtocol {#CommProtocol} Class for communication protocol > C++ defination code: > ```cpp > class CommProtocol > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, buff_size: int 1024, header: int 3148663466, method_none_raise: bool False) > None ``` Construct a new CommProtocol object item description **type** func **param** **buff_size**: buffer size, default to 1024 bytes<br>**header**: Customize header, default is maix.protocol.HEADER<br>**method_none_raise**: If method set to \"none\", raise err.Exception() if method_none_raise is true. Default false,<br>if method is \"none\" and this arg is false, valid() function will return false and get_msg() always return none.<br> **throw** Initialize failed will raise err::Exception() **static** False > C++ defination code: > ```cpp > CommProtocol(int buff_size 1024, uint32_t header maix::protocol::HEADER, bool method_none_raise false) > ``` #### get\\_msg {#get\\_msg} ```python def get_msg(self, timeout: int 0) > ... ``` Read data to buffer, and try to decode it as maix.protocol.MSG object item description **type** func **param** **timeout**: unit ms, 0 means return immediatly, 1 means block util have msg, >0 means block until have msg or timeout.<br> **return** decoded data, if nullptr, means no valid frame found.<br>Attentioin, delete it after use in C++. **static** False > C++ defination code: > ```cpp > protocol::MSG *get_msg(int timeout 0) > ``` #### resp\\_ok {#resp\\_ok} ```python def resp_ok(self, cmd: int, body: maix.Bytes(bytes) None) > maix.err.Err ``` Send response ok(success) message item description **type** func **param** **cmd**: CMD value<br>**body**: response body, can be null<br> **return** encoded data, if nullptr, means error, and the error code is err.Err.<br>Attentioin, delete it after use in C++. **static** False > C++ defination code: > ```cpp > err::Err resp_ok(uint8_t cmd, Bytes *body nullptr) > ``` #### report {#report} ```python def report(self, cmd: int, body: maix.Bytes(bytes) None) > maix.err.Err ``` Send report message item description **type** func **param** **cmd**: CMD value<br>**body**: report body, can be null<br> **return** encoded data, if nullptr, means error, and the error code is err.Err.<br>Attentioin, delete it after use in C++. **static** False > C++ defination code: > ```cpp > err::Err report(uint8_t cmd, Bytes *body nullptr) > ``` #### resp\\_err {#resp\\_err} ```python def resp_err(self, cmd: int, code: maix.err.Err, msg: str) > maix.err.Err ``` Encode response error message to buffer item description **type** func **param** **cmd**: CMD value<br>**code**: error code<br>**msg**: error message<br> **return** encoded data, if nullptr, means error, and the error code is err.Err.<br>Attentioin, delete it after use in C++. **static** False > C++ defination code: > ```cpp > err::Err resp_err(uint8_t cmd, err::Err code, const std::string &msg) > ``` #### valid {#valid} ```python def valid(self) > bool ``` Is CommProtocol valid, only not valid when method not set to \\\"none\\\". item description **type** func **return** false if commprotocol method is \"none\". **static** False > C++ defination code: > ```cpp > bool valid() > ``` #### set\\_method {#set\\_method} ```python def set_method(method: str) > maix.err.Err ``` Set CommProtocol method. Static method, can be called directly without instance. item description **type** func **param** **method**: Can be \"uart\" or \"none\", \"none\" means not use CommProtocol.<br> **static** True > C++ defination code: > ```cpp > static err::Err set_method(const std::string &method) > ``` #### get\\_method {#get\\_method} ```python def get_method() > str ``` Get CommProtocol method. Static method, can be called directly without instance. item description **type** func **return** method Can be \"uart\" or \"none\", \"none\" means not use CommProtocol. **static** True > C++ defination code: > ```cpp > static std::string get_method() > ``` #### get\\_uart\\_port {#get\\_uart\\_port} ```python def get_uart_port() > list[str] ``` Get CommProtocol method uart's port name. Static method, can be called directly without instance. item description **type** func **return** uart [port name, device path], e.g. [\"uart0\", \"/dev/ttyS0\"].<br>If no valid uart port, return empty list !! **static** True > C++ defination code: > ```cpp > static std::vector<std::string> get_uart_port() > ``` #### get\\_uart\\_ports {#get\\_uart\\_ports} ```python def get_uart_ports() > list[list[str]] ``` Get all CommProtocol method uart supported ports. Static method, can be called directly without instance. item description **type** func **return** uart [[port name, device path]], e.g. [[\"uart0\", \"/dev/ttyS0\"], ...]. **static** True > C++ defination code: > ```cpp > static std::vector<std::vector<std::string>> get_uart_ports() > ```"},"/maixpy/api/maix/http.html":{"title":"maix.http","content":" title: maix.http maix.http module > You can use `maix.http` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ## Variable {#Variable} ## Function {#Function} ## Class {#Class} ### JpegStreamer {#JpegStreamer} JpegStreamer class > C++ defination code: > ```cpp > class JpegStreamer > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, host: str '', port: int 8000, client_number: int 16) > None ``` Construct a new jpeg streamer object item description **type** func **note** You can get the picture stream through http://host:port/stream, you can also get it through http://ip:port, and you can add personal style through set_html() at this time **param** **host**: http host<br>**port**: http port, default is 8000<br>**client_number**: the max number of client<br> **static** False > C++ defination code: > ```cpp > JpegStreamer(std::string host std::string(), int port 8000, int client_number 16) > ``` #### start {#start} ```python def start(self) > maix.err.Err ``` start jpeg streame item description **type** func **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err start() > ``` #### stop {#stop} ```python def stop(self) > maix.err.Err ``` stop http item description **type** func **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err stop() > ``` #### write {#write} ```python def write(self, img: maix.image.Image) > maix.err.Err ``` Write data to http item description **type** func **param** **img**: image object<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err write(image::Image *img) > ``` #### set\\_html {#set\\_html} ```python def set_html(self, data: str) > maix.err.Err ``` add your style in this api\\ndefault is:\\n<html>\\n<body>\\n<h1>JPG Stream</h1>\\n<img src '/stream'>\\n</body>\\n</html> item description **type** func **param** **data**: html code<br> **return** error code, err::ERR_NONE means success, others means failed **static** False > C++ defination code: > ```cpp > err::Err set_html(std::string data) > ``` #### host {#host} ```python def host(self) > str ``` Get host item description **type** func **return** host name **static** False > C++ defination code: > ```cpp > std::string host() > ``` #### port {#port} ```python def port(self) > int ``` Get port item description **type** func **return** port **static** False > C++ defination code: > ```cpp > int port() > ```"},"/maixpy/api/maix/nn.html":{"title":"maix.nn","content":" title: maix.nn maix.nn module > You can use `maix.nn` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} module brief [F](./nn/F.html) maix.nn.F module ## Enum {#Enum} ### Layout {#Layout} layer layout types item describe **values** **NCHW**: [N, C, H, W]<br>**NHWC**: [N, H, W, C]<br>**UNKNOWN**: <br> > C++ defination code: > ```cpp > enum class Layout > { > NCHW 0, // [N, C, H, W] > NHWC 1, // [N, H, W, C] > UNKNOWN 4 > } > ``` ### SpeechDevice {#SpeechDevice} speech device item describe **values** **DEVICE_NONE**: <br>**DEVICE_PCM**: <br>**DEVICE_MIC**: <br>**DEVICE_WAV**: <br> > C++ defination code: > ```cpp > enum class SpeechDevice { > DEVICE_NONE 1, > DEVICE_PCM, > DEVICE_MIC, > DEVICE_WAV, > } > ``` ### SpeechDecoder {#SpeechDecoder} speech decoder type item describe **values** **DECODER_RAW**: <br>**DECODER_DIG**: <br>**DECODER_LVCSR**: <br>**DECODER_KWS**: <br>**DECODER_ALL**: <br> > C++ defination code: > ```cpp > enum class SpeechDecoder { > DECODER_RAW 1, > DECODER_DIG 2, > DECODER_LVCSR 4, > DECODER_KWS 8, > DECODER_ALL 65535, > } > ``` ## Variable {#Variable} ## Function {#Function} ## Class {#Class} ### QwenResp {#QwenResp} Qwen model response > C++ defination code: > ```cpp > class QwenResp > ``` #### msg {#msg} Model response full message. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string msg > ``` #### msg\\_new {#msg\\_new} Model response new message. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string msg_new > ``` #### err\\_code {#err\\_code} Model response error code, maix.Err type, should be err.Err.ERR_NONE if no error. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > err::Err err_code > ``` #### err\\_msg {#err\\_msg} Model response error message. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string err_msg > ``` ### QwenPostConfig {#QwenPostConfig} Qwen model post config > C++ defination code: > ```cpp > class QwenPostConfig > ``` #### enable\\_temperature {#enable\\_temperature} Enable temperature sampling item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > bool enable_temperature > ``` #### temperature {#temperature} Temperature sampling value item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float temperature > ``` #### enable\\_repetition\\_penalty {#enable\\_repetition\\_penalty} Enable repetition penalty item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > bool enable_repetition_penalty > ``` #### repetition\\_penalty {#repetition\\_penalty} Repetition penalty value item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float repetition_penalty > ``` #### penalty\\_window {#penalty\\_window} Repetition penalty window item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int penalty_window > ``` #### enable\\_top\\_p\\_sampling {#enable\\_top\\_p\\_sampling} Enable diversity penalty item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > bool enable_top_p_sampling > ``` #### top\\_p {#top\\_p} Diversity penalty value item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float top_p > ``` #### enable\\_top\\_k\\_sampling {#enable\\_top\\_k\\_sampling} Enable top k sampling item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > bool enable_top_k_sampling > ``` #### top\\_k {#top\\_k} Top k sampling value item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int top_k > ``` ### Qwen {#Qwen} Qwen model > C++ defination code: > ```cpp > class Qwen > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, model: str) > None ``` Qwen constructor item description **type** func **param** **model**: direction [in], model file path, model format can be MUD(model universal describe file) file.<br>If model_path set, will load model from file, load failed will raise err.Exception.<br>If model_path not set, you can load model later by load function.<br> **static** False > C++ defination code: > ```cpp > Qwen(const std::string &model) > ``` #### load {#load} ```python def load(self, model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: direction [in], model file path, model format can be MUD(model universal describe file) file.<br> **return** error code, if load success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err load(const std::string &model) > ``` #### unload {#unload} ```python def unload(self) > maix.err.Err ``` Unload model item description **type** func **return** error code, if unload success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err unload() > ``` #### loaded {#loaded} ```python def loaded(self) > bool ``` Is model loaded item description **type** func **return** true if model loaded, else false **static** False > C++ defination code: > ```cpp > bool loaded() > ``` #### set\\_system\\_prompt {#set\\_system\\_prompt} ```python def set_system_prompt(self, prompt: str) > None ``` Set system prompt, will auto call clear_context. item description **type** func **param** **prompt**: system prompt<br> **static** False > C++ defination code: > ```cpp > void set_system_prompt(const std::string &prompt) > ``` #### get\\_system\\_prompt {#get\\_system\\_prompt} ```python def get_system_prompt(self) > str ``` Get system prompt item description **type** func **return** system prompt **static** False > C++ defination code: > ```cpp > std::string get_system_prompt() > ``` #### set\\_log\\_level {#set\\_log\\_level} ```python def set_log_level(self, level: ..., color: bool) > None ``` Set log level item description **type** func **param** **level**: log level, @see maix.log.LogLevel<br>**color**: true to enable color, false to disable color<br> **static** False > C++ defination code: > ```cpp > void set_log_level(log::LogLevel level, bool color) > ``` #### set\\_reply\\_callback {#set\\_reply\\_callback} ```python def set_reply_callback(self, callback: typing.Callable[[Qwen, QwenResp], None] None) > None ``` Set reply callback item description **type** func **param** **callback**: reply callback, when token(words) generated, this function will be called,<br>so you can get response message in real time in this callback funtion.<br>If set to None(nullptr in C++), you can get response after all response message generated.<br> **static** False > C++ defination code: > ```cpp > void set_reply_callback(std::function<void(nn::Qwen &, const nn::QwenResp &)> callback nullptr) > ``` #### get\\_reply\\_callback {#get\\_reply\\_callback} ```python def get_reply_callback(self) > typing.Callable[[Qwen, QwenResp], None] ``` Get reply callback item description **type** func **return** reply callback **static** False > C++ defination code: > ```cpp > std::function<void(nn::Qwen &, const nn::QwenResp &)> get_reply_callback() > ``` #### send {#send} ```python def send(self, msg: str) > QwenResp ``` Send message to model item description **type** func **param** **msg**: message to send<br> **return** model response **static** False > C++ defination code: > ```cpp > nn::QwenResp send(const std::string &msg) > ``` #### cancel {#cancel} ```python def cancel(self) > None ``` Cancel running item description **type** func **static** False > C++ defination code: > ```cpp > void cancel() > ``` #### clear\\_context {#clear\\_context} ```python def clear_context(self) > maix.err.Err ``` Clear context item description **type** func **return** error code, if clear success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err clear_context() > ``` #### version {#version} ```python def version(self) > str ``` Get model version item description **type** func **return** model version **static** False > C++ defination code: > ```cpp > std::string version() > ``` #### post\\_config {#post\\_config} Qwen post config, default will read config from model mud file, you can also set it manually here. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > nn::QwenPostConfig post_config > ``` ### InternVLResp {#InternVLResp} InternVL model response > C++ defination code: > ```cpp > class InternVLResp > ``` #### msg {#msg 2} Model response full message. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string msg > ``` #### msg\\_new {#msg\\_new 2} Model response new message. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string msg_new > ``` #### err\\_code {#err\\_code 2} Model response error code, maix.Err type, should be err.Err.ERR_NONE if no error. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > err::Err err_code > ``` #### err\\_msg {#err\\_msg 2} Model response error message. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string err_msg > ``` ### InternVLPostConfig {#InternVLPostConfig} InternVL model post config > C++ defination code: > ```cpp > class InternVLPostConfig > ``` #### enable\\_temperature {#enable\\_temperature 2} Enable temperature sampling item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > bool enable_temperature > ``` #### temperature {#temperature 2} Temperature sampling value item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float temperature > ``` #### enable\\_repetition\\_penalty {#enable\\_repetition\\_penalty 2} Enable repetition penalty item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > bool enable_repetition_penalty > ``` #### repetition\\_penalty {#repetition\\_penalty 2} Repetition penalty value item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float repetition_penalty > ``` #### penalty\\_window {#penalty\\_window 2} Repetition penalty window item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int penalty_window > ``` #### enable\\_top\\_p\\_sampling {#enable\\_top\\_p\\_sampling 2} Enable diversity penalty item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > bool enable_top_p_sampling > ``` #### top\\_p {#top\\_p 2} Diversity penalty value item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float top_p > ``` #### enable\\_top\\_k\\_sampling {#enable\\_top\\_k\\_sampling 2} Enable top k sampling item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > bool enable_top_k_sampling > ``` #### top\\_k {#top\\_k 2} Top k sampling value item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int top_k > ``` ### InternVL {#InternVL} InternVL model > C++ defination code: > ```cpp > class InternVL > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 2} ```python def __init__(self, model: str) > None ``` InternVL constructor item description **type** func **param** **model**: direction [in], model file path, model format can be MUD(model universal describe file) file.<br>If model_path set, will load model from file, load failed will raise err.Exception.<br>If model_path not set, you can load model later by load function.<br> **static** False > C++ defination code: > ```cpp > InternVL(const std::string &model) > ``` #### load {#load 2} ```python def load(self, model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: direction [in], model file path, model format can be MUD(model universal describe file) file.<br> **return** error code, if load success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err load(const std::string &model) > ``` #### unload {#unload 2} ```python def unload(self) > maix.err.Err ``` Unload model item description **type** func **return** error code, if unload success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err unload() > ``` #### loaded {#loaded 2} ```python def loaded(self) > bool ``` Is model loaded item description **type** func **return** true if model loaded, else false **static** False > C++ defination code: > ```cpp > bool loaded() > ``` #### set\\_system\\_prompt {#set\\_system\\_prompt 2} ```python def set_system_prompt(self, prompt: str) > None ``` Set system prompt item description **type** func **param** **prompt**: system prompt<br> **static** False > C++ defination code: > ```cpp > void set_system_prompt(const std::string &prompt) > ``` #### get\\_system\\_prompt {#get\\_system\\_prompt 2} ```python def get_system_prompt(self) > str ``` Get system prompt item description **type** func **return** system prompt **static** False > C++ defination code: > ```cpp > std::string get_system_prompt() > ``` #### set\\_log\\_level {#set\\_log\\_level 2} ```python def set_log_level(self, level: ..., color: bool) > None ``` Set log level item description **type** func **param** **level**: log level, @see maix.log.LogLevel<br>**color**: true to enable color, false to disable color<br> **static** False > C++ defination code: > ```cpp > void set_log_level(log::LogLevel level, bool color) > ``` #### set\\_reply\\_callback {#set\\_reply\\_callback 2} ```python def set_reply_callback(self, callback: typing.Callable[[InternVL, InternVLResp], None] None) > None ``` Set reply callback. item description **type** func **param** **callback**: reply callback, when token(words) generated, this function will be called,<br>so you can get response message in real time in this callback funtion.<br>If set to None(nullptr in C++), you can get response after all response message generated.<br> **static** False > C++ defination code: > ```cpp > void set_reply_callback(std::function<void(nn::InternVL &, const nn::InternVLResp &)> callback nullptr) > ``` #### get\\_reply\\_callback {#get\\_reply\\_callback 2} ```python def get_reply_callback(self) > typing.Callable[[InternVL, InternVLResp], None] ``` Get reply callback item description **type** func **return** reply callback **static** False > C++ defination code: > ```cpp > std::function<void(nn::InternVL &, const nn::InternVLResp &)> get_reply_callback() > ``` #### input\\_width {#input\\_width} ```python def input_width(self) > int ``` Image input width item description **type** func **return** input width. **static** False > C++ defination code: > ```cpp > int input_width() > ``` #### input\\_height {#input\\_height} ```python def input_height(self) > int ``` Image input height item description **type** func **return** input height. **static** False > C++ defination code: > ```cpp > int input_height() > ``` #### input\\_format {#input\\_format} ```python def input_format(self) > maix.image.Format ``` Image input format item description **type** func **return** input format. **static** False > C++ defination code: > ```cpp > maix::image::Format input_format() > ``` #### set\\_image {#set\\_image} ```python def set_image(self, img: maix.image.Image, fit: maix.image.Fit ...) > maix.err.Err ``` Set image and will encode image.\\nYou can set image once and call send multiple times. item description **type** func **param** **img**: the image you want to use.<br>**fit**: Image resize fit method, only used when img size not equal to model input.<br> **return** err.Err return err.Err.ERR_NONE is no error happen. **static** False > C++ defination code: > ```cpp > err::Err set_image(maix::image::Image &img, maix::image::Fit fit maix::image::Fit::FIT_CONTAIN) > ``` #### clear\\_image {#clear\\_image} ```python def clear_image(self) > None ``` Clear image, InternVL2.5 based on Qwen2.5, so you can clear image and only use LLM function. item description **type** func **static** False > C++ defination code: > ```cpp > void clear_image() > ``` #### is\\_image\\_set {#is\\_image\\_set} ```python def is_image_set(self) > bool ``` Whether image set by set_image item description **type** func **return** Return true if image set by set_image function, or return false. **static** False > C++ defination code: > ```cpp > bool is_image_set() > ``` #### send {#send 2} ```python def send(self, msg: str) > InternVLResp ``` Send message to model item description **type** func **param** **msg**: message to send<br> **return** model response **static** False > C++ defination code: > ```cpp > nn::InternVLResp send(const std::string &msg) > ``` #### cancel {#cancel 2} ```python def cancel(self) > None ``` Cancel running item description **type** func **static** False > C++ defination code: > ```cpp > void cancel() > ``` #### version {#version 2} ```python def version(self) > str ``` Get model version item description **type** func **return** model version **static** False > C++ defination code: > ```cpp > std::string version() > ``` #### post\\_config {#post\\_config 2} InternVL post config, default will read config from model mud file, you can also set it manually here. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > nn::InternVLPostConfig post_config > ``` ### DepthAnything {#DepthAnything} DepthAnything > C++ defination code: > ```cpp > class DepthAnything > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 3} ```python def __init__(self, model: str '', dual_buff: bool True) > None ``` Construct a new DepthAnything object item description **type** func **param** **model**: MUD model path, if empty, will not load model, you can call load() later.<br>if not empty, will load model and will raise err::Exception if load failed.<br>**dual_buff**: direction [in], prepare dual input output buffer to accelarate forward, that is, when NPU is forwarding we not wait and prepare the next input buff.<br>If you want to ensure every time forward output the input's result, set this arg to false please.<br>Default true to ensure speed.<br> **static** False > C++ defination code: > ```cpp > DepthAnything(const string &model \"\", bool dual_buff true) > ``` #### load {#load 3} ```python def load(self, model: str) > maix.err.Err ``` Load model from file, model format is .mud,\\nMUD file should contain [extra] section, have key values:\\n model_type: depth_anything_v2\\n input_type: rgb or bgr\\n mean: 123.675, 116.28, 103.53\\n scale: 0.017124753831663668, 0.01750700280112045, 0.017429193899782137\\n labels: imagenet_classes.txt item description **type** func **param** **model**: MUD model path<br> **return** error code, if load failed, return error code **static** False > C++ defination code: > ```cpp > err::Err load(const string &model) > ``` #### get\\_depth {#get\\_depth} ```python def get_depth(self, img: maix.image.Image, fit: maix.image.Fit ...) > maix.tensor.Tensor ``` Forward model and get raw image depth estimation data. item description **type** func **param** **img**: image, format should match model input_type， or will raise err.Exception<br>**fit**: image resize fit mode if input image not equal to model' input size,<br>will auto resize to model's input size then detect, and recover to image input size.<br>Default Fit.FIT_CONTAIN, see image.Fit.<br> **throw** If error occurred, will raise err::Exception, you can find reason in log, mostly caused by args error or hardware error. **return** result, a tensor.Tensor object. If in dual_buff mode, value can be None(in Python) or nullptr(in C++) when not ready. In C++, you need to delete it after use. **static** False > C++ defination code: > ```cpp > tensor::Tensor *get_depth(image::Image &img, image::Fit fit image::FIT_CONTAIN) > ``` #### get\\_depth\\_image {#get\\_depth\\_image} ```python def get_depth_image(self, img: maix.image.Image, fit: maix.image.Fit ..., cmap: maix.image.CMap ...) > maix.image.Image ``` Forward model and get image depth estimation data normlized to [0, 255] and as a image.Image object. item description **type** func **param** **img**: image, format should match model input_type， or will raise err.Exception<br>**fit**: image resize fit mode if input image not equal to model' input size,<br>will auto resize to model's input size then detect, and recover to image input size.<br>Default Fit.FIT_CONTAIN, see image.Fit.<br>**cmap**: Color map used convert grayscale distance estimation image to RGB image.<br>Diiferent cmap will influence finally image.<br>Default image.CMap.INFERNO.<br> **throw** If error occurred, will raise err::Exception, you can find reason in log, mostly caused by args error or hardware error. **return** result, a image::Image object. If in dual_buff mode, value can be None(in Python) or nullptr(in C++) when not ready. In C++, you need to delete it after use. **static** False > C++ defination code: > ```cpp > image::Image *get_depth_image(image::Image &img, image::Fit fit image::FIT_CONTAIN, image::CMap cmap image::CMap::INFERNO) > ``` #### input\\_size {#input\\_size} ```python def input_size(self) > maix.image.Size ``` Get model input size, only for image input item description **type** func **return** model input size **static** False > C++ defination code: > ```cpp > image::Size input_size() > ``` #### input\\_width {#input\\_width 2} ```python def input_width(self) > int ``` Get model input width, only for image input item description **type** func **return** model input size of width **static** False > C++ defination code: > ```cpp > int input_width() > ``` #### input\\_height {#input\\_height 2} ```python def input_height(self) > int ``` Get model input height, only for image input item description **type** func **return** model input size of height **static** False > C++ defination code: > ```cpp > int input_height() > ``` #### input\\_format {#input\\_format 2} ```python def input_format(self) > maix.image.Format ``` Get input image format, only for image input item description **type** func **return** input image format, image::Format type. **static** False > C++ defination code: > ```cpp > image::Format input_format() > ``` #### input\\_shape {#input\\_shape} ```python def input_shape(self) > list[int] ``` Get input shape, if have multiple input, only return first input shape item description **type** func **return** input shape, list type **static** False > C++ defination code: > ```cpp > std::vector<int> input_shape() > ``` #### mean {#mean} Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean > ``` #### scale {#scale} Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale > ``` ### MixFormerV2 {#MixFormerV2} MixFormerV2 class > C++ defination code: > ```cpp > class MixFormerV2 > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 4} ```python def __init__(self, model: str '', update_interval: int 200, lost_find_interval: int 60) > None ``` Constructor of MixFormerV2 class item description **type** func **param** **model**: model path, default empty, you can load model later by load function.<br>**update_interval**: update online template interval in framsed, default 200 frames<br>**lost_find_interval**: auto find lose target in global after lose target lost_find_interval frames, 1 means not use.<br>In some scene, this is useful to get back target, but if always find wrong target after target lost, you should disable this.<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False > C++ defination code: > ```cpp > MixFormerV2(const string &model \"\", int update_interval 200, int lost_find_interval 60) > ``` #### load {#load 4} ```python def load(self, model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: Model path want to load<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err load(const string &model) > ``` #### init {#init} ```python def init(self, img: maix.image.Image, x: int, y: int, w: int, h: int) > None ``` Init tracker, give tacker first target image and target position. item description **type** func **param** **img**: Image want to detect, target should be in this image.<br>**x**: the target position left top coordinate x.<br>**y**: the target position left top coordinate y.<br>**w**: the target width.<br>**h**: the target height.<br> **throw** If image format not match model input format, will throw err::Exception. **static** False > C++ defination code: > ```cpp > void init(image::Image &img, int x, int y, int w, int h) > ``` #### track {#track} ```python def track(self, img: maix.image.Image, threshold: float 0.5) > ... ``` Track object acoording to last object position and the init function learned target feature. item description **type** func **param** **img**: image to detect object and track, can be any resolution, before detect it will crop a area according to last time target's position.<br>**threshold**: If score < threshold, will see this new detection is invalid, but remain return this new detecion, default 0.9.<br> **return** object, attribute [x, y, w, h] and score are the predict target position and score, points attribute provide more info:<br>0~3 [ search_x, search_y, search_w, search_h ]: search area for this time track, based on last correct start position.<br>4~5 [ predict_cx, predict_cy]: predict center according to this time input.<br>6 [ search_size ]: search_area size based on last correct start position, center is (search_x search_w / 2, search_y search_h / 2).<br>7 [ predict_template_size ]: template size based on predict target, center is (predict_cx, predict_cy).<br>8~11 [ correct_cx, correct_cy, correct_w, correct_h]: latest correct (score > threshold) target position. **static** False > C++ defination code: > ```cpp > nn::Object track(image::Image &img, float threshold 0.5) > ``` #### input\\_size {#input\\_size 2} ```python def input_size(self) > maix.image.Size ``` Get model input size item description **type** func **return** model input size **static** False > C++ defination code: > ```cpp > image::Size input_size() > ``` #### input\\_width {#input\\_width 3} ```python def input_width(self) > int ``` Get model input width item description **type** func **return** model input size of width **static** False > C++ defination code: > ```cpp > int input_width() > ``` #### input\\_height {#input\\_height 3} ```python def input_height(self) > int ``` Get model input height item description **type** func **return** model input size of height **static** False > C++ defination code: > ```cpp > int input_height() > ``` #### input\\_format {#input\\_format 3} ```python def input_format(self) > maix.image.Format ``` Get input image format item description **type** func **return** input image format, image::Format type. **static** False > C++ defination code: > ```cpp > image::Format input_format() > ``` #### mean {#mean 2} Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean > ``` #### scale {#scale 2} Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale > ``` #### frame\\_id {#frame\\_id} Current frame_id item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > uint64_t frame_id > ``` #### update\\_interval {#update\\_interval} update online template interval in frames item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int update_interval > ``` #### lost\\_find\\_interval {#lost\\_find\\_interval} Auto find target after lost lost_find_interval frames, 1 means not auto find.\\nIn some scene, this is useful to get back target, but if always find wrong target after target lost, you should disable this. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int lost_find_interval > ``` ### SelfLearnClassifier {#SelfLearnClassifier} SelfLearnClassifier > C++ defination code: > ```cpp > class SelfLearnClassifier > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 5} ```python def __init__(self, model: str '', dual_buff: bool True) > None ``` Construct a new SelfLearnClassifier object item description **type** func **param** **model**: MUD model path, if empty, will not load model, you can call load_model() later.<br>if not empty, will load model and will raise err::Exception if load failed.<br>**dual_buff**: direction [in], prepare dual input output buffer to accelarate forward, that is, when NPU is forwarding we not wait and prepare the next input buff.<br>If you want to ensure every time forward output the input's result, set this arg to false please.<br>Default true to ensure speed.<br> **static** False > C++ defination code: > ```cpp > SelfLearnClassifier(const std::string &model \"\", bool dual_buff true) > ``` #### load\\_model {#load\\_model} ```python def load_model(self, model: str) > maix.err.Err ``` Load model from file, model format is .mud,\\nMUD file should contain [extra] section, have key values:\\n model_type: classifier_no_top\\n input_type: rgb or bgr\\n mean: 123.675, 116.28, 103.53\\n scale: 0.017124753831663668, 0.01750700280112045, 0.017429193899782137 item description **type** func **param** **model**: MUD model path<br> **return** error code, if load failed, return error code **static** False > C++ defination code: > ```cpp > err::Err load_model(const string &model) > ``` #### classify {#classify} ```python def classify(self, img: maix.image.Image, fit: maix.image.Fit ...) > list[tuple[int, float]] ``` Classify image item description **type** func **param** **img**: image, format should match model input_type， or will raise err.Exception<br>**fit**: image resize fit mode, default Fit.FIT_COVER, see image.Fit.<br> **throw** If error occurred, will raise err::Exception, you can find reason in log, mostly caused by args error or hardware error. **return** result, a list of (idx, distance), smaller distance means more similar. In C++, you need to delete it after use. **static** False > C++ defination code: > ```cpp > std::vector<std::pair<int, float>> *classify(image::Image &img, image::Fit fit image::FIT_COVER) > ``` #### add\\_class {#add\\_class} ```python def add_class(self, img: maix.image.Image, fit: maix.image.Fit ...) > None ``` Add a class to recognize item description **type** func **param** **img**: Add a image as a new class<br>**fit**: image resize fit mode, default Fit.FIT_COVER, see image.Fit.<br> **static** False > C++ defination code: > ```cpp > void add_class(image::Image &img, image::Fit fit image::FIT_COVER) > ``` #### class\\_num {#class\\_num} ```python def class_num(self) > int ``` Get class number item description **type** func **static** False > C++ defination code: > ```cpp > int class_num() > ``` #### rm\\_class {#rm\\_class} ```python def rm_class(self, idx: int) > maix.err.Err ``` Remove a class item description **type** func **param** **idx**: index, value from 0 to class_num();<br> **static** False > C++ defination code: > ```cpp > err::Err rm_class(int idx) > ``` #### add\\_sample {#add\\_sample} ```python def add_sample(self, img: maix.image.Image, fit: maix.image.Fit ...) > None ``` Add sample, you should call learn method after add some samples to learn classes.\\nSample image can be any of classes we already added. item description **type** func **param** **img**: Add a image as a new sample.<br> **static** False > C++ defination code: > ```cpp > void add_sample(image::Image &img, image::Fit fit image::FIT_COVER) > ``` #### rm\\_sample {#rm\\_sample} ```python def rm_sample(self, idx: int) > maix.err.Err ``` Remove a sample item description **type** func **param** **idx**: index, value from 0 to sample_num();<br> **static** False > C++ defination code: > ```cpp > err::Err rm_sample(int idx) > ``` #### sample\\_num {#sample\\_num} ```python def sample_num(self) > int ``` Get sample number item description **type** func **static** False > C++ defination code: > ```cpp > int sample_num() > ``` #### learn {#learn} ```python def learn(self) > int ``` Start auto learn class features from classes image and samples.\\nYou should call this method after you add some samples. item description **type** func **return** learn epoch(times), 0 means learn nothing. **static** False > C++ defination code: > ```cpp > int learn() > ``` #### clear {#clear} ```python def clear(self) > None ``` Clear all class and samples item description **type** func **static** False > C++ defination code: > ```cpp > void clear() > ``` #### input\\_size {#input\\_size 3} ```python def input_size(self) > maix.image.Size ``` Get model input size, only for image input item description **type** func **return** model input size **static** False > C++ defination code: > ```cpp > image::Size input_size() > ``` #### input\\_width {#input\\_width 4} ```python def input_width(self) > int ``` Get model input width, only for image input item description **type** func **return** model input size of width **static** False > C++ defination code: > ```cpp > int input_width() > ``` #### input\\_height {#input\\_height 4} ```python def input_height(self) > int ``` Get model input height, only for image input item description **type** func **return** model input size of height **static** False > C++ defination code: > ```cpp > int input_height() > ``` #### input\\_format {#input\\_format 4} ```python def input_format(self) > maix.image.Format ``` Get input image format, only for image input item description **type** func **return** input image format, image::Format type. **static** False > C++ defination code: > ```cpp > image::Format input_format() > ``` #### input\\_shape {#input\\_shape 2} ```python def input_shape(self) > list[int] ``` Get input shape, if have multiple input, only return first input shape item description **type** func **return** input shape, list type **static** False > C++ defination code: > ```cpp > std::vector<int> input_shape() > ``` #### save {#save} ```python def save(self, path: str, labels: list[str] []) > maix.err.Err ``` Save features and labels to a binary file item description **type** func **param** **path**: file path to save, e.g. /root/my_classes.bin<br>**labels**: class labels, can be None, or length must equal to class num, or will return err::Err<br> **return** maix.err.Err if labels exists but length not equal to class num, or save file failed, or class num is 0. **static** False > C++ defination code: > ```cpp > err::Err save(const std::string &path, const std::vector<std::string> &labels std::vector<std::string>()) > ``` #### load {#load 5} ```python def load(self, path: str) > list[str] ``` Load features info from binary file item description **type** func **param** **path**: feature info binary file path, e.g. /root/my_classes.bin<br> **static** False > C++ defination code: > ```cpp > std::vector<std::string> load(const std::string &path) > ``` #### labels {#labels} Labels list item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<string> labels > ``` #### label\\_path {#label\\_path} Label file path item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string label_path > ``` #### mean {#mean 3} Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean > ``` #### scale {#scale 3} Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale > ``` ### YOLO11 {#YOLO11} YOLO11 class > C++ defination code: > ```cpp > class YOLO11 > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 6} ```python def __init__(self, model: str '', dual_buff: bool True) > None ``` Constructor of YOLO11 class item description **type** func **param** **model**: model path, default empty, you can load model later by load function.<br>**dual_buff**: direction [in], prepare dual input output buffer to accelarate forward, that is, when NPU is forwarding we not wait and prepare the next input buff.<br>If you want to ensure every time forward output the input's result, set this arg to false please.<br>Default true to ensure speed.<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False > C++ defination code: > ```cpp > YOLO11(const string &model \"\", bool dual_buff true) > ``` #### load {#load 6} ```python def load(self, model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: Model path want to load<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err load(const string &model) > ``` #### detect {#detect} ```python def detect(self, img: maix.image.Image, conf_th: float 0.5, iou_th: float 0.45, fit: maix.image.Fit ..., keypoint_th: float 0.5, sort: int 0) > ... ``` Detect objects from image item description **type** func **param** **img**: Image want to detect, if image's size not match model input's, will auto resize with fit method.<br>**conf_th**: Confidence threshold, default 0.5.<br>**iou_th**: IoU threshold, default 0.45.<br>**fit**: Resize method, default image.Fit.FIT_CONTAIN.<br>**keypoint_th**: keypoint threshold, default 0.5, only for yolo11 pose model.<br>**sort**: sort result according to object size, default 0 means not sort, 1 means bigger in front, 1 means smaller in front.<br> **throw** If image format not match model input format, will throw err::Exception. **return** Object list. In C++, you should delete it after use.<br>If model is yolo11 pose, object's points have value, and if points' value < 0 means that point is invalid(conf < keypoint_th). **static** False > C++ defination code: > ```cpp > nn::Objects *detect(image::Image &img, float conf_th 0.5, float iou_th 0.45, maix::image::Fit fit maix::image::FIT_CONTAIN, float keypoint_th 0.5, int sort 0) > ``` #### input\\_size {#input\\_size 4} ```python def input_size(self) > maix.image.Size ``` Get model input size item description **type** func **return** model input size **static** False > C++ defination code: > ```cpp > image::Size input_size() > ``` #### input\\_width {#input\\_width 5} ```python def input_width(self) > int ``` Get model input width item description **type** func **return** model input size of width **static** False > C++ defination code: > ```cpp > int input_width() > ``` #### input\\_height {#input\\_height 5} ```python def input_height(self) > int ``` Get model input height item description **type** func **return** model input size of height **static** False > C++ defination code: > ```cpp > int input_height() > ``` #### input\\_format {#input\\_format 5} ```python def input_format(self) > maix.image.Format ``` Get input image format item description **type** func **return** input image format, image::Format type. **static** False > C++ defination code: > ```cpp > image::Format input_format() > ``` #### draw\\_pose {#draw\\_pose} ```python def draw_pose(self, img: maix.image.Image, points: list[int], radius: int 4, color: maix.image.Color ..., colors: list[maix.image.Color] [], body: bool True, close: bool False) > None ``` Draw pose keypoints on image item description **type** func **param** **img**: image object, maix.image.Image type.<br>**points**: keypoits, int list type, [x, y, x, y ...]<br>**radius**: radius of points.<br>**color**: color of points.<br>**colors**: assign colors for points, list type, element is image.Color object.<br>**body**: true, if points' length is 17*2 and body is ture, will draw lines as human body, if set to false won't draw lines, default true.<br>**close**: connect all points to close a polygon, default false.<br> **static** False > C++ defination code: > ```cpp > void draw_pose(image::Image &img, std::vector<int> points, int radius 4, image::Color color image::COLOR_RED, const std::vector<image::Color> &colors std::vector<image::Color>(), bool body true, bool close false) > ``` #### draw\\_seg\\_mask {#draw\\_seg\\_mask} ```python def draw_seg_mask(self, img: maix.image.Image, x: int, y: int, seg_mask: maix.image.Image, threshold: int 127) > None ``` Draw segmentation on image item description **type** func **param** **img**: image object, maix.image.Image type.<br>**seg_mask**: segmentation mask image by detect method, a grayscale image<br>**threshold**: only mask's value > threshold will be draw on image, value from 0 to 255.<br> **static** False > C++ defination code: > ```cpp > void draw_seg_mask(image::Image &img, int x, int y, image::Image &seg_mask, int threshold 127) > ``` #### labels {#labels 2} Labels list item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<string> labels > ``` #### label\\_path {#label\\_path 2} Label file path item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string label_path > ``` #### mean {#mean 4} Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean > ``` #### scale {#scale 4} Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale > ``` ### Retinaface {#Retinaface} Retinaface class > C++ defination code: > ```cpp > class Retinaface > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 7} ```python def __init__(self, model: str '', dual_buff: bool True) > None ``` Constructor of Retinaface class item description **type** func **param** **model**: model path, default empty, you can load model later by load function.<br>**dual_buff**: direction [in], prepare dual input output buffer to accelarate forward, that is, when NPU is forwarding we not wait and prepare the next input buff.<br>If you want to ensure every time forward output the input's result, set this arg to false please.<br>Default true to ensure speed.<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False > C++ defination code: > ```cpp > Retinaface(const string &model \"\", bool dual_buff true) > ``` #### load {#load 7} ```python def load(self, model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: Model path want to load<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err load(const string &model) > ``` #### detect {#detect 2} ```python def detect(self, img: maix.image.Image, conf_th: float 0.4, iou_th: float 0.45, fit: maix.image.Fit ...) > list[...] ``` Detect objects from image item description **type** func **param** **img**: Image want to detect, if image's size not match model input's, will auto resize with fit method.<br>**conf_th**: Confidence threshold, default 0.4.<br>**iou_th**: IoU threshold, default 0.45.<br>**fit**: Resize method, default image.Fit.FIT_CONTAIN.<br> **throw** If image format not match model input format, will throw err::Exception. **return** Object list. In C++, you should delete it after use. **static** False > C++ defination code: > ```cpp > std::vector<nn::Object> *detect(image::Image &img, float conf_th 0.4, float iou_th 0.45, maix::image::Fit fit maix::image::FIT_CONTAIN) > ``` #### input\\_size {#input\\_size 5} ```python def input_size(self) > maix.image.Size ``` Get model input size item description **type** func **return** model input size **static** False > C++ defination code: > ```cpp > image::Size input_size() > ``` #### input\\_width {#input\\_width 6} ```python def input_width(self) > int ``` Get model input width item description **type** func **return** model input size of width **static** False > C++ defination code: > ```cpp > int input_width() > ``` #### input\\_height {#input\\_height 6} ```python def input_height(self) > int ``` Get model input height item description **type** func **return** model input size of height **static** False > C++ defination code: > ```cpp > int input_height() > ``` #### input\\_format {#input\\_format 6} ```python def input_format(self) > maix.image.Format ``` Get input image format item description **type** func **return** input image format, image::Format type. **static** False > C++ defination code: > ```cpp > image::Format input_format() > ``` #### mean {#mean 5} Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean > ``` #### scale {#scale 5} Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale > ``` ### Object {#Object} Object for detect result > C++ defination code: > ```cpp > class Object > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 8} ```python def __init__(self, x: int 0, y: int 0, w: int 0, h: int 0, class_id: int 0, score: float 0, points: list[int] [], angle: float 9999) > None ``` Constructor of Object for detect result item description **type** func **param** **x**: left top x<br>**y**: left top y<br>**w**: width<br>**h**: height<br>**class_id**: class id<br>**score**: score<br> **static** False > C++ defination code: > ```cpp > Object(int x 0, int y 0, int w 0, int h 0, int class_id 0, float score 0, std::vector<int> points std::vector<int>(), float angle 9999) > ``` #### \\_\\_str\\_\\_ {#\\_\\_str\\_\\_} ```python def __str__(self) > str ``` Object info to string item description **type** func **return** Object info string **static** False > C++ defination code: > ```cpp > std::string to_str() > ``` #### get\\_obb\\_points {#get\\_obb\\_points} ```python def get_obb_points(self) > list[int] ``` Get OBB(oriented bounding box) points, auto calculated according to x,y,w,h,angle item description **type** func **static** False > C++ defination code: > ```cpp > std::vector<int> get_obb_points() > ``` #### x {#x} Object left top coordinate x item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int x > ``` #### y {#y} Object left top coordinate y item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int y > ``` #### w {#w} Object width item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int w > ``` #### h {#h} Object height item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int h > ``` #### class\\_id {#class\\_id} Object class id item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int class_id > ``` #### score {#score} Object score item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float score > ``` #### points {#points} keypoints item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<int> points > ``` #### angle {#angle} Rotate angle, 9999 means not set, value is a percentage, need to multiply 180 to get the real angle or multiply PI to get the radian. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float angle > ``` #### seg\\_mask {#seg\\_mask} segmentation mask, uint8 list type, shape is h * w but flattened to one dimension, value fron 0 to 255. item description **type** var **attention** For efficiency, it's a pointer in C++, use this carefully! **static** False **readonly** False > C++ defination code: > ```cpp > image::Image *seg_mask > ``` ### ObjectFloat {#ObjectFloat} Object for detect result > C++ defination code: > ```cpp > class ObjectFloat > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 9} ```python def __init__(self, x: float 0, y: float 0, w: float 0, h: float 0, class_id: float 0, score: float 0, points: list[float] [], angle: float 1) > None ``` Constructor of Object for detect result item description **type** func **param** **x**: left top x<br>**y**: left top y<br>**w**: width<br>**h**: height<br>**class_id**: class id<br>**score**: score<br> **static** False > C++ defination code: > ```cpp > ObjectFloat(float x 0, float y 0, float w 0, float h 0, float class_id 0, float score 0, std::vector<float> points std::vector<float>(), float angle 1) > ``` #### \\_\\_str\\_\\_ {#\\_\\_str\\_\\_ 2} ```python def __str__(self) > str ``` Object info to string item description **type** func **return** Object info string **static** False > C++ defination code: > ```cpp > std::string to_str() > ``` #### x {#x 2} Object left top coordinate x item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float x > ``` #### y {#y 2} Object left top coordinate y item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float y > ``` #### w {#w 2} Object width item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float w > ``` #### h {#h 2} Object height item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float h > ``` #### class\\_id {#class\\_id 2} Object class id item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float class_id > ``` #### score {#score 2} Object score item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float score > ``` #### points {#points 2} keypoints item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> points > ``` #### angle {#angle 2} Rotate angle item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float angle > ``` ### Objects {#Objects} Objects Class for detect result > C++ defination code: > ```cpp > class Objects > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 10} ```python def __init__(self) > None ``` Constructor of Objects class item description **type** func **static** False > C++ defination code: > ```cpp > Objects() > ``` #### add {#add} ```python def add(self, x: int 0, y: int 0, w: int 0, h: int 0, class_id: int 0, score: float 0, points: list[int] [], angle: float 1) > Object ``` Add object to objects item description **type** func **throw** Throw exception if no memory **static** False > C++ defination code: > ```cpp > nn::Object &add(int x 0, int y 0, int w 0, int h 0, int class_id 0, float score 0, std::vector<int> points std::vector<int>(), float angle 1) > ``` #### remove {#remove} ```python def remove(self, idx: int) > maix.err.Err ``` Remove object form objects item description **type** func **static** False > C++ defination code: > ```cpp > err::Err remove(int idx) > ``` #### at {#at} ```python def at(self, idx: int) > Object ``` Get object item item description **type** func **static** False > C++ defination code: > ```cpp > nn::Object &at(int idx) > ``` #### \\_\\_getitem\\_\\_ {#\\_\\_getitem\\_\\_} ```python def __getitem__(self, idx: int) > Object ``` Get object item item description **type** func **static** False > C++ defination code: > ```cpp > nn::Object &operator[](int idx) > ``` #### \\_\\_len\\_\\_ {#\\_\\_len\\_\\_} ```python def __len__(self) > int ``` Get size item description **type** func **static** False > C++ defination code: > ```cpp > size_t size() > ``` #### \\_\\_iter\\_\\_ {#\\_\\_iter\\_\\_} ```python def __iter__(self) > typing.Iterator ``` Begin item description **type** func **static** False > C++ defination code: > ```cpp > std::vector<Object*>::iterator begin() > ``` ### FaceDetector {#FaceDetector} FaceDetector class > C++ defination code: > ```cpp > class FaceDetector > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 11} ```python def __init__(self, model: str '', dual_buff: bool True) > None ``` Constructor of FaceDetector class item description **type** func **param** **model**: model path, default empty, you can load model later by load function.<br>**dual_buff**: direction [in], prepare dual input output buffer to accelarate forward, that is, when NPU is forwarding we not wait and prepare the next input buff.<br>If you want to ensure every time forward output the input's result, set this arg to false please.<br>Default true to ensure speed.<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False > C++ defination code: > ```cpp > FaceDetector(const string &model \"\", bool dual_buff true) > ``` #### load {#load 8} ```python def load(self, model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: Model path want to load<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err load(const string &model) > ``` #### detect {#detect 3} ```python def detect(self, img: maix.image.Image, conf_th: float 0.5, iou_th: float 0.45, fit: maix.image.Fit ...) > list[Object] ``` Detect objects from image item description **type** func **param** **img**: Image want to detect, if image's size not match model input's, will auto resize with fit method.<br>**conf_th**: Confidence threshold, default 0.5.<br>**iou_th**: IoU threshold, default 0.45.<br>**fit**: Resize method, default image.Fit.FIT_CONTAIN.<br> **throw** If image format not match model input format, will throw err::Exception. **return** Object list. In C++, you should delete it after use. **static** False > C++ defination code: > ```cpp > std::vector<nn::Object> *detect(image::Image &img, float conf_th 0.5, float iou_th 0.45, maix::image::Fit fit maix::image::FIT_CONTAIN) > ``` #### input\\_size {#input\\_size 6} ```python def input_size(self) > maix.image.Size ``` Get model input size item description **type** func **return** model input size **static** False > C++ defination code: > ```cpp > image::Size input_size() > ``` #### input\\_width {#input\\_width 7} ```python def input_width(self) > int ``` Get model input width item description **type** func **return** model input size of width **static** False > C++ defination code: > ```cpp > int input_width() > ``` #### input\\_height {#input\\_height 7} ```python def input_height(self) > int ``` Get model input height item description **type** func **return** model input size of height **static** False > C++ defination code: > ```cpp > int input_height() > ``` #### input\\_format {#input\\_format 7} ```python def input_format(self) > maix.image.Format ``` Get input image format item description **type** func **return** input image format, image::Format type. **static** False > C++ defination code: > ```cpp > image::Format input_format() > ``` #### mean {#mean 6} Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean > ``` #### scale {#scale 6} Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale > ``` ### OCR\\_Box {#OCR\\_Box} Object for OCR detect box > C++ defination code: > ```cpp > class OCR_Box > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 12} ```python def __init__(self, x1: int 0, y1: int 0, x2: int 0, y2: int 0, x3: int 0, y3: int 0, x4: int 0, y4: int 0) > None ``` OCR_Box constructor item description **type** func **static** False > C++ defination code: > ```cpp > OCR_Box(int x1 0, int y1 0, int x2 0, int y2 0, int x3 0, int y3 0, int x4 0, int y4 0) > ``` #### x1 {#x1} left top point of box item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int x1 > ``` #### y1 {#y1} left top point of box item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int y1 > ``` #### x2 {#x2} right top point of box item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int x2 > ``` #### y2 {#y2} right top point of box item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int y2 > ``` #### x3 {#x3} right bottom point of box item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int x3 > ``` #### y3 {#y3} right bottom point of box item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int y3 > ``` #### x4 {#x4} left bottom point of box item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int x4 > ``` #### y4 {#y4} left bottom point of box item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int y4 > ``` #### to\\_list {#to\\_list} ```python def to_list(self) > list[int] ``` convert box point to a list type. item description **type** func **return** list type, element is int type, value [x1, y1, x2, y2, x3, y3, x4, y4]. **static** False > C++ defination code: > ```cpp > std::vector<int> to_list() > ``` ### OCR\\_Object {#OCR\\_Object} Object for OCR detect result > C++ defination code: > ```cpp > class OCR_Object > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 13} ```python def __init__(self, box: OCR_Box, idx_list: list[int], char_list: list[str], score: float 0, char_pos: list[int] []) > None ``` Constructor of Object for OCR detect result item description **type** func **param** **score**: score<br> **static** False > C++ defination code: > ```cpp > OCR_Object(const nn::OCR_Box &box, const std::vector<int> &idx_list, const std::vector<std::string> &char_list, float score 0, const std::vector<int> &char_pos std::vector<int>()) > ``` #### box {#box} OCR_Object box, 4 points box, first point at the left top, clock wise. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > nn::OCR_Box box > ``` #### score {#score 3} Object score item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float score > ``` #### idx\\_list {#idx\\_list} chars' idx list, element is int type. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<int> idx_list > ``` #### char\\_pos {#char\\_pos} Chars' position relative to left item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<int> char_pos > ``` #### char\\_str {#char\\_str} ```python def char_str(self) > str ``` Get OCR_Object's charactors, return a string type. item description **type** func **return** All charactors in string type. **static** False > C++ defination code: > ```cpp > const std::string &char_str() > ``` #### char\\_list {#char\\_list} ```python def char_list(self) > list[str] ``` Get OCR_Object's charactors, return a list type. item description **type** func **return** All charactors in list type. **static** False > C++ defination code: > ```cpp > const std::vector<std::string> &char_list() > ``` #### update\\_chars {#update\\_chars} ```python def update_chars(self, char_list: list[str]) > None ``` Set OCR_Object's charactors item description **type** func **param** **char_list**: All charactors in list type.<br> **static** False > C++ defination code: > ```cpp > void update_chars(const std::vector<std::string> &char_list) > ``` #### \\_\\_str\\_\\_ {#\\_\\_str\\_\\_ 3} ```python def __str__(self) > str ``` OCR_Object info to string item description **type** func **return** OCR_Object info string **static** False > C++ defination code: > ```cpp > std::string to_str() > ``` ### OCR\\_Objects {#OCR\\_Objects} OCR_Objects Class for detect result > C++ defination code: > ```cpp > class OCR_Objects > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 14} ```python def __init__(self) > None ``` Constructor of OCR_Objects class item description **type** func **static** False > C++ defination code: > ```cpp > OCR_Objects() > ``` #### add {#add 2} ```python def add(self, box: OCR_Box, idx_list: list[int], char_list: list[str], score: float 0, char_pos: list[int] []) > OCR_Object ``` Add object to objects item description **type** func **throw** Throw exception if no memory **static** False > C++ defination code: > ```cpp > nn::OCR_Object &add(const nn::OCR_Box &box, const std::vector<int> &idx_list, const std::vector<std::string> &char_list, float score 0, const std::vector<int> &char_pos std::vector<int>()) > ``` #### remove {#remove 2} ```python def remove(self, idx: int) > maix.err.Err ``` Remove object form objects item description **type** func **static** False > C++ defination code: > ```cpp > err::Err remove(int idx) > ``` #### at {#at 2} ```python def at(self, idx: int) > OCR_Object ``` Get object item item description **type** func **static** False > C++ defination code: > ```cpp > nn::OCR_Object &at(int idx) > ``` #### \\_\\_getitem\\_\\_ {#\\_\\_getitem\\_\\_ 2} ```python def __getitem__(self, idx: int) > OCR_Object ``` Get object item item description **type** func **static** False > C++ defination code: > ```cpp > nn::OCR_Object &operator[](int idx) > ``` #### \\_\\_len\\_\\_ {#\\_\\_len\\_\\_ 2} ```python def __len__(self) > int ``` Get size item description **type** func **static** False > C++ defination code: > ```cpp > size_t size() > ``` #### \\_\\_iter\\_\\_ {#\\_\\_iter\\_\\_ 2} ```python def __iter__(self) > typing.Iterator ``` Begin item description **type** func **static** False > C++ defination code: > ```cpp > std::vector<OCR_Object*>::iterator begin() > ``` ### MeloTTS {#MeloTTS} MeloTTS class > C++ defination code: > ```cpp > class MeloTTS > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 15} ```python def __init__(self, model: str '', language: str 'zh', speed: float 0.800000011920929, noise_scale: float 0.30000001192092896, noise_scale_w: float 0.6000000238418579, sdp_ratio: float 0.20000000298023224) > None ``` Constructor of MeloTTS class item description **type** func **param** **model**: model path, default empty, you can load model later by load function.<br>**language**: language code, default \"zh\", supported language code: \"zh\"<br>**speed**: the speech rate of the audio is controlled by this value,lower values result in slower reading speed. default is 0.8<br>**noise_scale**: this parameter controls the randomness in speech. increasing the value results in more varied and less deterministic speech output.default is 0.3<br>**noise_scale_w**: this parameter controls the randomness in speech alignment. while a higher value can enhance naturalness, overly high values may introduce instability or distortion in the audio. default is 0.6<br>**sdp_ratio**: the higher the alignment weight, the more natural the speech sounds, but excessive values may result in instability. default is 0.2<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False > C++ defination code: > ```cpp > MeloTTS(const string &model \"\", std::string language \"zh\", double speed 0.8f, double noise_scale 0.3f, double noise_scale_w 0.6f, double sdp_ratio 0.2f) > ``` #### load {#load 9} ```python def load(self, model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: Model path want to load<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err load(const string &model) > ``` #### infer {#infer} ```python def infer(*args, **kwargs) ``` Text to speech item description **type** func **param** **text**: input text<br>**path**: The output path of the voice file, the default sampling rate is 44100,<br>the number of channels is 1, and the number of sampling bits is 16. default is empty.<br>**output_pcm**: Enable or disable the output of raw PCM data. The default output sampling rate is 44100,<br>the number of channels is 1, and the sampling depth is 16 bits. default is false.<br> **return** raw PCM data **static** False > C++ defination code: > ```cpp > Bytes *infer(std::string text, std::string path \"\", bool output_pcm false) > ``` #### samplerate {#samplerate} ```python def samplerate(self) > int ``` Get pcm samplerate item description **type** func **return** pcm samplerate **static** False > C++ defination code: > ```cpp > int samplerate() > ``` #### speed {#speed} ```python def speed(self) > float ``` Get the speed of the text item description **type** func **return** text speed **static** False > C++ defination code: > ```cpp > double speed() > ``` ### Whisper {#Whisper} Whiper class > C++ defination code: > ```cpp > class Whisper > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 16} ```python def __init__(self, model: str '', language: str 'zh') > None ``` Constructor of Whisper class item description **type** func **param** **model**: model path, default empty, you can load model later by load function.<br>**language**: language code, default \"zh\", supported language code: \"zh\", \"en\"<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False > C++ defination code: > ```cpp > Whisper(const string &model \"\", std::string language \"zh\") > ``` #### load {#load 10} ```python def load(self, model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: Model path want to load<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err load(const string &model) > ``` #### transcribe {#transcribe} ```python def transcribe(self, file: str) > str ``` Transcribe audio file to text item description **type** func **note** If the wav file has multiple channels, only the first channel will be used. **param** **file**: Pass in an audio file, supporting files in wav,pcm format.<br> **return** The output result after automatic speech recognition. **static** False > C++ defination code: > ```cpp > std::string transcribe(std::string &file) > ``` #### transcribe\\_raw {#transcribe\\_raw} ```python def transcribe_raw(self, pcm: maix.Bytes(bytes), sample_rate: int 16000, channels: int 1, bits_per_frame: int 16) > str ``` Transcribe pcm data to text item description **type** func **param** **pcm**: RAW data<br> **return** The output result after automatic speech recognition. **static** False > C++ defination code: > ```cpp > std::string transcribe_raw(Bytes *pcm, int sample_rate 16000, int channels 1, int bits_per_frame 16) > ``` #### input\\_pcm\\_samplerate {#input\\_pcm\\_samplerate} ```python def input_pcm_samplerate(self) > int ``` Get input pcm samplerate item description **type** func **return** input pcm samplerate **static** False > C++ defination code: > ```cpp > int input_pcm_samplerate() > ``` #### input\\_pcm\\_channels {#input\\_pcm\\_channels} ```python def input_pcm_channels(self) > int ``` Get input pcm channels item description **type** func **return** input pcm channels **static** False > C++ defination code: > ```cpp > int input_pcm_channels() > ``` #### input\\_pcm\\_bits\\_per\\_frame {#input\\_pcm\\_bits\\_per\\_frame} ```python def input_pcm_bits_per_frame(self) > int ``` Get input pcm bits per frame item description **type** func **return** input pcm bits per frame **static** False > C++ defination code: > ```cpp > int input_pcm_bits_per_frame() > ``` ### MUD {#MUD} MUD(model universal describe file) class > C++ defination code: > ```cpp > class MUD > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 17} ```python def __init__(self, model_path: str '') > None ``` MUD constructor item description **type** func **param** **model_path**: direction [in], model file path, model format can be MUD(model universal describe file) file.<br>If model_path set, will load model from file, load failed will raise err.Exception.<br>If model_path not set, you can load model later by load function.<br> **static** False > C++ defination code: > ```cpp > MUD(const std::string &model_path \"\") > ``` #### load {#load 11} ```python def load(self, model_path: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model_path**: direction [in], model file path, model format can be MUD(model universal describe file) file.<br> **return** error code, if load success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err load(const std::string &model_path) > ``` #### type {#type} Model type, string type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string type > ``` #### items {#items} Model config items, different model type has different config items item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::map<std::string, std::map<std::string, std::string>> items > ``` #### model\\_path {#model\\_path} Model path item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string model_path > ``` #### parse\\_labels {#parse\\_labels} ```python def parse_labels(self, key: str 'labels') > list[str] ``` Please load() first, parse labels in items[\\\"extra\\\"][\\\"labels\\\"],\\nif items[\\\"extra\\\"][\\\"labels\\\"] is a file path: will parse file, every one line is a label;\\nif items[\\\"extra\\\"][\\\"labels\\\"] is a string, labels split by comma(\\\",\\\").\\nExecute this method will replace items[\\\"extra\\\"][\\\"labels\\\"]; item description **type** func **param** **key**: parse from items[key], default \"labels\".<br> **return** parsed labels list. **static** False > C++ defination code: > ```cpp > std::vector<std::string> parse_labels(const std::string key \"labels\") > ``` ### LayerInfo {#LayerInfo} NN model layer info > C++ defination code: > ```cpp > class LayerInfo > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 18} ```python def __init__(self, name: str '', dtype: maix.tensor.DType ..., shape: list[int] []) > None ``` LayerInfo constructor item description **type** func **param** **name**: direction [in], layer name<br>**dtype**: direction [in], layer data type<br>**shape**: direction [in], layer shape<br> **static** False > C++ defination code: > ```cpp > LayerInfo(const std::string &name \"\", tensor::DType dtype tensor::DType::FLOAT32, std::vector<int> shape std::vector<int>()) > ``` #### name {#name} Layer name item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string name > ``` #### dtype {#dtype} Layer data type item description **type** var **attention** If model is quantized, this is the real quantized data type like int8 float16,<br>in most scene, inputs and outputs we actually use float32 in API like forward. **static** False **readonly** False > C++ defination code: > ```cpp > tensor::DType dtype > ``` #### shape {#shape} Layer shape item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<int> shape > ``` #### layout {#layout 2} If layer layout, if layout is chw, typically the shape is [N, C, H, W], hwc is [N, H, W, C]. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > nn::Layout layout nn::Layout::UNKNOWN > ``` #### shape\\_int {#shape\\_int} ```python def shape_int(self) > int ``` Shape as one int type, multiply all dims of shape item description **type** func **static** False > C++ defination code: > ```cpp > int shape_int() > ``` #### to\\_str {#to\\_str} ```python def to_str(self) > str ``` To string item description **type** func **static** False > C++ defination code: > ```cpp > std::string to_str() > ``` #### \\_\\_str\\_\\_ {#\\_\\_str\\_\\_ 4} ```python def __str__(self) > str ``` To string item description **type** func **static** False > C++ defination code: > ```cpp > std::string __str__() > ``` ### NN {#NN} Neural network class > C++ defination code: > ```cpp > class NN > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 19} ```python def __init__(self, model: str '', dual_buff: bool False) > None ``` Neural network constructor item description **type** func **param** **model**: direction [in], model file path, model format can be MUD(model universal describe file) file.<br>If model_path set, will load model from file, load failed will raise err.Exception.<br>If model_path not set, you can load model later by load function.<br>**dual_buff**: direction [in], prepare dual input output buffer to accelarate forward, that is, when NPU is forwarding we not wait and prepare the next input buff.<br>If you want to ensure every time forward output the input's result, set this arg to false please.<br>Default false to ensure easy use.<br> **static** False > C++ defination code: > ```cpp > NN(const std::string &model \"\", bool dual_buff false) > ``` #### load {#load 12} ```python def load(self, model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: direction [in], model file path, model format can be MUD(model universal describe file) file.<br> **return** error code, if load success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err load(const std::string &model) > ``` #### loaded {#loaded 3} ```python def loaded(self) > bool ``` Is model loaded item description **type** func **return** true if model loaded, else false **static** False > C++ defination code: > ```cpp > bool loaded() > ``` #### set\\_dual\\_buff {#set\\_dual\\_buff} ```python def set_dual_buff(self, enable: bool) > None ``` Enable dual buff or disable dual buff item description **type** func **param** **enable**: true to enable, false to disable<br> **static** False > C++ defination code: > ```cpp > void set_dual_buff(bool enable) > ``` #### inputs\\_info {#inputs\\_info} ```python def inputs_info(self) > list[LayerInfo] ``` Get model input layer info item description **type** func **return** input layer info **static** False > C++ defination code: > ```cpp > std::vector<nn::LayerInfo> inputs_info() > ``` #### outputs\\_info {#outputs\\_info} ```python def outputs_info(self) > list[LayerInfo] ``` Get model output layer info item description **type** func **return** output layer info **static** False > C++ defination code: > ```cpp > std::vector<nn::LayerInfo> outputs_info() > ``` #### extra\\_info {#extra\\_info} ```python def extra_info(self) > dict[str, str] ``` Get model extra info define in MUD file item description **type** func **return** extra info, dict type, key value object, attention: key and value are all string type. **static** False > C++ defination code: > ```cpp > std::map<std::string, std::string> extra_info() > ``` #### extra\\_info\\_labels {#extra\\_info\\_labels} ```python def extra_info_labels(self) > list[str] ``` Get model parsed extra info labels define in MUD file item description **type** func **return** labels list in extra info, string list type. **static** False > C++ defination code: > ```cpp > std::vector<std::string> extra_info_labels() > ``` #### forward {#forward} ```python def forward(self, inputs: maix.tensor.Tensors, copy_result: bool True, dual_buff_wait: bool False) > maix.tensor.Tensors ``` forward run model, get output of model,\\nthis is specially for MaixPy, not efficient, but easy to use in MaixPy item description **type** func **param** **input**: direction [in], input tensor<br>**copy_result**: If set true, will copy result to a new variable; else will use a internal memory, you can only use it until to the next forward.<br>Default true to avoid problems, you can set it to false manually to make speed faster.<br>**dual_buff_wait**: bool type, only for dual_buff mode, if true, will inference this image and wait for result, default false.<br> **return** output tensor. In C++, you should manually delete tensors in return value and return value.<br>If dual_buff mode, it can be NULL(None in MaixPy) means not ready. **throw** if error ocurrs like no memory or arg error, will raise err.Exception. **static** False > C++ defination code: > ```cpp > tensor::Tensors *forward(tensor::Tensors &inputs, bool copy_result true, bool dual_buff_wait false) > ``` #### forward\\_image {#forward\\_image} ```python def forward_image(self, img: maix.image.Image, mean: list[float] [], scale: list[float] [], fit: maix.image.Fit ..., copy_result: bool True, dual_buff_wait: bool False, chw: bool True) > maix.tensor.Tensors ``` forward model, param is image item description **type** func **param** **img**: input image<br>**mean**: mean value, a list type, e.g. [0.485, 0.456, 0.406], default is empty list means not normalize.<br>**scale**: scale value, a list type, e.g. [1/0.229, 1/0.224, 1/0.225], default is empty list means not normalize.<br>**fit**: fit mode, if the image size of input not equal to model's input, it will auto resize use this fit method,<br>default is image.Fit.FIT_FILL for easy coordinate calculation, but for more accurate result, use image.Fit.FIT_CONTAIN is better.<br>**copy_result**: If set true, will copy result to a new variable; else will use a internal memory, you can only use it until to the next forward.<br>Default true to avoid problems, you can set it to false manually to make speed faster.<br>**dual_buff_wait**: bool type, only for dual_buff mode, if true, will inference this image and wait for result, default false.<br>**chw**: !!depracated!! This arg will be ignored!!! Please set extra.input_layout in mud file instead.<br>chw channel format, forward model with hwc format image input if set to false, default true(chw).<br> **return** output tensor. In C++, you should manually delete tensors in return value and return value.<br>If dual_buff mode, it can be NULL(None in MaixPy) means not ready. **throw** If error occurs, like arg error or alloc memory failed, will raise err.Exception. **static** False > C++ defination code: > ```cpp > tensor::Tensors *forward_image(image::Image &img, std::vector<float> mean std::vector<float>(), std::vector<float> scale std::vector<float>(), image::Fit fit image::Fit::FIT_FILL, bool copy_result true, bool dual_buff_wait false, bool chw true) > ``` ### YOLOv8 {#YOLOv8} YOLOv8 class > C++ defination code: > ```cpp > class YOLOv8 : public YOLO11 > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 20} ```python def __init__(self, model: str '', dual_buff: bool True) > None ``` Constructor of YOLOv8 class item description **type** func **param** **model**: model path, default empty, you can load model later by load function.<br>**dual_buff**: direction [in], prepare dual input output buffer to accelarate forward, that is, when NPU is forwarding we not wait and prepare the next input buff.<br>If you want to ensure every time forward output the input's result, set this arg to false please.<br>Default true to ensure speed.<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False > C++ defination code: > ```cpp > YOLOv8(const string &model \"\", bool dual_buff true) > ``` #### load {#load 13} ```python def load(self, model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: Model path want to load<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err load(const string &model) > ``` #### detect {#detect 4} ```python def detect(self, img: maix.image.Image, conf_th: float 0.5, iou_th: float 0.45, fit: maix.image.Fit ..., keypoint_th: float 0.5, sort: int 0) > Objects ``` Detect objects from image item description **type** func **param** **img**: Image want to detect, if image's size not match model input's, will auto resize with fit method.<br>**conf_th**: Confidence threshold, default 0.5.<br>**iou_th**: IoU threshold, default 0.45.<br>**fit**: Resize method, default image.Fit.FIT_CONTAIN.<br>**keypoint_th**: keypoint threshold, default 0.5, only for yolov8 pose model.<br>**sort**: sort result according to object size, default 0 means not sort, 1 means bigger in front, 1 means smaller in front.<br> **throw** If image format not match model input format, will throw err::Exception. **return** Object list. In C++, you should delete it after use.<br>If model is yolov8 pose, object's points have value, and if points' value < 0 means that point is invalid(conf < keypoint_th). **static** False > C++ defination code: > ```cpp > nn::Objects *detect(image::Image &img, float conf_th 0.5, float iou_th 0.45, maix::image::Fit fit maix::image::FIT_CONTAIN, float keypoint_th 0.5, int sort 0) > ``` #### input\\_size {#input\\_size 7} ```python def input_size(self) > maix.image.Size ``` Get model input size item description **type** func **return** model input size **static** False > C++ defination code: > ```cpp > image::Size input_size() > ``` #### input\\_width {#input\\_width 8} ```python def input_width(self) > int ``` Get model input width item description **type** func **return** model input size of width **static** False > C++ defination code: > ```cpp > int input_width() > ``` #### input\\_height {#input\\_height 8} ```python def input_height(self) > int ``` Get model input height item description **type** func **return** model input size of height **static** False > C++ defination code: > ```cpp > int input_height() > ``` #### input\\_format {#input\\_format 8} ```python def input_format(self) > maix.image.Format ``` Get input image format item description **type** func **return** input image format, image::Format type. **static** False > C++ defination code: > ```cpp > image::Format input_format() > ``` #### draw\\_pose {#draw\\_pose 2} ```python def draw_pose(self, img: maix.image.Image, points: list[int], radius: int 4, color: maix.image.Color ..., colors: list[maix.image.Color] [], body: bool True, close: bool False) > None ``` Draw pose keypoints on image item description **type** func **param** **img**: image object, maix.image.Image type.<br>**points**: keypoits, int list type, [x, y, x, y ...]<br>**radius**: radius of points.<br>**color**: color of points.<br>**colors**: assign colors for points, list type, element is image.Color object.<br>**body**: true, if points' length is 17*2 and body is ture, will draw lines as human body, if set to false won't draw lines, default true.<br>**close**: connect all points to close a polygon, default false.<br> **static** False > C++ defination code: > ```cpp > void draw_pose(image::Image &img, std::vector<int> points, int radius 4, image::Color color image::COLOR_RED, const std::vector<image::Color> &colors std::vector<image::Color>(), bool body true, bool close false) > ``` #### draw\\_seg\\_mask {#draw\\_seg\\_mask 2} ```python def draw_seg_mask(self, img: maix.image.Image, x: int, y: int, seg_mask: maix.image.Image, threshold: int 127) > None ``` Draw segmentation on image item description **type** func **param** **img**: image object, maix.image.Image type.<br>**seg_mask**: segmentation mask image by detect method, a grayscale image<br>**threshold**: only mask's value > threshold will be draw on image, value from 0 to 255.<br> **static** False > C++ defination code: > ```cpp > void draw_seg_mask(image::Image &img, int x, int y, image::Image &seg_mask, int threshold 127) > ``` #### labels {#labels 3} Labels list item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<string> labels > ``` #### label\\_path {#label\\_path 3} Label file path item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string label_path > ``` #### mean {#mean 7} Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean > ``` #### scale {#scale 7} Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale > ``` ### PP\\_OCR {#PP\\_OCR} PP_OCR class > C++ defination code: > ```cpp > class PP_OCR > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 21} ```python def __init__(self, model: str '') > None ``` Constructor of PP_OCR class item description **type** func **param** **model**: model path, default empty, you can load model later by load function.<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False > C++ defination code: > ```cpp > PP_OCR(const string &model \"\") > ``` #### load {#load 14} ```python def load(self, model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: Model path want to load<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err load(const string &model) > ``` #### detect {#detect 5} ```python def detect(self, img: maix.image.Image, thresh: float 0.3, box_thresh: float 0.6, fit: maix.image.Fit ..., char_box: bool False) > OCR_Objects ``` Detect objects from image item description **type** func **param** **img**: Image want to detect, if image's size not match model input's, will auto resize with fit method.<br>**thresh**: Confidence threshold where pixels have charactor, default 0.3.<br>**box_thresh**: Box threshold, the box prob higher than this value will be valid, default 0.6.<br>**fit**: Resize method, default image.Fit.FIT_CONTAIN.<br>**char_box**: Calculate every charactor's box, default false, if true then you can get charactor's box by nn.OCR_Object's char_boxes attribute.<br> **throw** If image format not match model input format or no memory, will throw err::Exception. **return** nn.OCR_Objects type. In C++, you should delete it after use. **static** False > C++ defination code: > ```cpp > nn::OCR_Objects *detect(image::Image &img, float thresh 0.3, float box_thresh 0.6, maix::image::Fit fit maix::image::FIT_CONTAIN, bool char_box false) > ``` #### recognize {#recognize} ```python def recognize(self, img: maix.image.Image, box_points: list[int] []) > OCR_Object ``` Only recognize, not detect item description **type** func **param** **img**: image to recognize chractors, can be a stanrd cropped charactors image,<br>if crop image not standard, you can use box_points to assgin where the charactors' 4 corner is.<br>**box_points**: list type, length must be 8 or 0, default empty means not transfer image to standard image.<br>4 points postiion, format: [x1, y1, x2, y2, x3, y3, x4, y4], point 1 at the left top, point 2 right top...<br>**char_box**: Calculate every charactor's box, default false, if true then you can get charactor's box by nn.OCR_Object's char_boxes attribute.<br> **static** False > C++ defination code: > ```cpp > nn::OCR_Object *recognize(image::Image &img, const std::vector<int> &box_points std::vector<int>()) > ``` #### draw\\_seg\\_mask {#draw\\_seg\\_mask 3} ```python def draw_seg_mask(self, img: maix.image.Image, x: int, y: int, seg_mask: maix.image.Image, threshold: int 127) > None ``` Draw segmentation on image item description **type** func **param** **img**: image object, maix.image.Image type.<br>**seg_mask**: segmentation mask image by detect method, a grayscale image<br>**threshold**: only mask's value > threshold will be draw on image, value from 0 to 255.<br> **static** False > C++ defination code: > ```cpp > void draw_seg_mask(image::Image &img, int x, int y, image::Image &seg_mask, int threshold 127) > ``` #### input\\_size {#input\\_size 8} ```python def input_size(self) > maix.image.Size ``` Get model input size item description **type** func **return** model input size **static** False > C++ defination code: > ```cpp > image::Size input_size() > ``` #### input\\_width {#input\\_width 9} ```python def input_width(self) > int ``` Get model input width item description **type** func **return** model input size of width **static** False > C++ defination code: > ```cpp > int input_width() > ``` #### input\\_height {#input\\_height 9} ```python def input_height(self) > int ``` Get model input height item description **type** func **return** model input size of height **static** False > C++ defination code: > ```cpp > int input_height() > ``` #### input\\_format {#input\\_format 9} ```python def input_format(self) > maix.image.Format ``` Get input image format item description **type** func **return** input image format, image::Format type. **static** False > C++ defination code: > ```cpp > image::Format input_format() > ``` #### mean {#mean 8} Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean > ``` #### scale {#scale 8} Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale > ``` #### rec\\_mean {#rec\\_mean} Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> rec_mean > ``` #### rec\\_scale {#rec\\_scale} Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> rec_scale > ``` #### labels {#labels 4} labels (charactors) item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<std::string> labels > ``` #### det {#det} model have detect model item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > bool det > ``` #### rec {#rec} model have recognize model item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > bool rec > ``` ### YOLOWorld {#YOLOWorld} YOLOWorld class > C++ defination code: > ```cpp > class YOLOWorld > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 22} ```python def __init__(self, model: str '', text_feature: str '', labels: str '', dual_buff: bool True) > None ``` Constructor of YOLOWorld class item description **type** func **param** **model**: model path, default empty, you can load model later by load function.<br>**text_feature**: class text feature path, more info refer to load method, default empty, you can load class text feature later by load function.<br>**labels**: Class labels or labels file path.<br>If string class labels: labels split by comma, e.g. \"person, car, cat\".<br>If file path: labels file path, each line is a label.<br>**dual_buff**: direction [in], prepare dual input output buffer to accelarate forward, that is, when NPU is forwarding we not wait and prepare the next input buff.<br>If you want to ensure every time forward output the input's result, set this arg to false please.<br>Default true to ensure speed.<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False > C++ defination code: > ```cpp > YOLOWorld(const string &model \"\", const string &text_feature \"\", const string &labels \"\", bool dual_buff true) > ``` #### load {#load 15} ```python def load(self, model: str, text_feature: str, labels: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: Model path want to load<br>**text_feature**: Class text feature bin file path.<br>**labels**: Class labels or labels file path.<br>If string class labels: labels split by comma, e.g. \"person, car, cat\".<br>If file path: labels file path, each line is a label.<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err load(const string &model, const string &text_feature, const string &labels) > ``` #### learn\\_text\\_feature {#learn\\_text\\_feature} ```python def learn_text_feature(model: str, labels: list[str], feature_path: str, labels_path: str) > maix.err.Err ``` Set detector class labels dynamically, will generate class text feature and save to text_feature path set in load method or constructor. item description **type** func **param** **labels**: class labels you want to recognize, list type. e.g. [\"person\", \"car\", \"cat\"]<br> **return** err::Err **static** True > C++ defination code: > ```cpp > static err::Err learn_text_feature(const std::string &model, std::vector<std::string> labels, const std::string &feature_path, const std::string &labels_path) > ``` #### detect {#detect 6} ```python def detect(self, img: maix.image.Image, conf_th: float 0.5, iou_th: float 0.45, fit: maix.image.Fit ..., sort: int 0) > Objects ``` Detect objects from image item description **type** func **param** **img**: Image want to detect, if image's size not match model input's, will auto resize with fit method.<br>**conf_th**: Confidence threshold, default 0.5.<br>**iou_th**: IoU threshold, default 0.45.<br>**fit**: Resize method, default image.Fit.FIT_CONTAIN.<br>**sort**: sort result according to object size, default 0 means not sort, 1 means bigger in front, 1 means smaller in front.<br> **throw** If image format not match model input format, will throw err::Exception. **return** Object list. In C++, you should delete it after use. **static** False > C++ defination code: > ```cpp > nn::Objects *detect(image::Image &img, float conf_th 0.5, float iou_th 0.45, maix::image::Fit fit maix::image::FIT_CONTAIN, int sort 0) > ``` #### input\\_size {#input\\_size 9} ```python def input_size(self) > maix.image.Size ``` Get model input size item description **type** func **return** model input size **static** False > C++ defination code: > ```cpp > image::Size input_size() > ``` #### input\\_width {#input\\_width 10} ```python def input_width(self) > int ``` Get model input width item description **type** func **return** model input size of width **static** False > C++ defination code: > ```cpp > int input_width() > ``` #### input\\_height {#input\\_height 10} ```python def input_height(self) > int ``` Get model input height item description **type** func **return** model input size of height **static** False > C++ defination code: > ```cpp > int input_height() > ``` #### input\\_format {#input\\_format 10} ```python def input_format(self) > maix.image.Format ``` Get input image format item description **type** func **return** input image format, image::Format type. **static** False > C++ defination code: > ```cpp > image::Format input_format() > ``` #### labels {#labels 5} Labels list item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<string> labels > ``` #### mean {#mean 9} Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean > ``` #### scale {#scale 9} Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale > ``` ### NanoTrack {#NanoTrack} NanoTrack class > C++ defination code: > ```cpp > class NanoTrack > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 23} ```python def __init__(self, model: str '') > None ``` Constructor of NanoTrack class item description **type** func **param** **model**: model path, default empty, you can load model later by load function.<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False > C++ defination code: > ```cpp > NanoTrack(const string &model \"\") > ``` #### load {#load 16} ```python def load(self, model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: Model path want to load<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err load(const string &model) > ``` #### init {#init 2} ```python def init(self, img: maix.image.Image, x: int, y: int, w: int, h: int) > None ``` Init tracker, give tacker first target image and target position. item description **type** func **param** **img**: Image want to detect, target should be in this image.<br>**x**: the target position left top coordinate x.<br>**y**: the target position left top coordinate y.<br>**w**: the target width.<br>**h**: the target height.<br> **throw** If image format not match model input format, will throw err::Exception. **static** False > C++ defination code: > ```cpp > void init(image::Image &img, int x, int y, int w, int h) > ``` #### track {#track 2} ```python def track(self, img: maix.image.Image, threshold: float 0.9) > Object ``` Track object acoording to last object position and the init function learned target feature. item description **type** func **param** **img**: image to detect object and track, can be any resolution, before detect it will crop a area according to last time target's position.<br>**threshold**: If score < threshold, will see this new detection is invalid, but remain return this new detecion, default 0.9.<br> **return** object, attribute [x, y, w, h] and score are the predict target position and score, points attribute provide more info:<br>0~3 [ search_x, search_y, search_w, search_h ]: search area for this time track, based on last correct start position.<br>4~5 [ predict_cx, predict_cy]: predict center according to this time input.<br>6 [ search_size ]: search_area size based on last correct start position, center is (search_x search_w / 2, search_y search_h / 2).<br>7 [ predict_template_size ]: template size based on predict target, center is (predict_cx, predict_cy).<br>8~11 [ correct_cx, correct_cy, correct_w, correct_h]: latest correct (score > threshold) target position. **static** False > C++ defination code: > ```cpp > nn::Object track(image::Image &img, float threshold 0.9) > ``` #### input\\_size {#input\\_size 10} ```python def input_size(self) > maix.image.Size ``` Get model input size item description **type** func **return** model input size **static** False > C++ defination code: > ```cpp > image::Size input_size() > ``` #### input\\_width {#input\\_width 11} ```python def input_width(self) > int ``` Get model input width item description **type** func **return** model input size of width **static** False > C++ defination code: > ```cpp > int input_width() > ``` #### input\\_height {#input\\_height 11} ```python def input_height(self) > int ``` Get model input height item description **type** func **return** model input size of height **static** False > C++ defination code: > ```cpp > int input_height() > ``` #### input\\_format {#input\\_format 11} ```python def input_format(self) > maix.image.Format ``` Get input image format item description **type** func **return** input image format, image::Format type. **static** False > C++ defination code: > ```cpp > image::Format input_format() > ``` #### mean {#mean 10} Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean > ``` #### scale {#scale 10} Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale > ``` ### FaceObject {#FaceObject} Face object > C++ defination code: > ```cpp > class FaceObject > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 24} ```python def __init__(self, x: int 0, y: int 0, w: int 0, h: int 0, class_id: int 0, score: float 0, points: list[int] [], feature: list[float] [], face: maix.image.Image ...) > None ``` Constructor item description **type** func **static** False > C++ defination code: > ```cpp > FaceObject(int x 0, int y 0, int w 0, int h 0, int class_id 0, float score 0, std::vector<int> points std::vector<int>(), std::vector<float> feature std::vector<float>(), image::Image face image::Image()) > ``` #### \\_\\_str\\_\\_ {#\\_\\_str\\_\\_ 5} ```python def __str__(self) > str ``` FaceObject info to string item description **type** func **return** FaceObject info string **static** False > C++ defination code: > ```cpp > std::string to_str() > ``` #### x {#x 3} FaceObject left top coordinate x item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int x > ``` #### y {#y 3} FaceObject left top coordinate y item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int y > ``` #### w {#w 3} FaceObject width item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int w > ``` #### h {#h 3} FaceObject height item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int h > ``` #### class\\_id {#class\\_id 3} FaceObject class id item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int class_id > ``` #### score {#score 4} FaceObject score item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float score > ``` #### points {#points 3} keypoints item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<int> points > ``` #### feature {#feature} feature, float list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> feature > ``` #### face {#face} face image item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > image::Image face > ``` ### FaceObjects {#FaceObjects} Objects Class for detect result > C++ defination code: > ```cpp > class FaceObjects > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 25} ```python def __init__(self) > None ``` Constructor of FaceObjects class item description **type** func **static** False > C++ defination code: > ```cpp > FaceObjects() > ``` #### add {#add 3} ```python def add(self, x: int 0, y: int 0, w: int 0, h: int 0, class_id: int 0, score: float 0, points: list[int] [], feature: list[float] [], face: maix.image.Image ...) > FaceObject ``` Add object to FaceObjects item description **type** func **throw** Throw exception if no memory **static** False > C++ defination code: > ```cpp > nn::FaceObject &add(int x 0, int y 0, int w 0, int h 0, int class_id 0, float score 0, std::vector<int> points std::vector<int>(), std::vector<float> feature std::vector<float>(), image::Image face image::Image()) > ``` #### remove {#remove 3} ```python def remove(self, idx: int) > maix.err.Err ``` Remove object form FaceObjects item description **type** func **static** False > C++ defination code: > ```cpp > err::Err remove(int idx) > ``` #### at {#at 3} ```python def at(self, idx: int) > FaceObject ``` Get object item item description **type** func **static** False > C++ defination code: > ```cpp > nn::FaceObject &at(int idx) > ``` #### \\_\\_getitem\\_\\_ {#\\_\\_getitem\\_\\_ 3} ```python def __getitem__(self, idx: int) > FaceObject ``` Get object item item description **type** func **static** False > C++ defination code: > ```cpp > nn::FaceObject &operator[](int idx) > ``` #### \\_\\_len\\_\\_ {#\\_\\_len\\_\\_ 3} ```python def __len__(self) > int ``` Get size item description **type** func **static** False > C++ defination code: > ```cpp > size_t size() > ``` #### \\_\\_iter\\_\\_ {#\\_\\_iter\\_\\_ 3} ```python def __iter__(self) > typing.Iterator ``` Begin item description **type** func **static** False > C++ defination code: > ```cpp > std::vector<FaceObject*>::iterator begin() > ``` ### FaceRecognizer {#FaceRecognizer} FaceRecognizer class > C++ defination code: > ```cpp > class FaceRecognizer > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 26} ```python def __init__(self, detect_model: str '', feature_model: str '', dual_buff: bool True) > None ``` Constructor of FaceRecognizer class item description **type** func **param** **detect_model**: face detect model path, default empty, you can load model later by load function.<br>**feature_model**: feature extract model<br>**dual_buff**: direction [in], prepare dual input output buffer to accelarate forward, that is, when NPU is forwarding we not wait and prepare the next input buff.<br>If you want to ensure every time forward output the input's result, set this arg to false please.<br>Default true to ensure speed.<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False > C++ defination code: > ```cpp > FaceRecognizer(const string &detect_model \"\", const string &feature_model \"\", bool dual_buff true) > ``` #### load {#load 17} ```python def load(self, detect_model: str, feature_model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **detect_model**: face detect model path, default empty, you can load model later by load function.<br>**feature_model**: feature extract model<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err load(const string &detect_model, const string &feature_model) > ``` #### recognize {#recognize 2} ```python def recognize(self, img: maix.image.Image, conf_th: float 0.5, iou_th: float 0.45, compare_th: float 0.8, get_feature: bool False, get_face: bool False, fit: maix.image.Fit ...) > FaceObjects ``` Detect objects from image item description **type** func **param** **img**: Image want to detect, if image's size not match model input's, will auto resize with fit method.<br>**conf_th**: Detect confidence threshold, default 0.5.<br>**iou_th**: Detect IoU threshold, default 0.45.<br>**compare_th**: Compare two face score threshold, default 0.8, if two faces' score < this value, will see this face fas unknown.<br>**get_feature**: return feature or not, if true will copy features to result, if false will not copy feature to result to save time and memory.<br>**get_face**: return face image or not, if true result object's face attribute will valid, or face sttribute is empty. Get face image will alloc memory and copy image, so will lead to slower speed.<br>**fit**: Resize method, default image.Fit.FIT_CONTAIN.<br> **throw** If image format not match model input format, will throw err::Exception. **return** FaceObjects object. In C++, you should delete it after use. **static** False > C++ defination code: > ```cpp > nn::FaceObjects *recognize(image::Image &img, float conf_th 0.5, float iou_th 0.45, float compare_th 0.8, bool get_feature false, bool get_face false, maix::image::Fit fit maix::image::FIT_CONTAIN) > ``` #### add\\_face {#add\\_face} ```python def add_face(self, face: FaceObject, label: str) > maix.err.Err ``` Add face to lib item description **type** func **param** **face**: face object, find by recognize<br>**label**: face label(name)<br> **static** False > C++ defination code: > ```cpp > err::Err add_face(nn::FaceObject *face, const std::string &label) > ``` #### remove\\_face {#remove\\_face} ```python def remove_face(self, idx: int 1, label: str '') > maix.err.Err ``` remove face from lib item description **type** func **param** **idx**: index of face in lib, default 1 means use label, value [0,face_num), idx and label must have one, idx have high priotiry.<br>**label**: which face to remove, default to empty string mean use idx, idx and label must have one, idx have high priotiry.<br> **static** False > C++ defination code: > ```cpp > err::Err remove_face(int idx 1, const std::string &label \"\") > ``` #### save\\_faces {#save\\_faces} ```python def save_faces(self, path: str) > maix.err.Err ``` Save faces info to a file item description **type** func **param** **path**: where to save, string type.<br> **return** err.Err type **static** False > C++ defination code: > ```cpp > err::Err save_faces(const std::string &path) > ``` #### load\\_faces {#load\\_faces} ```python def load_faces(self, path: str) > maix.err.Err ``` Load faces info from a file item description **type** func **param** **path**: from where to load, string type.<br> **return** err::Err type **static** False > C++ defination code: > ```cpp > err::Err load_faces(const std::string &path) > ``` #### input\\_size {#input\\_size 11} ```python def input_size(self) > maix.image.Size ``` Get model input size item description **type** func **return** model input size **static** False > C++ defination code: > ```cpp > image::Size input_size() > ``` #### input\\_width {#input\\_width 12} ```python def input_width(self) > int ``` Get model input width item description **type** func **return** model input size of width **static** False > C++ defination code: > ```cpp > int input_width() > ``` #### input\\_height {#input\\_height 12} ```python def input_height(self) > int ``` Get model input height item description **type** func **return** model input size of height **static** False > C++ defination code: > ```cpp > int input_height() > ``` #### input\\_format {#input\\_format 12} ```python def input_format(self) > maix.image.Format ``` Get input image format item description **type** func **return** input image format, image::Format type. **static** False > C++ defination code: > ```cpp > image::Format input_format() > ``` #### mean\\_detector {#mean\\_detector} Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean_detector > ``` #### scale\\_detector {#scale\\_detector} Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale_detector > ``` #### mean\\_feature {#mean\\_feature} Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean_feature > ``` #### scale\\_feature {#scale\\_feature} Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale_feature > ``` #### labels {#labels 6} labels, list type, first is \\\"unknown\\\" item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<std::string> labels > ``` #### features {#features} features item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<std::vector<float>> features > ``` ### Classifier {#Classifier} Classifier > C++ defination code: > ```cpp > class Classifier > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 27} ```python def __init__(self, model: str '', dual_buff: bool True) > None ``` Construct a new Classifier object item description **type** func **param** **model**: MUD model path, if empty, will not load model, you can call load() later.<br>if not empty, will load model and will raise err::Exception if load failed.<br>**dual_buff**: direction [in], prepare dual input output buffer to accelarate forward, that is, when NPU is forwarding we not wait and prepare the next input buff.<br>If you want to ensure every time forward output the input's result, set this arg to false please.<br>Default true to ensure speed.<br> **static** False > C++ defination code: > ```cpp > Classifier(const string &model \"\", bool dual_buff true) > ``` #### load {#load 18} ```python def load(self, model: str) > maix.err.Err ``` Load model from file, model format is .mud,\\nMUD file should contain [extra] section, have key values:\\n model_type: classifier\\n input_type: rgb or bgr\\n mean: 123.675, 116.28, 103.53\\n scale: 0.017124753831663668, 0.01750700280112045, 0.017429193899782137\\n labels: imagenet_classes.txt item description **type** func **param** **model**: MUD model path<br> **return** error code, if load failed, return error code **static** False > C++ defination code: > ```cpp > err::Err load(const string &model) > ``` #### classify {#classify 2} ```python def classify(self, img: maix.image.Image, softmax: bool True, fit: maix.image.Fit ...) > list[tuple[int, float]] ``` Forward image to model, get result. Only for image input, use classify_raw for tensor input. item description **type** func **param** **img**: image, format should match model input_type， or will raise err.Exception<br>**softmax**: if true, will do softmax to result, or will return raw value<br>**fit**: image resize fit mode, default Fit.FIT_COVER, see image.Fit.<br> **throw** If error occurred, will raise err::Exception, you can find reason in log, mostly caused by args error or hardware error. **return** result, a list of (label, score). If in dual_buff mode, value can be one element list and score is zero when not ready. In C++, you need to delete it after use. **static** False > C++ defination code: > ```cpp > std::vector<std::pair<int, float>> *classify(image::Image &img, bool softmax true, image::Fit fit image::FIT_COVER) > ``` #### classify\\_raw {#classify\\_raw} ```python def classify_raw(self, data: maix.tensor.Tensor, softmax: bool True) > list[tuple[int, float]] ``` Forward tensor data to model, get result item description **type** func **param** **data**: tensor data, format should match model input_type， or will raise err.Excetion<br>**softmax**: if true, will do softmax to result, or will return raw value<br> **throw** If error occurred, will raise err::Exception, you can find reason in log, mostly caused by args error or hardware error. **return** result, a list of (label, score). In C++, you need to delete it after use. **static** False > C++ defination code: > ```cpp > std::vector<std::pair<int, float>> *classify_raw(tensor::Tensor &data, bool softmax true) > ``` #### input\\_size {#input\\_size 12} ```python def input_size(self) > maix.image.Size ``` Get model input size, only for image input item description **type** func **return** model input size **static** False > C++ defination code: > ```cpp > image::Size input_size() > ``` #### input\\_width {#input\\_width 13} ```python def input_width(self) > int ``` Get model input width, only for image input item description **type** func **return** model input size of width **static** False > C++ defination code: > ```cpp > int input_width() > ``` #### input\\_height {#input\\_height 13} ```python def input_height(self) > int ``` Get model input height, only for image input item description **type** func **return** model input size of height **static** False > C++ defination code: > ```cpp > int input_height() > ``` #### input\\_format {#input\\_format 13} ```python def input_format(self) > maix.image.Format ``` Get input image format, only for image input item description **type** func **return** input image format, image::Format type. **static** False > C++ defination code: > ```cpp > image::Format input_format() > ``` #### input\\_shape {#input\\_shape 3} ```python def input_shape(self) > list[int] ``` Get input shape, if have multiple input, only return first input shape item description **type** func **return** input shape, list type **static** False > C++ defination code: > ```cpp > std::vector<int> input_shape() > ``` #### labels {#labels 7} Labels list item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<string> labels > ``` #### label\\_path {#label\\_path 4} Label file path item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string label_path > ``` #### mean {#mean 11} Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean > ``` #### scale {#scale 11} Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale > ``` ### FaceLandmarksObject {#FaceLandmarksObject} FaceLandmarksObject class > C++ defination code: > ```cpp > class FaceLandmarksObject > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 28} ```python def __init__(self) > None ``` Valid or not(score > conf_th when detect). item description **type** func **static** False > C++ defination code: > ```cpp > FaceLandmarksObject() > ``` #### valid {#valid} Valid or not(score > conf_th when detect). item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > bool valid > ``` #### score {#score 5} whether face in image score, value from 0 to 1.0. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > float score > ``` #### points {#points 4} landmarks points, format: x0, y0, ..., xn 1, yn 1. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<int> points > ``` #### points\\_z {#points\\_z} landmarks points, format: z0, z1, ..., zn 1. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<int> points_z > ``` ### FaceLandmarks {#FaceLandmarks} FaceLandmarks class > C++ defination code: > ```cpp > class FaceLandmarks > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 29} ```python def __init__(self, model: str '') > None ``` Constructor of FaceLandmarks class item description **type** func **param** **model**: model path, default empty, you can load model later by load function.<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False > C++ defination code: > ```cpp > FaceLandmarks(const string &model \"\") > ``` #### load {#load 19} ```python def load(self, model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: Model path want to load<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err load(const string &model) > ``` #### detect {#detect 7} ```python def detect(self, img: maix.image.Image, conf_th: float 0.5, landmarks_abs: bool True, landmarks_rel: bool False) > FaceLandmarksObject ``` Detect objects from image item description **type** func **param** **img**: Image want to detect, if image's size not match model input's, will auto resize with fit method.<br>**conf_th**: Hand detect confidence threshold, default 0.7.<br>**landmarks_rel**: outputs the relative coordinates of 21 points with respect to the top left vertex of the hand.<br>In obj.points, the last 21x2 values are arranged as x0y0x1y1...x20y20.<br>Value from 0 to obj.w.<br> **throw** If image format not match model input format, will throw err::Exception. **return** Object list. In C++, you should delete it after use.<br>Object's points value format: box_topleft_x, box_topleft_y, box_topright_x, box_topright_y, box_bottomright_x, box_bottomright_y， box_bottomleft_x, box_bottomleft_y,<br>x0, y0, z1, x1, y1, z2, ..., x20, y20, z20.<br>If landmarks_rel is True, will be box_topleft_x, box_topleft_y...,x20,y20,z20,x0_rel,y0_rel,...,x20_rel,y20_rel.<br>Z is depth, the larger the value, the farther away from the palm, and the positive value means closer to the camera. **static** False > C++ defination code: > ```cpp > nn::FaceLandmarksObject *detect(image::Image &img, float conf_th 0.5, bool landmarks_abs true, bool landmarks_rel false) > ``` #### crop\\_image {#crop\\_image} ```python def crop_image(self, img: maix.image.Image, x: int, y: int, w: int, h: int, points: list[int], new_width: int 1, new_height: int 1, scale: float 1.2) > maix.image.Image ``` Crop image from source image by 2 points(2 eyes) item description **type** func **param** **x,y,w,h**: face rectangle, x,y is left top point.<br>**img**: source image<br>**points**: 2 points, eye_left_x, eye_left_y, eye_right_x, eye_right_y<br>**scale**: crop size scale relative to rectangle's max side length(w or h), final value is `scale *max(w, h)`,default 1.2.<br> **static** False > C++ defination code: > ```cpp > maix::image::Image *crop_image(maix::image::Image &img, int x, int y, int w, int h, std::vector<int> points, int new_width 1, int new_height 1, float scale 1.2) > ``` #### input\\_size {#input\\_size 13} ```python def input_size(self, detect: bool True) > maix.image.Size ``` Get model input size item description **type** func **param** **detect**: detect or landmarks model, default true.<br> **return** model input size **static** False > C++ defination code: > ```cpp > image::Size input_size(bool detect true) > ``` #### input\\_width {#input\\_width 14} ```python def input_width(self, detect: bool True) > int ``` Get model input width item description **type** func **param** **detect**: detect or landmarks model, default true.<br> **return** model input size of width **static** False > C++ defination code: > ```cpp > int input_width(bool detect true) > ``` #### input\\_height {#input\\_height 14} ```python def input_height(self, detect: bool True) > int ``` Get model input height item description **type** func **param** **detect**: detect or landmarks model, default true.<br> **return** model input size of height **static** False > C++ defination code: > ```cpp > int input_height(bool detect true) > ``` #### input\\_format {#input\\_format 14} ```python def input_format(self) > maix.image.Format ``` Get input image format item description **type** func **return** input image format, image::Format type. **static** False > C++ defination code: > ```cpp > image::Format input_format() > ``` #### draw\\_face {#draw\\_face} ```python def draw_face(self, img: maix.image.Image, points: list[int], num: int, points_z: list[int] [], r_min: int 2, r_max: int 4) > None ``` Draw hand and landmarks on image item description **type** func **param** **img**: image object, maix.image.Image type.<br>**leftright,**: 0 means left, 1 means right<br>**points**: points result from detect method: x0, y0, x1, y1, ..., xn 1, yn 1.<br>**points_z**: points result from detect method: z0, z1, ..., zn 1.<br>**r_min**: min radius of points.<br>**r_max**: min radius of points.<br> **static** False > C++ defination code: > ```cpp > void draw_face(image::Image &img, const std::vector<int> &points, int num, const std::vector<int> &points_z std::vector<int>(), int r_min 2, int r_max 4) > ``` #### mean {#mean 12} Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean > ``` #### scale {#scale 12} Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale > ``` #### landmarks\\_num {#landmarks\\_num} landmarks number. item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > int landmarks_num > ``` ### YOLOv5 {#YOLOv5} YOLOv5 class > C++ defination code: > ```cpp > class YOLOv5 > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 30} ```python def __init__(self, model: str '', dual_buff: bool True) > None ``` Constructor of YOLOv5 class item description **type** func **param** **model**: model path, default empty, you can load model later by load function.<br>**dual_buff**: direction [in], prepare dual input output buffer to accelarate forward, that is, when NPU is forwarding we not wait and prepare the next input buff.<br>If you want to ensure every time forward output the input's result, set this arg to false please.<br>Default true to ensure speed.<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False > C++ defination code: > ```cpp > YOLOv5(const string &model \"\", bool dual_buff true) > ``` #### load {#load 20} ```python def load(self, model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: Model path want to load<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err load(const string &model) > ``` #### detect {#detect 8} ```python def detect(self, img: maix.image.Image, conf_th: float 0.5, iou_th: float 0.45, fit: maix.image.Fit ..., sort: int 0) > list[Object] ``` Detect objects from image item description **type** func **param** **img**: Image want to detect, if image's size not match model input's, will auto resize with fit method.<br>**conf_th**: Confidence threshold, default 0.5.<br>**iou_th**: IoU threshold, default 0.45.<br>**fit**: Resize method, default image.Fit.FIT_CONTAIN.<br>**sort**: sort result according to object size, default 0 means not sort, 1 means bigger in front, 1 means smaller in front.<br> **throw** If image format not match model input format, will throw err::Exception. **return** Object list. In C++, you should delete it after use. **static** False > C++ defination code: > ```cpp > std::vector<nn::Object> *detect(image::Image &img, float conf_th 0.5, float iou_th 0.45, maix::image::Fit fit maix::image::FIT_CONTAIN, int sort 0) > ``` #### input\\_size {#input\\_size 14} ```python def input_size(self) > maix.image.Size ``` Get model input size item description **type** func **return** model input size **static** False > C++ defination code: > ```cpp > image::Size input_size() > ``` #### input\\_width {#input\\_width 15} ```python def input_width(self) > int ``` Get model input width item description **type** func **return** model input size of width **static** False > C++ defination code: > ```cpp > int input_width() > ``` #### input\\_height {#input\\_height 15} ```python def input_height(self) > int ``` Get model input height item description **type** func **return** model input size of height **static** False > C++ defination code: > ```cpp > int input_height() > ``` #### input\\_format {#input\\_format 15} ```python def input_format(self) > maix.image.Format ``` Get input image format item description **type** func **return** input image format, image::Format type. **static** False > C++ defination code: > ```cpp > image::Format input_format() > ``` #### labels {#labels 8} Labels list item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<string> labels > ``` #### label\\_path {#label\\_path 5} Label file path item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string label_path > ``` #### mean {#mean 13} Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean > ``` #### scale {#scale 13} Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale > ``` #### anchors {#anchors} Get anchors item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> anchors > ``` ### Speech {#Speech} Speech > C++ defination code: > ```cpp > class Speech > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 31} ```python def __init__(self, model: str '') > None ``` Construct a new Speech object item description **type** func **param** **model**: model path, default empty, you can load model later by load function.<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False > C++ defination code: > ```cpp > Speech(const string &model \"\") > ``` #### load {#load 21} ```python def load(self, model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: Model path want to load<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err load(const string &model) > ``` #### init {#init 3} ```python def init(self, dev_type: SpeechDevice, device_name: str '') > maix.err.Err ``` Init the ASR library and select the type and name of the audio device. item description **type** func **param** **dev_type**: device type want to detect, can choose between WAV, PCM, or MIC.<br>**device_name**: device name want to detect, can choose a WAV file, a PCM file, or a MIC device name.<br> **throw** **1**. If am model is not loaded, will throw err::ERR_NOT_IMPL.<br>**2**. If device is not supported, will throw err::ERR_NOT_IMPL.<br> **return** err::Err type, if init success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err init(nn::SpeechDevice dev_type, const string &device_name \"\") > ``` #### devive {#devive} ```python def devive(self, dev_type: SpeechDevice, device_name: str) > maix.err.Err ``` Reset the device, usually used for PCM/WAV recognition,\\nsuch as identifying the next WAV file. item description **type** func **param** **dev_type**: device type want to detect, can choose between WAV, PCM, or MIC.<br>**device_name**: device name want to detect, can choose a WAV file, a PCM file, or a MIC device name.<br> **throw** If device is not supported, will throw err::ERR_NOT_IMPL. **return** err::Err type, if init success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err devive(nn::SpeechDevice dev_type, const string &device_name) > ``` #### dec\\_deinit {#dec\\_deinit} ```python def dec_deinit(self, decoder: SpeechDecoder) > None ``` Deinit the decoder. item description **type** func **param** **decoder**: decoder type want to deinit<br>can choose between DECODER_RAW, DECODER_DIG, DECODER_LVCSR, DECODER_KWS or DECODER_ALL.<br> **throw** If device is not supported, will throw err::ERR_NOT_IMPL. **static** False > C++ defination code: > ```cpp > void dec_deinit(nn::SpeechDecoder decoder) > ``` #### raw {#raw} ```python def raw(self, callback: typing.Callable[[list[tuple[int, float]], int], None]) > maix.err.Err ``` Init raw decoder, it will output the prediction results of the original AM. item description **type** func **param** **callback**: raw decoder user callback.<br> **return** err::Err type, if init success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err raw(std::function<void(std::vector<std::pair<int, float>>, int)> callback) > ``` #### digit {#digit} ```python def digit(self, blank: int, callback: typing.Callable[[str, int], None]) > maix.err.Err ``` Init digit decoder, it will output the Chinese digit recognition results within the last 4 seconds. item description **type** func **param** **blank**: If it exceeds this value, insert a '_' in the output result to indicate idle mute.<br>**callback**: digit decoder user callback.<br> **return** err::Err type, if init success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err digit(int blank, std::function<void(char*, int)> callback) > ``` #### kws {#kws} ```python def kws(self, kw_tbl: list[str], kw_gate: list[float], callback: typing.Callable[[list[float], int], None], auto_similar: bool True) > maix.err.Err ``` Init kws decoder, it will output a probability list of all registered keywords in the latest frame,\\nusers can set their own thresholds for wake up. item description **type** func **param** **kw_tbl**: Keyword list, filled in with spaces separated by pinyin, for example: xiao3 ai4 tong2 xue2<br>**kw_gate**: kw_gate, keyword probability gate table, the number should be the same as kw_tbl<br>**auto_similar**: Whether to perform automatic homophone processing,<br>setting it to true will automatically calculate the probability by using pinyin with different tones as homophones<br>**callback**: digit decoder user callback.<br> **return** err::Err type, if init success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err kws(std::vector<string> kw_tbl, std::vector<float> kw_gate, std::function<void(std::vector<float>, int)> callback, bool auto_similar true) > ``` #### lvcsr {#lvcsr} ```python def lvcsr(self, sfst_name: str, sym_name: str, phones_txt: str, words_txt: str, callback: typing.Callable[[tuple[str, str], int], None], beam: float 8, bg_prob: float 10, scale: float 0.5, mmap: bool False) > maix.err.Err ``` Init lvcsr decoder, it will output continuous speech recognition results (less than 1024 Chinese characters). item description **type** func **param** **sfst_name**: Sfst file path.<br>**sym_name**: Sym file path (output symbol table).<br>**phones_txt**: Path to phones.bin (pinyin table).<br>**words_txt**: Path to words.bin (dictionary table).<br>**callback**: lvcsr decoder user callback.<br>**beam**: The beam size for WFST search is set to 8 by default, and it is recommended to be between 3 and 9.<br>The larger the size, the larger the search space, and the more accurate but slower the search.<br>**bg_prob**: The absolute value of the natural logarithm of the default probability value for background pinyin<br>outside of BEAM CNT is set to 10 by default.<br>**scale**: acoustics_cost log(pny_prob)*scale.<br>**mmap**: use mmap to load the WFST decoding image,<br>If set to true, the beam should be less than 5.<br> **return** err::Err type, if init success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err lvcsr(const string &sfst_name, const string &sym_name, > const string &phones_txt, const string &words_txt, > std::function<void(std::pair<char*, char*>, int)> callback, > float beam 8, float bg_prob 10, float scale 0.5, bool mmap false) > ``` #### run {#run} ```python def run(self, frame: int) > int ``` Run speech recognition, user can run 1 frame at a time and do other processing after running,\\nor it can run continuously within a thread and be stopped by an external thread. item description **type** func **param** **frame**: The number of frames per run.<br> **return** int type, return actual number of frames in the run. **static** False > C++ defination code: > ```cpp > int run(int frame) > ``` #### clear {#clear 2} ```python def clear(self) > None ``` Reset internal cache operation item description **type** func **static** False > C++ defination code: > ```cpp > void clear() > ``` #### frame\\_time {#frame\\_time} ```python def frame_time(self) > int ``` Get the time of one frame. item description **type** func **return** int type, return the time of one frame. **static** False > C++ defination code: > ```cpp > int frame_time() > ``` #### similar {#similar} ```python def similar(self, pny: str, similar_pnys: list[str]) > maix.err.Err ``` Manually register mute words, and each pinyin can register up to 10 homophones,\\nplease note that using this interface to register homophones will overwrite,\\nthe homophone table automatically generated in the \\\"automatic homophone processing\\\" feature. item description **type** func **param** **dev_type**: device type want to detect, can choose between WAV, PCM, or MIC.<br>**device_name**: device name want to detect, can choose a WAV file, a PCM file, or a MIC device name.<br> **return** err::Err type, if init success, return err::ERR_NONE **static** False > C++ defination code: > ```cpp > err::Err similar(const string &pny, std::vector<std::string> similar_pnys) > ``` #### skip\\_frames {#skip\\_frames} ```python def skip_frames(self, num: int) > None ``` Run some frames and drop, this can be used to avoid\\nincorrect recognition results when switching decoders. item description **type** func **param** **num**: number of frames to run and drop<br> **static** False > C++ defination code: > ```cpp > void skip_frames(int num) > ``` #### mean {#mean 14} Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean > ``` #### scale {#scale 14} Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale > ``` #### dev\\_type {#dev\\_type} ```python def dev_type(self) > SpeechDevice ``` get device type item description **type** func **return** nn::SpeechDevice type, see SpeechDevice of this module **static** False > C++ defination code: > ```cpp > nn::SpeechDevice dev_type() > ``` ### HandLandmarks {#HandLandmarks} HandLandmarks class > C++ defination code: > ```cpp > class HandLandmarks > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_ 32} ```python def __init__(self, model: str '') > None ``` Constructor of HandLandmarks class item description **type** func **param** **model**: model path, default empty, you can load model later by load function.<br> **throw** If model arg is not empty and load failed, will throw err::Exception. **static** False > C++ defination code: > ```cpp > HandLandmarks(const string &model \"\") > ``` #### load {#load 22} ```python def load(self, model: str) > maix.err.Err ``` Load model from file item description **type** func **param** **model**: Model path want to load<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err load(const string &model) > ``` #### detect {#detect 9} ```python def detect(self, img: maix.image.Image, conf_th: float 0.7, iou_th: float 0.45, conf_th2: float 0.8, landmarks_rel: bool False) > Objects ``` Detect objects from image item description **type** func **param** **img**: Image want to detect, if image's size not match model input's, will auto resize with fit method.<br>**conf_th**: Hand detect confidence threshold, default 0.7.<br>**iou_th**: IoU threshold, default 0.45.<br>**conf_th2**: Hand detect confidence second time check threshold, default 0.8.<br>**landmarks_rel**: outputs the relative coordinates of 21 points with respect to the top left vertex of the hand.<br>In obj.points, the last 21x2 values are arranged as x0y0x1y1...x20y20.<br>Value from 0 to obj.w.<br> **throw** If image format not match model input format, will throw err::Exception. **return** Object list. In C++, you should delete it after use.<br>Object's points value format: box_topleft_x, box_topleft_y, box_topright_x, box_topright_y, box_bottomright_x, box_bottomright_y， box_bottomleft_x, box_bottomleft_y,<br>x0, y0, z1, x1, y1, z2, ..., x20, y20, z20.<br>If landmarks_rel is True, will be box_topleft_x, box_topleft_y...,x20,y20,z20,x0_rel,y0_rel,...,x20_rel,y20_rel.<br>Z is depth, the larger the value, the farther away from the palm, and the positive value means closer to the camera. **static** False > C++ defination code: > ```cpp > nn::Objects *detect(image::Image &img, float conf_th 0.7, float iou_th 0.45, float conf_th2 0.8, bool landmarks_rel false) > ``` #### input\\_size {#input\\_size 15} ```python def input_size(self, detect: bool True) > maix.image.Size ``` Get model input size item description **type** func **param** **detect**: detect or landmarks model, default true.<br> **return** model input size **static** False > C++ defination code: > ```cpp > image::Size input_size(bool detect true) > ``` #### input\\_width {#input\\_width 16} ```python def input_width(self, detect: bool True) > int ``` Get model input width item description **type** func **param** **detect**: detect or landmarks model, default true.<br> **return** model input size of width **static** False > C++ defination code: > ```cpp > int input_width(bool detect true) > ``` #### input\\_height {#input\\_height 16} ```python def input_height(self, detect: bool True) > int ``` Get model input height item description **type** func **param** **detect**: detect or landmarks model, default true.<br> **return** model input size of height **static** False > C++ defination code: > ```cpp > int input_height(bool detect true) > ``` #### input\\_format {#input\\_format 16} ```python def input_format(self) > maix.image.Format ``` Get input image format item description **type** func **return** input image format, image::Format type. **static** False > C++ defination code: > ```cpp > image::Format input_format() > ``` #### draw\\_hand {#draw\\_hand} ```python def draw_hand(self, img: maix.image.Image, leftright: int, points: list[int], r_min: int 4, r_max: int 10, box: bool True, box_thickness: int 1, box_color_l: maix.image.Color ..., box_color_r: maix.image.Color ...) > None ``` Draw hand and landmarks on image item description **type** func **param** **img**: image object, maix.image.Image type.<br>**leftright,**: 0 means left, 1 means right<br>**points**: points result from detect method: box_topleft_x, box_topleft_y, box_topright_x, box_topright_y, box_bottomright_x, box_bottomright_y， box_bottomleft_x, box_bottomleft_y,<br>x0, y0, z1, x1, y1, z2, ..., x20, y20, z20<br>**r_min**: min radius of points.<br>**r_max**: min radius of points.<br>**box**: draw box or not, default true.<br>**box_color**: color of box.<br> **static** False > C++ defination code: > ```cpp > void draw_hand(image::Image &img, int leftright, const std::vector<int> &points, int r_min 4, int r_max 10, bool box true, int box_thickness 1, image::Color box_color_l image::COLOR_RED, image::Color box_color_r image::COLOR_GREEN) > ``` #### labels {#labels 9} Labels list item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<string> labels > ``` #### label\\_path {#label\\_path 6} Label file path item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::string label_path > ``` #### mean {#mean 15} Get mean value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> mean > ``` #### scale {#scale 15} Get scale value, list type item description **type** var **static** False **readonly** False > C++ defination code: > ```cpp > std::vector<float> scale > ```"},"/maixpy/api/maix/ext_dev.html":{"title":"maix.ext_dev","content":" title: maix.ext_dev maix.ext_dev module > You can use `maix.ext_dev` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} module brief [imu](./ext_dev/imu.html) maix.ext_dev.imu module [qmi8658](./ext_dev/qmi8658.html) maix.ext_dev.qmi8658 module [cmap](./ext_dev/cmap.html) maix.ext_dev.cmap module [mlx90640](./ext_dev/mlx90640.html) maix.ext_dev.mlx90640 module [tof100](./ext_dev/tof100.html) maix.ext_dev.tof100 module [tmc2209](./ext_dev/tmc2209.html) maix.ext_dev.tmc2209 module [fp5510](./ext_dev/fp5510.html) maix.ext_dev.fp5510 module [bm8563](./ext_dev/bm8563.html) maix.ext_dev.bm8563 module [pmu](./ext_dev/pmu.html) maix.ext_dev.pmu module [axp2101](./ext_dev/axp2101.html) maix.ext_dev.axp2101 module [lsm6dsowtr](./ext_dev/lsm6dsowtr.html) maix.ext_dev.lsm6dsowtr module ## Enum {#Enum} ## Variable {#Variable} ## Function {#Function} ## Class {#Class}"},"/maixpy/api/maix/peripheral/pwm.html":{"title":"maix.peripheral.pwm","content":" title: maix.peripheral.pwm maix.peripheral.pwm module > You can use `maix.peripheral.pwm` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ## Variable {#Variable} ## Function {#Function} ## Class {#Class} ### PWM {#PWM} Peripheral pwm class > C++ defination code: > ```cpp > class PWM > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, id: int, freq: int 1000, duty: float 0, enable: bool True, duty_val: int 1) > None ``` PWM constructor item description **type** func **param** **pin**: direction [in], pwm id, int type, like 0, 1, 2 etc.<br>**freq**: direction [in], pwm frequency, unit: Hz. int type. default is 1000<br>**duty**: direction [in], pwm duty. double type. range is [0, 100], default is 0.<br>**enable**: direction [in], enable pwm output right now. bool type. default is true, if false, you need to call enable() to enable pwm output.<br>**duty_val**: direction [in], pwm duty value, int type. default 1 means not set and auto calculate by freq and duty.<br>This arg directly set pwm duty value, if set, will ignore duty arg.<br>duty_val duty / 100 * T_ns, T_ns 1 / freq * 1000000000.<br> **throw** If args error or init pwm failed, will throw err::Exception **static** False > C++ defination code: > ```cpp > PWM(int id, int freq 1000, double duty 0, bool enable true, int duty_val 1) > ``` #### duty {#duty} ```python def duty(self, duty: float 1) > float ``` get or set pwm duty item description **type** func **param** **duty**: direction [in], pwm duty, double type, value in [0, 100], default 1 means only read.<br> **return** current duty, float type, if set and set failed will return err::Err **static** False > C++ defination code: > ```cpp > double duty(double duty 1) > ``` #### duty\\_val {#duty\\_val} ```python def duty_val(self, duty_val: int 1) > int ``` set pwm duty value item description **type** func **param** **duty_val**: direction [in], pwm duty value. int type. default is 1<br>duty_val > 0 means set duty_val<br>duty_val 1 or not set, return current duty_val<br> **return** int type<br>when get duty_val, return current duty_val, else return err::Err code. **static** False > C++ defination code: > ```cpp > int duty_val(int duty_val 1) > ``` #### freq {#freq} ```python def freq(self, freq: int 1) > int ``` get or set pwm frequency item description **type** func **param** **freq**: direction [in], pwm frequency. int type. default is 1<br>freq > 0, set freq<br>freq 1 or not set, return current freq<br> **return** int type, current freq, if set and set failed will return err::Err **static** False > C++ defination code: > ```cpp > int freq(int freq 1) > ``` #### enable {#enable} ```python def enable(self) > maix.err.Err ``` set pwm enable item description **type** func **return** err::Err type, err.Err.ERR_NONE means success **static** False > C++ defination code: > ```cpp > err::Err enable() > ``` #### disable {#disable} ```python def disable(self) > maix.err.Err ``` set pwm disable item description **type** func **return** err::Err type, err.Err.ERR_NONE means success **static** False > C++ defination code: > ```cpp > err::Err disable() > ``` #### is\\_enabled {#is\\_enabled} ```python def is_enabled(self) > bool ``` get pwm enable status item description **type** func **return** bool type, true means enable, false means disable **static** False > C++ defination code: > ```cpp > bool is_enabled() > ```"},"/maixpy/api/maix/peripheral/i2c.html":{"title":"maix.peripheral.i2c","content":" title: maix.peripheral.i2c maix.peripheral.i2c module > You can use `maix.peripheral.i2c` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### AddrSize {#AddrSize} Address size enum item describe **values** **SEVEN_BIT**: 7 bit address mode<br>**TEN_BIT**: 10 bit address mode<br> > C++ defination code: > ```cpp > enum AddrSize > { > SEVEN_BIT 7, // 7 bit address mode > TEN_BIT 10 // 10 bit address mode > } > ``` ### Mode {#Mode} I2C mode enum item describe **values** **MASTER**: master mode<br>**SLAVE**: slave mode<br> > C++ defination code: > ```cpp > enum Mode > { > MASTER 0x00, // master mode > SLAVE 0x01 // slave mode > } > ``` ## Variable {#Variable} ## Function {#Function} ### list\\_devices {#list\\_devices} ```python def list_devices() > list[int] ``` Get supported i2c bus devices. item description **return** i2c bus devices list, int type, is the i2c bus id. > C++ defination code: > ```cpp > std::vector<int> list_devices() > ``` ## Class {#Class} ### I2C {#I2C} Peripheral i2c class > C++ defination code: > ```cpp > class I2C > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, id: int, mode: Mode, freq: int 100000, addr_size: AddrSize ...) > None ``` I2C Device constructor\\nthis constructor will be export to MaixPy as _maix.example.Example.__init__ item description **type** func **param** **id**: direction [in], i2c bus id, int type, e.g. 0, 1, 2<br>**freq**: direction [in], i2c clock, int type, default is 100000(100kbit/s), will auto set fast mode if freq > 100000.<br>**mode**: direction [in], mode of i2c, i2c.Mode.SLAVE or i2c.Mode.MASTER.<br>**addr_size**: direction [in], address length of i2c, i2c.AddrSize.SEVEN_BIT or i2c.AddrSize.TEN_BIT.<br> **throw** err::Exception if open i2c device failed. **static** False > C++ defination code: > ```cpp > I2C(int id, i2c::Mode mode, int freq 100000, i2c::AddrSize addr_size i2c::AddrSize::SEVEN_BIT) > ``` #### scan {#scan} ```python def scan(self, addr: int 1) > list[int] ``` scan all i2c salve address on the bus item description **type** func **param** **addr**: If 1, only scan this addr, or scan from 0x08~0x77, default 1.<br> **return** the list of i2c slave address, int list type. **static** False > C++ defination code: > ```cpp > std::vector<int> scan(int addr 1) > ``` #### writeto {#writeto} ```python def writeto(self, addr: int, data: maix.Bytes(bytes)) > int ``` write data to i2c slave item description **type** func **param** **addr**: direction [in], i2c slave address, int type<br>**data**: direction [in], data to write, bytes type.<br>Note: The range of value should be in [0,255].<br> **return** if success, return the length of written data, error occurred will return err::Err. **static** False > C++ defination code: > ```cpp > int writeto(int addr, const Bytes &data) > ``` #### readfrom {#readfrom} ```python def readfrom(*args, **kwargs) ``` read data from i2c slave item description **type** func **param** **addr**: direction [in], i2c slave address, int type<br>**len**: direction [in], data length to read, int type<br> **return** the list of data read from i2c slave, bytes type, you should delete it after use in C++.<br>If read failed, return nullptr in C++, None in MaixPy. **static** False > C++ defination code: > ```cpp > Bytes* readfrom(int addr, int len) > ``` #### writeto\\_mem {#writeto\\_mem} ```python def writeto_mem(self, addr: int, mem_addr: int, data: maix.Bytes(bytes), mem_addr_size: int 8, mem_addr_le: bool False) > int ``` write data to i2c slave's memory address item description **type** func **param** **addr**: direction [in], i2c slave address, int type<br>**mem_addr**: direction [in], memory address want to write, int type.<br>**data**: direction [in], data to write, bytes type.<br>**mem_addr_size**: direction [in], memory address size, default is 8.<br>**mem_addr_le**: direction [in], memory address little endian, default is false, that is send high byte first.<br> **return** data length written if success, error occurred will return err::Err. **static** False > C++ defination code: > ```cpp > int writeto_mem(int addr, int mem_addr, const Bytes &data, int mem_addr_size 8, bool mem_addr_le false) > ``` #### readfrom\\_mem {#readfrom\\_mem} ```python def readfrom_mem(*args, **kwargs) ``` read data from i2c slave item description **type** func **param** **addr**: direction [in], i2c slave address, int type<br>**mem_addr**: direction [in], memory address want to read, int type.<br>**len**: direction [in], data length to read, int type<br>**mem_addr_size**: direction [in], memory address size, default is 8.<br>**mem_addr_le**: direction [in], memory address little endian, default is false, that is send high byte first.<br> **return** the list of data read from i2c slave, bytes type, you should delete it after use in C++.<br>If read failed, return nullptr in C++, None in MaixPy. **static** False > C++ defination code: > ```cpp > Bytes* readfrom_mem(int addr, int mem_addr, int len, int mem_addr_size 8, bool mem_addr_le false) > ```"},"/maixpy/api/maix/peripheral/timer.html":{"title":"maix.peripheral.timer","content":" title: maix.peripheral.timer maix.peripheral.timer module > You can use `maix.peripheral.timer` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ## Variable {#Variable} ## Function {#Function} ## Class {#Class} ### TIMER {#TIMER} Peripheral timer class > C++ defination code: > ```cpp > class TIMER > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self) > None ``` TIMER constructor item description **type** func **static** False > C++ defination code: > ```cpp > TIMER() > ```"},"/maixpy/api/maix/peripheral/key.html":{"title":"maix.peripheral.key","content":" title: maix.peripheral.key maix.peripheral.key module > You can use `maix.peripheral.key` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### Keys {#Keys} Keys enum, id the same as linux input.h(input event codes.h) item describe **values** **KEY_NONE**: <br>**KEY_ESC**: <br>**KEY_SPACE**: <br>**KEY_LEFT**: <br>**KEY_RIGHT**: <br>**KEY_POWER**: <br>**KEY_OK**: <br>**KEY_OPTION**: <br>**KEY_NEXT**: <br>**KEY_PREV**: <br> > C++ defination code: > ```cpp > enum Keys{ > KEY_NONE 0x000, > KEY_ESC 0x001, > KEY_SPACE 0x039, > KEY_LEFT 0x069, > KEY_RIGHT 0x06a, > KEY_POWER 0x074, > KEY_OK 0x160, > KEY_OPTION 0x165, > KEY_NEXT 0x197, > KEY_PREV 0x19c, > } > ``` ### State {#State} Key state enum item describe **values** **KEY_RELEASED**: <br>**KEY_PRESSED**: <br>**KEY_LONG_PRESSED**: <br> > C++ defination code: > ```cpp > enum State{ > KEY_RELEASED 0, > KEY_PRESSED 1, > KEY_LONG_PRESSED 2, > } > ``` ## Variable {#Variable} ## Function {#Function} ### add\\_default\\_listener {#add\\_default\\_listener} Add default listener, if you want to exit app when press ok button, you can just call this function.\\nThis function is auto called in MaixPy' startup code, so you don't need to call it in MaixPy.\\nCreate Key object will auto call rm_default_listener() to cancel the default ok button function.\\nWhen ok button pressed, a SIGINT signal will be raise and call app.set_exit_flag(True). > C++ defination code: > ```cpp > void add_default_listener() > ``` ### rm\\_default\\_listener {#rm\\_default\\_listener} Remove default listener, if you want to cancel the default ok button function(exit app), you can just call this function. > C++ defination code: > ```cpp > void rm_default_listener() > ``` ## Class {#Class} ### Key {#Key} Key input class > C++ defination code: > ```cpp > class Key > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, callback: typing.Callable[[int, int], None] None, open: bool True, device: str '', long_press_time: int 2000) > None ``` Key Device constructor item description **type** func **param** **callback**: When key triggered and callback is not empty(empty In MaixPy is None, in C++ is nullptr),<br>callback will be called with args key(key.Keys) and value(key.State).<br>If set to null, you can get key value by read() function.<br>This callback called in a standalone thread, so you can block a while in callback, and you should be carefully when operate shared data.<br>**open**: auto open device in constructor, if false, you need call open() to open device.<br>**device**: Specifies the input device to use. The default initializes all keys,<br>for a specific device, provide the path (e.g., \"/dev/input/device\").<br>**long_press_time**: The duration (in milliseconds) from pressing the key to triggering the long press event. Default is 2000ms.<br> **static** False > C++ defination code: > ```cpp > Key(std::function<void(int, int)> callback nullptr, bool open true, const string &device \"\", int long_press_time 2000) > ``` #### open {#open} ```python def open(self) > maix.err.Err ``` Open(Initialize) key device, if already opened, will close first and then open. item description **type** func **return** err::Err type, err.Err.ERR_NONE means success **static** False > C++ defination code: > ```cpp > err::Err open() > ``` #### close {#close} ```python def close(self) > maix.err.Err ``` Close key device item description **type** func **return** err::Err type, err.Err.ERR_NONE means success **static** False > C++ defination code: > ```cpp > err::Err close() > ``` #### is\\_opened {#is\\_opened} ```python def is_opened(self) > bool ``` Check key device is opened item description **type** func **return** bool type, true means opened, false means closed **static** False > C++ defination code: > ```cpp > bool is_opened() > ``` #### read {#read} ```python def read(self) > tuple[int, int] ``` Read key input, and return key and value, if callback is set, DO NOT call this function manually. item description **type** func **return** list type, first is key(maix.key.Keys), second is value(maix.key.State), if no key input, return [0, 0] **throw** If read failed, will throw maix.err.Exception. **static** False > C++ defination code: > ```cpp > std::pair<int, int> read() > ``` #### long\\_press\\_time {#long\\_press\\_time} ```python def long_press_time(self, press_time: int 1) > int ``` Sets and retrieves the key's long press time. item description **type** func **param** **press_time**: The long press time to set for the key.<br>Setting it to 0 will disable the long press event.<br> **return** int type, the current long press time for the key (in milliseconds). **static** False > C++ defination code: > ```cpp > int long_press_time(int press_time 1) > ```"},"/maixpy/api/maix/peripheral/hid.html":{"title":"maix.peripheral.hid","content":" title: maix.peripheral.hid maix.peripheral.hid module > You can use `maix.peripheral.hid` to access this module with MaixPy > This module is generated from [MaixPy](https://github.com/sipeed/MaixPy) and [MaixCDK](https://github.com/sipeed/MaixCDK) ## Module {#Module} No module ## Enum {#Enum} ### DeviceType {#DeviceType} Device enum of hid item describe **values** **DEVICE_MOUSE**: <br>**DEVICE_KEYBOARD**: <br>**DEVICE_TOUCHPAD**: <br> > C++ defination code: > ```cpp > enum DeviceType { > DEVICE_MOUSE 0, > DEVICE_KEYBOARD, > DEVICE_TOUCHPAD > } > ``` ## Variable {#Variable} ## Function {#Function} ## Class {#Class} ### Hid {#Hid} Hid class > C++ defination code: > ```cpp > class Hid > ``` #### \\_\\_init\\_\\_ {#\\_\\_init\\_\\_} ```python def __init__(self, device_type: DeviceType, open: bool True) > None ``` Hid Device constructor item description **type** func **param** **device_type**: Device type, used to select mouse, keyboard, or touchpad.<br>**open**: auto open device in constructor, if false, you need call open() to open device<br> **static** False > C++ defination code: > ```cpp > Hid(hid::DeviceType device_type, bool open true) > ``` #### open {#open} ```python def open(self) > maix.err.Err ``` Open hid device item description **type** func **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err open() > ``` #### close {#close} ```python def close(self) > maix.err.Err ``` Close hid device item description **type** func **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err close() > ``` #### write {#write} ```python def write(self, data: list[int]) > maix.err.Err ``` Write data to hid device item description **type** func **param** **data**: data to write<br>For the keyboard, 8 bytes of data need to be written, with the format as follows:<br>data [0x00, #<br>0x00, #<br>0x00, # Key value. Refer to the \"Universal Serial Bus HID Usage Tables\" section of the official documentation(https://www.usb.org).<br>0x00, #<br>0x00, #<br>0x00, #<br>0x00, #<br>0x00] #<br>For the mouse, 4 bytes of data need to be written, with the format as follows:<br>data [0x00, # Button state<br>0x00: no button pressed<br>0x01: press left button<br>0x02: press right button<br>0x04: press middle button<br>x, # X axis relative coordinates. Signed number, positive values for x indicate movement to the right<br>y, # Y axis relative coordinates. Signed number, positive values for y indicate movement downward<br>0x00] # Wheel movement. Signed number, positive values indicate downward movement.<br>For the touchpad, 6 bytes of data need to be written, with the format as follows:<br>data [0x00, # Button state (0: no button pressed, 0x01: press left button, 0x10, press right button.)<br>x & 0xFF, (x >> 8) & 0xFF, # X axis absolute coordinate, 0 means unused.<br>Note: You must map the target position to the range [0x1, 0x7FFF]. This means x value <position_to_move> * 0x7FFF / <actual_screen_width><br>y & 0xFF, (y >> 8) & 0xFF, # Y axis absolute coordinate, 0 means unused.<br>Note: You must map the target position to the range [0x1, 0x7FFF]. This means y value <position_to_move> * 0x7FFF / <actual_screen_height><br>0x00, # Wheel movement. Signed number, positive values indicate downward movement.<br> **return** err::Err **static** False > C++ defination code: > ```cpp > err::Err write(std::vector<int> &data) > ``` #### is\\_opened {#is\\_opened} ```python def is_opened(self) > bool ``` Check if hid device is opened item description **type** func **return** bool **static** False > C++ defination code: > ```cpp > bool is_opened() > ```"}}